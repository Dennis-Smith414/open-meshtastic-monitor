// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: meshtastic/config.proto
// Protobuf C++ Version: 6.31.1

#ifndef meshtastic_2fconfig_2eproto_2epb_2eh
#define meshtastic_2fconfig_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6031001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "meshtastic/device_ui.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_meshtastic_2fconfig_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_meshtastic_2fconfig_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable descriptor_table_meshtastic_2fconfig_2eproto;
}  // extern "C"
namespace meshtastic {
enum Config_BluetoothConfig_PairingMode : int;
extern const uint32_t Config_BluetoothConfig_PairingMode_internal_data_[];
enum Config_DeviceConfig_BuzzerMode : int;
extern const uint32_t Config_DeviceConfig_BuzzerMode_internal_data_[];
enum Config_DeviceConfig_RebroadcastMode : int;
extern const uint32_t Config_DeviceConfig_RebroadcastMode_internal_data_[];
enum Config_DeviceConfig_Role : int;
extern const uint32_t Config_DeviceConfig_Role_internal_data_[];
enum Config_DisplayConfig_CompassOrientation : int;
extern const uint32_t Config_DisplayConfig_CompassOrientation_internal_data_[];
enum Config_DisplayConfig_DisplayMode : int;
extern const uint32_t Config_DisplayConfig_DisplayMode_internal_data_[];
enum Config_DisplayConfig_DisplayUnits : int;
extern const uint32_t Config_DisplayConfig_DisplayUnits_internal_data_[];
enum Config_DisplayConfig_GpsCoordinateFormat : int;
extern const uint32_t Config_DisplayConfig_GpsCoordinateFormat_internal_data_[];
enum Config_DisplayConfig_OledType : int;
extern const uint32_t Config_DisplayConfig_OledType_internal_data_[];
enum Config_LoRaConfig_ModemPreset : int;
extern const uint32_t Config_LoRaConfig_ModemPreset_internal_data_[];
enum Config_LoRaConfig_RegionCode : int;
extern const uint32_t Config_LoRaConfig_RegionCode_internal_data_[];
enum Config_NetworkConfig_AddressMode : int;
extern const uint32_t Config_NetworkConfig_AddressMode_internal_data_[];
enum Config_NetworkConfig_ProtocolFlags : int;
extern const uint32_t Config_NetworkConfig_ProtocolFlags_internal_data_[];
enum Config_PositionConfig_GpsMode : int;
extern const uint32_t Config_PositionConfig_GpsMode_internal_data_[];
enum Config_PositionConfig_PositionFlags : int;
extern const uint32_t Config_PositionConfig_PositionFlags_internal_data_[];
class Config;
struct ConfigDefaultTypeInternal;
extern ConfigDefaultTypeInternal _Config_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Config_class_data_;
class Config_BluetoothConfig;
struct Config_BluetoothConfigDefaultTypeInternal;
extern Config_BluetoothConfigDefaultTypeInternal _Config_BluetoothConfig_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Config_BluetoothConfig_class_data_;
class Config_DeviceConfig;
struct Config_DeviceConfigDefaultTypeInternal;
extern Config_DeviceConfigDefaultTypeInternal _Config_DeviceConfig_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Config_DeviceConfig_class_data_;
class Config_DisplayConfig;
struct Config_DisplayConfigDefaultTypeInternal;
extern Config_DisplayConfigDefaultTypeInternal _Config_DisplayConfig_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Config_DisplayConfig_class_data_;
class Config_LoRaConfig;
struct Config_LoRaConfigDefaultTypeInternal;
extern Config_LoRaConfigDefaultTypeInternal _Config_LoRaConfig_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Config_LoRaConfig_class_data_;
class Config_NetworkConfig;
struct Config_NetworkConfigDefaultTypeInternal;
extern Config_NetworkConfigDefaultTypeInternal _Config_NetworkConfig_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Config_NetworkConfig_class_data_;
class Config_NetworkConfig_IpV4Config;
struct Config_NetworkConfig_IpV4ConfigDefaultTypeInternal;
extern Config_NetworkConfig_IpV4ConfigDefaultTypeInternal _Config_NetworkConfig_IpV4Config_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Config_NetworkConfig_IpV4Config_class_data_;
class Config_PositionConfig;
struct Config_PositionConfigDefaultTypeInternal;
extern Config_PositionConfigDefaultTypeInternal _Config_PositionConfig_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Config_PositionConfig_class_data_;
class Config_PowerConfig;
struct Config_PowerConfigDefaultTypeInternal;
extern Config_PowerConfigDefaultTypeInternal _Config_PowerConfig_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Config_PowerConfig_class_data_;
class Config_SecurityConfig;
struct Config_SecurityConfigDefaultTypeInternal;
extern Config_SecurityConfigDefaultTypeInternal _Config_SecurityConfig_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Config_SecurityConfig_class_data_;
class Config_SessionkeyConfig;
struct Config_SessionkeyConfigDefaultTypeInternal;
extern Config_SessionkeyConfigDefaultTypeInternal _Config_SessionkeyConfig_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Config_SessionkeyConfig_class_data_;
}  // namespace meshtastic
namespace google {
namespace protobuf {
template <>
internal::EnumTraitsT<::meshtastic::Config_BluetoothConfig_PairingMode_internal_data_>
    internal::EnumTraitsImpl::value<::meshtastic::Config_BluetoothConfig_PairingMode>;
template <>
internal::EnumTraitsT<::meshtastic::Config_DeviceConfig_BuzzerMode_internal_data_>
    internal::EnumTraitsImpl::value<::meshtastic::Config_DeviceConfig_BuzzerMode>;
template <>
internal::EnumTraitsT<::meshtastic::Config_DeviceConfig_RebroadcastMode_internal_data_>
    internal::EnumTraitsImpl::value<::meshtastic::Config_DeviceConfig_RebroadcastMode>;
template <>
internal::EnumTraitsT<::meshtastic::Config_DeviceConfig_Role_internal_data_>
    internal::EnumTraitsImpl::value<::meshtastic::Config_DeviceConfig_Role>;
template <>
internal::EnumTraitsT<::meshtastic::Config_DisplayConfig_CompassOrientation_internal_data_>
    internal::EnumTraitsImpl::value<::meshtastic::Config_DisplayConfig_CompassOrientation>;
template <>
internal::EnumTraitsT<::meshtastic::Config_DisplayConfig_DisplayMode_internal_data_>
    internal::EnumTraitsImpl::value<::meshtastic::Config_DisplayConfig_DisplayMode>;
template <>
internal::EnumTraitsT<::meshtastic::Config_DisplayConfig_DisplayUnits_internal_data_>
    internal::EnumTraitsImpl::value<::meshtastic::Config_DisplayConfig_DisplayUnits>;
template <>
internal::EnumTraitsT<::meshtastic::Config_DisplayConfig_GpsCoordinateFormat_internal_data_>
    internal::EnumTraitsImpl::value<::meshtastic::Config_DisplayConfig_GpsCoordinateFormat>;
template <>
internal::EnumTraitsT<::meshtastic::Config_DisplayConfig_OledType_internal_data_>
    internal::EnumTraitsImpl::value<::meshtastic::Config_DisplayConfig_OledType>;
template <>
internal::EnumTraitsT<::meshtastic::Config_LoRaConfig_ModemPreset_internal_data_>
    internal::EnumTraitsImpl::value<::meshtastic::Config_LoRaConfig_ModemPreset>;
template <>
internal::EnumTraitsT<::meshtastic::Config_LoRaConfig_RegionCode_internal_data_>
    internal::EnumTraitsImpl::value<::meshtastic::Config_LoRaConfig_RegionCode>;
template <>
internal::EnumTraitsT<::meshtastic::Config_NetworkConfig_AddressMode_internal_data_>
    internal::EnumTraitsImpl::value<::meshtastic::Config_NetworkConfig_AddressMode>;
template <>
internal::EnumTraitsT<::meshtastic::Config_NetworkConfig_ProtocolFlags_internal_data_>
    internal::EnumTraitsImpl::value<::meshtastic::Config_NetworkConfig_ProtocolFlags>;
template <>
internal::EnumTraitsT<::meshtastic::Config_PositionConfig_GpsMode_internal_data_>
    internal::EnumTraitsImpl::value<::meshtastic::Config_PositionConfig_GpsMode>;
template <>
internal::EnumTraitsT<::meshtastic::Config_PositionConfig_PositionFlags_internal_data_>
    internal::EnumTraitsImpl::value<::meshtastic::Config_PositionConfig_PositionFlags>;
}  // namespace protobuf
}  // namespace google

namespace meshtastic {
enum Config_DeviceConfig_Role : int {
  Config_DeviceConfig_Role_CLIENT = 0,
  Config_DeviceConfig_Role_CLIENT_MUTE = 1,
  Config_DeviceConfig_Role_ROUTER = 2,
  Config_DeviceConfig_Role_ROUTER_CLIENT [[deprecated]] = 3,
  Config_DeviceConfig_Role_REPEATER = 4,
  Config_DeviceConfig_Role_TRACKER = 5,
  Config_DeviceConfig_Role_SENSOR = 6,
  Config_DeviceConfig_Role_TAK = 7,
  Config_DeviceConfig_Role_CLIENT_HIDDEN = 8,
  Config_DeviceConfig_Role_LOST_AND_FOUND = 9,
  Config_DeviceConfig_Role_TAK_TRACKER = 10,
  Config_DeviceConfig_Role_ROUTER_LATE = 11,
  Config_DeviceConfig_Role_Config_DeviceConfig_Role_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Config_DeviceConfig_Role_Config_DeviceConfig_Role_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Config_DeviceConfig_Role_internal_data_[];
inline constexpr Config_DeviceConfig_Role Config_DeviceConfig_Role_Role_MIN =
    static_cast<Config_DeviceConfig_Role>(0);
inline constexpr Config_DeviceConfig_Role Config_DeviceConfig_Role_Role_MAX =
    static_cast<Config_DeviceConfig_Role>(11);
inline bool Config_DeviceConfig_Role_IsValid(int value) {
  return 0 <= value && value <= 11;
}
inline constexpr int Config_DeviceConfig_Role_Role_ARRAYSIZE = 11 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Config_DeviceConfig_Role_descriptor();
template <typename T>
const ::std::string& Config_DeviceConfig_Role_Name(T value) {
  static_assert(::std::is_same<T, Config_DeviceConfig_Role>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Role_Name().");
  return Config_DeviceConfig_Role_Name(static_cast<Config_DeviceConfig_Role>(value));
}
template <>
inline const ::std::string& Config_DeviceConfig_Role_Name(Config_DeviceConfig_Role value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Config_DeviceConfig_Role_descriptor, 0, 11>(
      static_cast<int>(value));
}
inline bool Config_DeviceConfig_Role_Parse(
    ::absl::string_view name, Config_DeviceConfig_Role* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Config_DeviceConfig_Role>(Config_DeviceConfig_Role_descriptor(), name,
                                           value);
}
enum Config_DeviceConfig_RebroadcastMode : int {
  Config_DeviceConfig_RebroadcastMode_ALL = 0,
  Config_DeviceConfig_RebroadcastMode_ALL_SKIP_DECODING = 1,
  Config_DeviceConfig_RebroadcastMode_LOCAL_ONLY = 2,
  Config_DeviceConfig_RebroadcastMode_KNOWN_ONLY = 3,
  Config_DeviceConfig_RebroadcastMode_NONE = 4,
  Config_DeviceConfig_RebroadcastMode_CORE_PORTNUMS_ONLY = 5,
  Config_DeviceConfig_RebroadcastMode_Config_DeviceConfig_RebroadcastMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Config_DeviceConfig_RebroadcastMode_Config_DeviceConfig_RebroadcastMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Config_DeviceConfig_RebroadcastMode_internal_data_[];
inline constexpr Config_DeviceConfig_RebroadcastMode Config_DeviceConfig_RebroadcastMode_RebroadcastMode_MIN =
    static_cast<Config_DeviceConfig_RebroadcastMode>(0);
inline constexpr Config_DeviceConfig_RebroadcastMode Config_DeviceConfig_RebroadcastMode_RebroadcastMode_MAX =
    static_cast<Config_DeviceConfig_RebroadcastMode>(5);
inline bool Config_DeviceConfig_RebroadcastMode_IsValid(int value) {
  return 0 <= value && value <= 5;
}
inline constexpr int Config_DeviceConfig_RebroadcastMode_RebroadcastMode_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Config_DeviceConfig_RebroadcastMode_descriptor();
template <typename T>
const ::std::string& Config_DeviceConfig_RebroadcastMode_Name(T value) {
  static_assert(::std::is_same<T, Config_DeviceConfig_RebroadcastMode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to RebroadcastMode_Name().");
  return Config_DeviceConfig_RebroadcastMode_Name(static_cast<Config_DeviceConfig_RebroadcastMode>(value));
}
template <>
inline const ::std::string& Config_DeviceConfig_RebroadcastMode_Name(Config_DeviceConfig_RebroadcastMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Config_DeviceConfig_RebroadcastMode_descriptor, 0, 5>(
      static_cast<int>(value));
}
inline bool Config_DeviceConfig_RebroadcastMode_Parse(
    ::absl::string_view name, Config_DeviceConfig_RebroadcastMode* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Config_DeviceConfig_RebroadcastMode>(Config_DeviceConfig_RebroadcastMode_descriptor(), name,
                                           value);
}
enum Config_DeviceConfig_BuzzerMode : int {
  Config_DeviceConfig_BuzzerMode_ALL_ENABLED = 0,
  Config_DeviceConfig_BuzzerMode_DISABLED = 1,
  Config_DeviceConfig_BuzzerMode_NOTIFICATIONS_ONLY = 2,
  Config_DeviceConfig_BuzzerMode_SYSTEM_ONLY = 3,
  Config_DeviceConfig_BuzzerMode_DIRECT_MSG_ONLY = 4,
  Config_DeviceConfig_BuzzerMode_Config_DeviceConfig_BuzzerMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Config_DeviceConfig_BuzzerMode_Config_DeviceConfig_BuzzerMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Config_DeviceConfig_BuzzerMode_internal_data_[];
inline constexpr Config_DeviceConfig_BuzzerMode Config_DeviceConfig_BuzzerMode_BuzzerMode_MIN =
    static_cast<Config_DeviceConfig_BuzzerMode>(0);
inline constexpr Config_DeviceConfig_BuzzerMode Config_DeviceConfig_BuzzerMode_BuzzerMode_MAX =
    static_cast<Config_DeviceConfig_BuzzerMode>(4);
inline bool Config_DeviceConfig_BuzzerMode_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int Config_DeviceConfig_BuzzerMode_BuzzerMode_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Config_DeviceConfig_BuzzerMode_descriptor();
template <typename T>
const ::std::string& Config_DeviceConfig_BuzzerMode_Name(T value) {
  static_assert(::std::is_same<T, Config_DeviceConfig_BuzzerMode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to BuzzerMode_Name().");
  return Config_DeviceConfig_BuzzerMode_Name(static_cast<Config_DeviceConfig_BuzzerMode>(value));
}
template <>
inline const ::std::string& Config_DeviceConfig_BuzzerMode_Name(Config_DeviceConfig_BuzzerMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Config_DeviceConfig_BuzzerMode_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool Config_DeviceConfig_BuzzerMode_Parse(
    ::absl::string_view name, Config_DeviceConfig_BuzzerMode* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Config_DeviceConfig_BuzzerMode>(Config_DeviceConfig_BuzzerMode_descriptor(), name,
                                           value);
}
enum Config_PositionConfig_PositionFlags : int {
  Config_PositionConfig_PositionFlags_UNSET = 0,
  Config_PositionConfig_PositionFlags_ALTITUDE = 1,
  Config_PositionConfig_PositionFlags_ALTITUDE_MSL = 2,
  Config_PositionConfig_PositionFlags_GEOIDAL_SEPARATION = 4,
  Config_PositionConfig_PositionFlags_DOP = 8,
  Config_PositionConfig_PositionFlags_HVDOP = 16,
  Config_PositionConfig_PositionFlags_SATINVIEW = 32,
  Config_PositionConfig_PositionFlags_SEQ_NO = 64,
  Config_PositionConfig_PositionFlags_TIMESTAMP = 128,
  Config_PositionConfig_PositionFlags_HEADING = 256,
  Config_PositionConfig_PositionFlags_SPEED = 512,
  Config_PositionConfig_PositionFlags_Config_PositionConfig_PositionFlags_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Config_PositionConfig_PositionFlags_Config_PositionConfig_PositionFlags_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Config_PositionConfig_PositionFlags_internal_data_[];
inline constexpr Config_PositionConfig_PositionFlags Config_PositionConfig_PositionFlags_PositionFlags_MIN =
    static_cast<Config_PositionConfig_PositionFlags>(0);
inline constexpr Config_PositionConfig_PositionFlags Config_PositionConfig_PositionFlags_PositionFlags_MAX =
    static_cast<Config_PositionConfig_PositionFlags>(512);
inline bool Config_PositionConfig_PositionFlags_IsValid(int value) {
  return ::google::protobuf::internal::ValidateEnum(value, Config_PositionConfig_PositionFlags_internal_data_);
}
inline constexpr int Config_PositionConfig_PositionFlags_PositionFlags_ARRAYSIZE = 512 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Config_PositionConfig_PositionFlags_descriptor();
template <typename T>
const ::std::string& Config_PositionConfig_PositionFlags_Name(T value) {
  static_assert(::std::is_same<T, Config_PositionConfig_PositionFlags>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to PositionFlags_Name().");
  return ::google::protobuf::internal::NameOfEnum(Config_PositionConfig_PositionFlags_descriptor(), value);
}
inline bool Config_PositionConfig_PositionFlags_Parse(
    ::absl::string_view name, Config_PositionConfig_PositionFlags* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Config_PositionConfig_PositionFlags>(Config_PositionConfig_PositionFlags_descriptor(), name,
                                           value);
}
enum Config_PositionConfig_GpsMode : int {
  Config_PositionConfig_GpsMode_DISABLED = 0,
  Config_PositionConfig_GpsMode_ENABLED = 1,
  Config_PositionConfig_GpsMode_NOT_PRESENT = 2,
  Config_PositionConfig_GpsMode_Config_PositionConfig_GpsMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Config_PositionConfig_GpsMode_Config_PositionConfig_GpsMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Config_PositionConfig_GpsMode_internal_data_[];
inline constexpr Config_PositionConfig_GpsMode Config_PositionConfig_GpsMode_GpsMode_MIN =
    static_cast<Config_PositionConfig_GpsMode>(0);
inline constexpr Config_PositionConfig_GpsMode Config_PositionConfig_GpsMode_GpsMode_MAX =
    static_cast<Config_PositionConfig_GpsMode>(2);
inline bool Config_PositionConfig_GpsMode_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int Config_PositionConfig_GpsMode_GpsMode_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Config_PositionConfig_GpsMode_descriptor();
template <typename T>
const ::std::string& Config_PositionConfig_GpsMode_Name(T value) {
  static_assert(::std::is_same<T, Config_PositionConfig_GpsMode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to GpsMode_Name().");
  return Config_PositionConfig_GpsMode_Name(static_cast<Config_PositionConfig_GpsMode>(value));
}
template <>
inline const ::std::string& Config_PositionConfig_GpsMode_Name(Config_PositionConfig_GpsMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Config_PositionConfig_GpsMode_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool Config_PositionConfig_GpsMode_Parse(
    ::absl::string_view name, Config_PositionConfig_GpsMode* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Config_PositionConfig_GpsMode>(Config_PositionConfig_GpsMode_descriptor(), name,
                                           value);
}
enum Config_NetworkConfig_AddressMode : int {
  Config_NetworkConfig_AddressMode_DHCP = 0,
  Config_NetworkConfig_AddressMode_STATIC = 1,
  Config_NetworkConfig_AddressMode_Config_NetworkConfig_AddressMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Config_NetworkConfig_AddressMode_Config_NetworkConfig_AddressMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Config_NetworkConfig_AddressMode_internal_data_[];
inline constexpr Config_NetworkConfig_AddressMode Config_NetworkConfig_AddressMode_AddressMode_MIN =
    static_cast<Config_NetworkConfig_AddressMode>(0);
inline constexpr Config_NetworkConfig_AddressMode Config_NetworkConfig_AddressMode_AddressMode_MAX =
    static_cast<Config_NetworkConfig_AddressMode>(1);
inline bool Config_NetworkConfig_AddressMode_IsValid(int value) {
  return 0 <= value && value <= 1;
}
inline constexpr int Config_NetworkConfig_AddressMode_AddressMode_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Config_NetworkConfig_AddressMode_descriptor();
template <typename T>
const ::std::string& Config_NetworkConfig_AddressMode_Name(T value) {
  static_assert(::std::is_same<T, Config_NetworkConfig_AddressMode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to AddressMode_Name().");
  return Config_NetworkConfig_AddressMode_Name(static_cast<Config_NetworkConfig_AddressMode>(value));
}
template <>
inline const ::std::string& Config_NetworkConfig_AddressMode_Name(Config_NetworkConfig_AddressMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Config_NetworkConfig_AddressMode_descriptor, 0, 1>(
      static_cast<int>(value));
}
inline bool Config_NetworkConfig_AddressMode_Parse(
    ::absl::string_view name, Config_NetworkConfig_AddressMode* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Config_NetworkConfig_AddressMode>(Config_NetworkConfig_AddressMode_descriptor(), name,
                                           value);
}
enum Config_NetworkConfig_ProtocolFlags : int {
  Config_NetworkConfig_ProtocolFlags_NO_BROADCAST = 0,
  Config_NetworkConfig_ProtocolFlags_UDP_BROADCAST = 1,
  Config_NetworkConfig_ProtocolFlags_Config_NetworkConfig_ProtocolFlags_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Config_NetworkConfig_ProtocolFlags_Config_NetworkConfig_ProtocolFlags_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Config_NetworkConfig_ProtocolFlags_internal_data_[];
inline constexpr Config_NetworkConfig_ProtocolFlags Config_NetworkConfig_ProtocolFlags_ProtocolFlags_MIN =
    static_cast<Config_NetworkConfig_ProtocolFlags>(0);
inline constexpr Config_NetworkConfig_ProtocolFlags Config_NetworkConfig_ProtocolFlags_ProtocolFlags_MAX =
    static_cast<Config_NetworkConfig_ProtocolFlags>(1);
inline bool Config_NetworkConfig_ProtocolFlags_IsValid(int value) {
  return 0 <= value && value <= 1;
}
inline constexpr int Config_NetworkConfig_ProtocolFlags_ProtocolFlags_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Config_NetworkConfig_ProtocolFlags_descriptor();
template <typename T>
const ::std::string& Config_NetworkConfig_ProtocolFlags_Name(T value) {
  static_assert(::std::is_same<T, Config_NetworkConfig_ProtocolFlags>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ProtocolFlags_Name().");
  return Config_NetworkConfig_ProtocolFlags_Name(static_cast<Config_NetworkConfig_ProtocolFlags>(value));
}
template <>
inline const ::std::string& Config_NetworkConfig_ProtocolFlags_Name(Config_NetworkConfig_ProtocolFlags value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Config_NetworkConfig_ProtocolFlags_descriptor, 0, 1>(
      static_cast<int>(value));
}
inline bool Config_NetworkConfig_ProtocolFlags_Parse(
    ::absl::string_view name, Config_NetworkConfig_ProtocolFlags* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Config_NetworkConfig_ProtocolFlags>(Config_NetworkConfig_ProtocolFlags_descriptor(), name,
                                           value);
}
enum Config_DisplayConfig_GpsCoordinateFormat : int {
  Config_DisplayConfig_GpsCoordinateFormat_DEC = 0,
  Config_DisplayConfig_GpsCoordinateFormat_DMS = 1,
  Config_DisplayConfig_GpsCoordinateFormat_UTM = 2,
  Config_DisplayConfig_GpsCoordinateFormat_MGRS = 3,
  Config_DisplayConfig_GpsCoordinateFormat_OLC = 4,
  Config_DisplayConfig_GpsCoordinateFormat_OSGR = 5,
  Config_DisplayConfig_GpsCoordinateFormat_Config_DisplayConfig_GpsCoordinateFormat_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Config_DisplayConfig_GpsCoordinateFormat_Config_DisplayConfig_GpsCoordinateFormat_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Config_DisplayConfig_GpsCoordinateFormat_internal_data_[];
inline constexpr Config_DisplayConfig_GpsCoordinateFormat Config_DisplayConfig_GpsCoordinateFormat_GpsCoordinateFormat_MIN =
    static_cast<Config_DisplayConfig_GpsCoordinateFormat>(0);
inline constexpr Config_DisplayConfig_GpsCoordinateFormat Config_DisplayConfig_GpsCoordinateFormat_GpsCoordinateFormat_MAX =
    static_cast<Config_DisplayConfig_GpsCoordinateFormat>(5);
inline bool Config_DisplayConfig_GpsCoordinateFormat_IsValid(int value) {
  return 0 <= value && value <= 5;
}
inline constexpr int Config_DisplayConfig_GpsCoordinateFormat_GpsCoordinateFormat_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Config_DisplayConfig_GpsCoordinateFormat_descriptor();
template <typename T>
const ::std::string& Config_DisplayConfig_GpsCoordinateFormat_Name(T value) {
  static_assert(::std::is_same<T, Config_DisplayConfig_GpsCoordinateFormat>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to GpsCoordinateFormat_Name().");
  return Config_DisplayConfig_GpsCoordinateFormat_Name(static_cast<Config_DisplayConfig_GpsCoordinateFormat>(value));
}
template <>
inline const ::std::string& Config_DisplayConfig_GpsCoordinateFormat_Name(Config_DisplayConfig_GpsCoordinateFormat value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Config_DisplayConfig_GpsCoordinateFormat_descriptor, 0, 5>(
      static_cast<int>(value));
}
inline bool Config_DisplayConfig_GpsCoordinateFormat_Parse(
    ::absl::string_view name, Config_DisplayConfig_GpsCoordinateFormat* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Config_DisplayConfig_GpsCoordinateFormat>(Config_DisplayConfig_GpsCoordinateFormat_descriptor(), name,
                                           value);
}
enum Config_DisplayConfig_DisplayUnits : int {
  Config_DisplayConfig_DisplayUnits_METRIC = 0,
  Config_DisplayConfig_DisplayUnits_IMPERIAL = 1,
  Config_DisplayConfig_DisplayUnits_Config_DisplayConfig_DisplayUnits_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Config_DisplayConfig_DisplayUnits_Config_DisplayConfig_DisplayUnits_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Config_DisplayConfig_DisplayUnits_internal_data_[];
inline constexpr Config_DisplayConfig_DisplayUnits Config_DisplayConfig_DisplayUnits_DisplayUnits_MIN =
    static_cast<Config_DisplayConfig_DisplayUnits>(0);
inline constexpr Config_DisplayConfig_DisplayUnits Config_DisplayConfig_DisplayUnits_DisplayUnits_MAX =
    static_cast<Config_DisplayConfig_DisplayUnits>(1);
inline bool Config_DisplayConfig_DisplayUnits_IsValid(int value) {
  return 0 <= value && value <= 1;
}
inline constexpr int Config_DisplayConfig_DisplayUnits_DisplayUnits_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Config_DisplayConfig_DisplayUnits_descriptor();
template <typename T>
const ::std::string& Config_DisplayConfig_DisplayUnits_Name(T value) {
  static_assert(::std::is_same<T, Config_DisplayConfig_DisplayUnits>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to DisplayUnits_Name().");
  return Config_DisplayConfig_DisplayUnits_Name(static_cast<Config_DisplayConfig_DisplayUnits>(value));
}
template <>
inline const ::std::string& Config_DisplayConfig_DisplayUnits_Name(Config_DisplayConfig_DisplayUnits value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Config_DisplayConfig_DisplayUnits_descriptor, 0, 1>(
      static_cast<int>(value));
}
inline bool Config_DisplayConfig_DisplayUnits_Parse(
    ::absl::string_view name, Config_DisplayConfig_DisplayUnits* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Config_DisplayConfig_DisplayUnits>(Config_DisplayConfig_DisplayUnits_descriptor(), name,
                                           value);
}
enum Config_DisplayConfig_OledType : int {
  Config_DisplayConfig_OledType_OLED_AUTO = 0,
  Config_DisplayConfig_OledType_OLED_SSD1306 = 1,
  Config_DisplayConfig_OledType_OLED_SH1106 = 2,
  Config_DisplayConfig_OledType_OLED_SH1107 = 3,
  Config_DisplayConfig_OledType_OLED_SH1107_128_128 = 4,
  Config_DisplayConfig_OledType_Config_DisplayConfig_OledType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Config_DisplayConfig_OledType_Config_DisplayConfig_OledType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Config_DisplayConfig_OledType_internal_data_[];
inline constexpr Config_DisplayConfig_OledType Config_DisplayConfig_OledType_OledType_MIN =
    static_cast<Config_DisplayConfig_OledType>(0);
inline constexpr Config_DisplayConfig_OledType Config_DisplayConfig_OledType_OledType_MAX =
    static_cast<Config_DisplayConfig_OledType>(4);
inline bool Config_DisplayConfig_OledType_IsValid(int value) {
  return 0 <= value && value <= 4;
}
inline constexpr int Config_DisplayConfig_OledType_OledType_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Config_DisplayConfig_OledType_descriptor();
template <typename T>
const ::std::string& Config_DisplayConfig_OledType_Name(T value) {
  static_assert(::std::is_same<T, Config_DisplayConfig_OledType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to OledType_Name().");
  return Config_DisplayConfig_OledType_Name(static_cast<Config_DisplayConfig_OledType>(value));
}
template <>
inline const ::std::string& Config_DisplayConfig_OledType_Name(Config_DisplayConfig_OledType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Config_DisplayConfig_OledType_descriptor, 0, 4>(
      static_cast<int>(value));
}
inline bool Config_DisplayConfig_OledType_Parse(
    ::absl::string_view name, Config_DisplayConfig_OledType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Config_DisplayConfig_OledType>(Config_DisplayConfig_OledType_descriptor(), name,
                                           value);
}
enum Config_DisplayConfig_DisplayMode : int {
  Config_DisplayConfig_DisplayMode_DEFAULT = 0,
  Config_DisplayConfig_DisplayMode_TWOCOLOR = 1,
  Config_DisplayConfig_DisplayMode_INVERTED = 2,
  Config_DisplayConfig_DisplayMode_COLOR = 3,
  Config_DisplayConfig_DisplayMode_Config_DisplayConfig_DisplayMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Config_DisplayConfig_DisplayMode_Config_DisplayConfig_DisplayMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Config_DisplayConfig_DisplayMode_internal_data_[];
inline constexpr Config_DisplayConfig_DisplayMode Config_DisplayConfig_DisplayMode_DisplayMode_MIN =
    static_cast<Config_DisplayConfig_DisplayMode>(0);
inline constexpr Config_DisplayConfig_DisplayMode Config_DisplayConfig_DisplayMode_DisplayMode_MAX =
    static_cast<Config_DisplayConfig_DisplayMode>(3);
inline bool Config_DisplayConfig_DisplayMode_IsValid(int value) {
  return 0 <= value && value <= 3;
}
inline constexpr int Config_DisplayConfig_DisplayMode_DisplayMode_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Config_DisplayConfig_DisplayMode_descriptor();
template <typename T>
const ::std::string& Config_DisplayConfig_DisplayMode_Name(T value) {
  static_assert(::std::is_same<T, Config_DisplayConfig_DisplayMode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to DisplayMode_Name().");
  return Config_DisplayConfig_DisplayMode_Name(static_cast<Config_DisplayConfig_DisplayMode>(value));
}
template <>
inline const ::std::string& Config_DisplayConfig_DisplayMode_Name(Config_DisplayConfig_DisplayMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Config_DisplayConfig_DisplayMode_descriptor, 0, 3>(
      static_cast<int>(value));
}
inline bool Config_DisplayConfig_DisplayMode_Parse(
    ::absl::string_view name, Config_DisplayConfig_DisplayMode* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Config_DisplayConfig_DisplayMode>(Config_DisplayConfig_DisplayMode_descriptor(), name,
                                           value);
}
enum Config_DisplayConfig_CompassOrientation : int {
  Config_DisplayConfig_CompassOrientation_DEGREES_0 = 0,
  Config_DisplayConfig_CompassOrientation_DEGREES_90 = 1,
  Config_DisplayConfig_CompassOrientation_DEGREES_180 = 2,
  Config_DisplayConfig_CompassOrientation_DEGREES_270 = 3,
  Config_DisplayConfig_CompassOrientation_DEGREES_0_INVERTED = 4,
  Config_DisplayConfig_CompassOrientation_DEGREES_90_INVERTED = 5,
  Config_DisplayConfig_CompassOrientation_DEGREES_180_INVERTED = 6,
  Config_DisplayConfig_CompassOrientation_DEGREES_270_INVERTED = 7,
  Config_DisplayConfig_CompassOrientation_Config_DisplayConfig_CompassOrientation_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Config_DisplayConfig_CompassOrientation_Config_DisplayConfig_CompassOrientation_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Config_DisplayConfig_CompassOrientation_internal_data_[];
inline constexpr Config_DisplayConfig_CompassOrientation Config_DisplayConfig_CompassOrientation_CompassOrientation_MIN =
    static_cast<Config_DisplayConfig_CompassOrientation>(0);
inline constexpr Config_DisplayConfig_CompassOrientation Config_DisplayConfig_CompassOrientation_CompassOrientation_MAX =
    static_cast<Config_DisplayConfig_CompassOrientation>(7);
inline bool Config_DisplayConfig_CompassOrientation_IsValid(int value) {
  return 0 <= value && value <= 7;
}
inline constexpr int Config_DisplayConfig_CompassOrientation_CompassOrientation_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Config_DisplayConfig_CompassOrientation_descriptor();
template <typename T>
const ::std::string& Config_DisplayConfig_CompassOrientation_Name(T value) {
  static_assert(::std::is_same<T, Config_DisplayConfig_CompassOrientation>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to CompassOrientation_Name().");
  return Config_DisplayConfig_CompassOrientation_Name(static_cast<Config_DisplayConfig_CompassOrientation>(value));
}
template <>
inline const ::std::string& Config_DisplayConfig_CompassOrientation_Name(Config_DisplayConfig_CompassOrientation value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Config_DisplayConfig_CompassOrientation_descriptor, 0, 7>(
      static_cast<int>(value));
}
inline bool Config_DisplayConfig_CompassOrientation_Parse(
    ::absl::string_view name, Config_DisplayConfig_CompassOrientation* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Config_DisplayConfig_CompassOrientation>(Config_DisplayConfig_CompassOrientation_descriptor(), name,
                                           value);
}
enum Config_LoRaConfig_RegionCode : int {
  Config_LoRaConfig_RegionCode_UNSET = 0,
  Config_LoRaConfig_RegionCode_US = 1,
  Config_LoRaConfig_RegionCode_EU_433 = 2,
  Config_LoRaConfig_RegionCode_EU_868 = 3,
  Config_LoRaConfig_RegionCode_CN = 4,
  Config_LoRaConfig_RegionCode_JP = 5,
  Config_LoRaConfig_RegionCode_ANZ = 6,
  Config_LoRaConfig_RegionCode_KR = 7,
  Config_LoRaConfig_RegionCode_TW = 8,
  Config_LoRaConfig_RegionCode_RU = 9,
  Config_LoRaConfig_RegionCode_IN = 10,
  Config_LoRaConfig_RegionCode_NZ_865 = 11,
  Config_LoRaConfig_RegionCode_TH = 12,
  Config_LoRaConfig_RegionCode_LORA_24 = 13,
  Config_LoRaConfig_RegionCode_UA_433 = 14,
  Config_LoRaConfig_RegionCode_UA_868 = 15,
  Config_LoRaConfig_RegionCode_MY_433 = 16,
  Config_LoRaConfig_RegionCode_MY_919 = 17,
  Config_LoRaConfig_RegionCode_SG_923 = 18,
  Config_LoRaConfig_RegionCode_PH_433 = 19,
  Config_LoRaConfig_RegionCode_PH_868 = 20,
  Config_LoRaConfig_RegionCode_PH_915 = 21,
  Config_LoRaConfig_RegionCode_ANZ_433 = 22,
  Config_LoRaConfig_RegionCode_KZ_433 = 23,
  Config_LoRaConfig_RegionCode_KZ_863 = 24,
  Config_LoRaConfig_RegionCode_NP_865 = 25,
  Config_LoRaConfig_RegionCode_BR_902 = 26,
  Config_LoRaConfig_RegionCode_Config_LoRaConfig_RegionCode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Config_LoRaConfig_RegionCode_Config_LoRaConfig_RegionCode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Config_LoRaConfig_RegionCode_internal_data_[];
inline constexpr Config_LoRaConfig_RegionCode Config_LoRaConfig_RegionCode_RegionCode_MIN =
    static_cast<Config_LoRaConfig_RegionCode>(0);
inline constexpr Config_LoRaConfig_RegionCode Config_LoRaConfig_RegionCode_RegionCode_MAX =
    static_cast<Config_LoRaConfig_RegionCode>(26);
inline bool Config_LoRaConfig_RegionCode_IsValid(int value) {
  return 0 <= value && value <= 26;
}
inline constexpr int Config_LoRaConfig_RegionCode_RegionCode_ARRAYSIZE = 26 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Config_LoRaConfig_RegionCode_descriptor();
template <typename T>
const ::std::string& Config_LoRaConfig_RegionCode_Name(T value) {
  static_assert(::std::is_same<T, Config_LoRaConfig_RegionCode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to RegionCode_Name().");
  return Config_LoRaConfig_RegionCode_Name(static_cast<Config_LoRaConfig_RegionCode>(value));
}
template <>
inline const ::std::string& Config_LoRaConfig_RegionCode_Name(Config_LoRaConfig_RegionCode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Config_LoRaConfig_RegionCode_descriptor, 0, 26>(
      static_cast<int>(value));
}
inline bool Config_LoRaConfig_RegionCode_Parse(
    ::absl::string_view name, Config_LoRaConfig_RegionCode* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Config_LoRaConfig_RegionCode>(Config_LoRaConfig_RegionCode_descriptor(), name,
                                           value);
}
enum Config_LoRaConfig_ModemPreset : int {
  Config_LoRaConfig_ModemPreset_LONG_FAST = 0,
  Config_LoRaConfig_ModemPreset_LONG_SLOW = 1,
  Config_LoRaConfig_ModemPreset_VERY_LONG_SLOW [[deprecated]] = 2,
  Config_LoRaConfig_ModemPreset_MEDIUM_SLOW = 3,
  Config_LoRaConfig_ModemPreset_MEDIUM_FAST = 4,
  Config_LoRaConfig_ModemPreset_SHORT_SLOW = 5,
  Config_LoRaConfig_ModemPreset_SHORT_FAST = 6,
  Config_LoRaConfig_ModemPreset_LONG_MODERATE = 7,
  Config_LoRaConfig_ModemPreset_SHORT_TURBO = 8,
  Config_LoRaConfig_ModemPreset_Config_LoRaConfig_ModemPreset_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Config_LoRaConfig_ModemPreset_Config_LoRaConfig_ModemPreset_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Config_LoRaConfig_ModemPreset_internal_data_[];
inline constexpr Config_LoRaConfig_ModemPreset Config_LoRaConfig_ModemPreset_ModemPreset_MIN =
    static_cast<Config_LoRaConfig_ModemPreset>(0);
inline constexpr Config_LoRaConfig_ModemPreset Config_LoRaConfig_ModemPreset_ModemPreset_MAX =
    static_cast<Config_LoRaConfig_ModemPreset>(8);
inline bool Config_LoRaConfig_ModemPreset_IsValid(int value) {
  return 0 <= value && value <= 8;
}
inline constexpr int Config_LoRaConfig_ModemPreset_ModemPreset_ARRAYSIZE = 8 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Config_LoRaConfig_ModemPreset_descriptor();
template <typename T>
const ::std::string& Config_LoRaConfig_ModemPreset_Name(T value) {
  static_assert(::std::is_same<T, Config_LoRaConfig_ModemPreset>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to ModemPreset_Name().");
  return Config_LoRaConfig_ModemPreset_Name(static_cast<Config_LoRaConfig_ModemPreset>(value));
}
template <>
inline const ::std::string& Config_LoRaConfig_ModemPreset_Name(Config_LoRaConfig_ModemPreset value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Config_LoRaConfig_ModemPreset_descriptor, 0, 8>(
      static_cast<int>(value));
}
inline bool Config_LoRaConfig_ModemPreset_Parse(
    ::absl::string_view name, Config_LoRaConfig_ModemPreset* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Config_LoRaConfig_ModemPreset>(Config_LoRaConfig_ModemPreset_descriptor(), name,
                                           value);
}
enum Config_BluetoothConfig_PairingMode : int {
  Config_BluetoothConfig_PairingMode_RANDOM_PIN = 0,
  Config_BluetoothConfig_PairingMode_FIXED_PIN = 1,
  Config_BluetoothConfig_PairingMode_NO_PIN = 2,
  Config_BluetoothConfig_PairingMode_Config_BluetoothConfig_PairingMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Config_BluetoothConfig_PairingMode_Config_BluetoothConfig_PairingMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Config_BluetoothConfig_PairingMode_internal_data_[];
inline constexpr Config_BluetoothConfig_PairingMode Config_BluetoothConfig_PairingMode_PairingMode_MIN =
    static_cast<Config_BluetoothConfig_PairingMode>(0);
inline constexpr Config_BluetoothConfig_PairingMode Config_BluetoothConfig_PairingMode_PairingMode_MAX =
    static_cast<Config_BluetoothConfig_PairingMode>(2);
inline bool Config_BluetoothConfig_PairingMode_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int Config_BluetoothConfig_PairingMode_PairingMode_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Config_BluetoothConfig_PairingMode_descriptor();
template <typename T>
const ::std::string& Config_BluetoothConfig_PairingMode_Name(T value) {
  static_assert(::std::is_same<T, Config_BluetoothConfig_PairingMode>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to PairingMode_Name().");
  return Config_BluetoothConfig_PairingMode_Name(static_cast<Config_BluetoothConfig_PairingMode>(value));
}
template <>
inline const ::std::string& Config_BluetoothConfig_PairingMode_Name(Config_BluetoothConfig_PairingMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Config_BluetoothConfig_PairingMode_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool Config_BluetoothConfig_PairingMode_Parse(
    ::absl::string_view name, Config_BluetoothConfig_PairingMode* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Config_BluetoothConfig_PairingMode>(Config_BluetoothConfig_PairingMode_descriptor(), name,
                                           value);
}

// ===================================================================


// -------------------------------------------------------------------

class Config_SessionkeyConfig final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:meshtastic.Config.SessionkeyConfig) */ {
 public:
  inline Config_SessionkeyConfig() : Config_SessionkeyConfig(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Config_SessionkeyConfig* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Config_SessionkeyConfig));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Config_SessionkeyConfig(::google::protobuf::internal::ConstantInitialized);

  inline Config_SessionkeyConfig(const Config_SessionkeyConfig& from) : Config_SessionkeyConfig(nullptr, from) {}
  inline Config_SessionkeyConfig(Config_SessionkeyConfig&& from) noexcept
      : Config_SessionkeyConfig(nullptr, ::std::move(from)) {}
  inline Config_SessionkeyConfig& operator=(const Config_SessionkeyConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline Config_SessionkeyConfig& operator=(Config_SessionkeyConfig&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Config_SessionkeyConfig& default_instance() {
    return *reinterpret_cast<const Config_SessionkeyConfig*>(
        &_Config_SessionkeyConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(Config_SessionkeyConfig& a, Config_SessionkeyConfig& b) { a.Swap(&b); }
  inline void Swap(Config_SessionkeyConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Config_SessionkeyConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Config_SessionkeyConfig* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<Config_SessionkeyConfig>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Config_SessionkeyConfig& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Config_SessionkeyConfig& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.Config.SessionkeyConfig"; }

 protected:
  explicit Config_SessionkeyConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Config_SessionkeyConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Config_SessionkeyConfig& from);
  Config_SessionkeyConfig(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Config_SessionkeyConfig&& from) noexcept
      : Config_SessionkeyConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:meshtastic.Config.SessionkeyConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 0,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Config_SessionkeyConfig& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_meshtastic_2fconfig_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Config_SessionkeyConfig_class_data_;
// -------------------------------------------------------------------

class Config_SecurityConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.Config.SecurityConfig) */ {
 public:
  inline Config_SecurityConfig() : Config_SecurityConfig(nullptr) {}
  ~Config_SecurityConfig() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Config_SecurityConfig* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Config_SecurityConfig));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Config_SecurityConfig(::google::protobuf::internal::ConstantInitialized);

  inline Config_SecurityConfig(const Config_SecurityConfig& from) : Config_SecurityConfig(nullptr, from) {}
  inline Config_SecurityConfig(Config_SecurityConfig&& from) noexcept
      : Config_SecurityConfig(nullptr, ::std::move(from)) {}
  inline Config_SecurityConfig& operator=(const Config_SecurityConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline Config_SecurityConfig& operator=(Config_SecurityConfig&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Config_SecurityConfig& default_instance() {
    return *reinterpret_cast<const Config_SecurityConfig*>(
        &_Config_SecurityConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(Config_SecurityConfig& a, Config_SecurityConfig& b) { a.Swap(&b); }
  inline void Swap(Config_SecurityConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Config_SecurityConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Config_SecurityConfig* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Config_SecurityConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Config_SecurityConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Config_SecurityConfig& from) { Config_SecurityConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Config_SecurityConfig* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.Config.SecurityConfig"; }

 protected:
  explicit Config_SecurityConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Config_SecurityConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Config_SecurityConfig& from);
  Config_SecurityConfig(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Config_SecurityConfig&& from) noexcept
      : Config_SecurityConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAdminKeyFieldNumber = 3,
    kPublicKeyFieldNumber = 1,
    kPrivateKeyFieldNumber = 2,
    kIsManagedFieldNumber = 4,
    kSerialEnabledFieldNumber = 5,
    kDebugLogApiEnabledFieldNumber = 6,
    kAdminChannelEnabledFieldNumber = 8,
  };
  // repeated bytes admin_key = 3;
  int admin_key_size() const;
  private:
  int _internal_admin_key_size() const;

  public:
  void clear_admin_key() ;
  const ::std::string& admin_key(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_admin_key(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_admin_key(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_admin_key();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_admin_key(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& admin_key() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_admin_key();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_admin_key() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_admin_key();

  public:
  // bytes public_key = 1;
  void clear_public_key() ;
  const ::std::string& public_key() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_public_key(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_public_key();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_public_key();
  void set_allocated_public_key(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_public_key() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_public_key(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_public_key();

  public:
  // bytes private_key = 2;
  void clear_private_key() ;
  const ::std::string& private_key() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_private_key(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_private_key();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_private_key();
  void set_allocated_private_key(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_private_key() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_private_key(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_private_key();

  public:
  // bool is_managed = 4;
  void clear_is_managed() ;
  bool is_managed() const;
  void set_is_managed(bool value);

  private:
  bool _internal_is_managed() const;
  void _internal_set_is_managed(bool value);

  public:
  // bool serial_enabled = 5;
  void clear_serial_enabled() ;
  bool serial_enabled() const;
  void set_serial_enabled(bool value);

  private:
  bool _internal_serial_enabled() const;
  void _internal_set_serial_enabled(bool value);

  public:
  // bool debug_log_api_enabled = 6;
  void clear_debug_log_api_enabled() ;
  bool debug_log_api_enabled() const;
  void set_debug_log_api_enabled(bool value);

  private:
  bool _internal_debug_log_api_enabled() const;
  void _internal_set_debug_log_api_enabled(bool value);

  public:
  // bool admin_channel_enabled = 8;
  void clear_admin_channel_enabled() ;
  bool admin_channel_enabled() const;
  void set_admin_channel_enabled(bool value);

  private:
  bool _internal_admin_channel_enabled() const;
  void _internal_set_admin_channel_enabled(bool value);

  public:
  // @@protoc_insertion_point(class_scope:meshtastic.Config.SecurityConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Config_SecurityConfig& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> admin_key_;
    ::google::protobuf::internal::ArenaStringPtr public_key_;
    ::google::protobuf::internal::ArenaStringPtr private_key_;
    bool is_managed_;
    bool serial_enabled_;
    bool debug_log_api_enabled_;
    bool admin_channel_enabled_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fconfig_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Config_SecurityConfig_class_data_;
// -------------------------------------------------------------------

class Config_PowerConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.Config.PowerConfig) */ {
 public:
  inline Config_PowerConfig() : Config_PowerConfig(nullptr) {}
  ~Config_PowerConfig() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Config_PowerConfig* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Config_PowerConfig));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Config_PowerConfig(::google::protobuf::internal::ConstantInitialized);

  inline Config_PowerConfig(const Config_PowerConfig& from) : Config_PowerConfig(nullptr, from) {}
  inline Config_PowerConfig(Config_PowerConfig&& from) noexcept
      : Config_PowerConfig(nullptr, ::std::move(from)) {}
  inline Config_PowerConfig& operator=(const Config_PowerConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline Config_PowerConfig& operator=(Config_PowerConfig&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Config_PowerConfig& default_instance() {
    return *reinterpret_cast<const Config_PowerConfig*>(
        &_Config_PowerConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(Config_PowerConfig& a, Config_PowerConfig& b) { a.Swap(&b); }
  inline void Swap(Config_PowerConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Config_PowerConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Config_PowerConfig* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Config_PowerConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Config_PowerConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Config_PowerConfig& from) { Config_PowerConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Config_PowerConfig* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.Config.PowerConfig"; }

 protected:
  explicit Config_PowerConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Config_PowerConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Config_PowerConfig& from);
  Config_PowerConfig(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Config_PowerConfig&& from) noexcept
      : Config_PowerConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIsPowerSavingFieldNumber = 1,
    kOnBatteryShutdownAfterSecsFieldNumber = 2,
    kAdcMultiplierOverrideFieldNumber = 3,
    kWaitBluetoothSecsFieldNumber = 4,
    kSdsSecsFieldNumber = 6,
    kLsSecsFieldNumber = 7,
    kMinWakeSecsFieldNumber = 8,
    kDeviceBatteryInaAddressFieldNumber = 9,
    kPowermonEnablesFieldNumber = 32,
  };
  // bool is_power_saving = 1;
  void clear_is_power_saving() ;
  bool is_power_saving() const;
  void set_is_power_saving(bool value);

  private:
  bool _internal_is_power_saving() const;
  void _internal_set_is_power_saving(bool value);

  public:
  // uint32 on_battery_shutdown_after_secs = 2;
  void clear_on_battery_shutdown_after_secs() ;
  ::uint32_t on_battery_shutdown_after_secs() const;
  void set_on_battery_shutdown_after_secs(::uint32_t value);

  private:
  ::uint32_t _internal_on_battery_shutdown_after_secs() const;
  void _internal_set_on_battery_shutdown_after_secs(::uint32_t value);

  public:
  // float adc_multiplier_override = 3;
  void clear_adc_multiplier_override() ;
  float adc_multiplier_override() const;
  void set_adc_multiplier_override(float value);

  private:
  float _internal_adc_multiplier_override() const;
  void _internal_set_adc_multiplier_override(float value);

  public:
  // uint32 wait_bluetooth_secs = 4;
  void clear_wait_bluetooth_secs() ;
  ::uint32_t wait_bluetooth_secs() const;
  void set_wait_bluetooth_secs(::uint32_t value);

  private:
  ::uint32_t _internal_wait_bluetooth_secs() const;
  void _internal_set_wait_bluetooth_secs(::uint32_t value);

  public:
  // uint32 sds_secs = 6;
  void clear_sds_secs() ;
  ::uint32_t sds_secs() const;
  void set_sds_secs(::uint32_t value);

  private:
  ::uint32_t _internal_sds_secs() const;
  void _internal_set_sds_secs(::uint32_t value);

  public:
  // uint32 ls_secs = 7;
  void clear_ls_secs() ;
  ::uint32_t ls_secs() const;
  void set_ls_secs(::uint32_t value);

  private:
  ::uint32_t _internal_ls_secs() const;
  void _internal_set_ls_secs(::uint32_t value);

  public:
  // uint32 min_wake_secs = 8;
  void clear_min_wake_secs() ;
  ::uint32_t min_wake_secs() const;
  void set_min_wake_secs(::uint32_t value);

  private:
  ::uint32_t _internal_min_wake_secs() const;
  void _internal_set_min_wake_secs(::uint32_t value);

  public:
  // uint32 device_battery_ina_address = 9;
  void clear_device_battery_ina_address() ;
  ::uint32_t device_battery_ina_address() const;
  void set_device_battery_ina_address(::uint32_t value);

  private:
  ::uint32_t _internal_device_battery_ina_address() const;
  void _internal_set_device_battery_ina_address(::uint32_t value);

  public:
  // uint64 powermon_enables = 32;
  void clear_powermon_enables() ;
  ::uint64_t powermon_enables() const;
  void set_powermon_enables(::uint64_t value);

  private:
  ::uint64_t _internal_powermon_enables() const;
  void _internal_set_powermon_enables(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:meshtastic.Config.PowerConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 9,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Config_PowerConfig& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    bool is_power_saving_;
    ::uint32_t on_battery_shutdown_after_secs_;
    float adc_multiplier_override_;
    ::uint32_t wait_bluetooth_secs_;
    ::uint32_t sds_secs_;
    ::uint32_t ls_secs_;
    ::uint32_t min_wake_secs_;
    ::uint32_t device_battery_ina_address_;
    ::uint64_t powermon_enables_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fconfig_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Config_PowerConfig_class_data_;
// -------------------------------------------------------------------

class Config_PositionConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.Config.PositionConfig) */ {
 public:
  inline Config_PositionConfig() : Config_PositionConfig(nullptr) {}
  ~Config_PositionConfig() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Config_PositionConfig* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Config_PositionConfig));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Config_PositionConfig(::google::protobuf::internal::ConstantInitialized);

  inline Config_PositionConfig(const Config_PositionConfig& from) : Config_PositionConfig(nullptr, from) {}
  inline Config_PositionConfig(Config_PositionConfig&& from) noexcept
      : Config_PositionConfig(nullptr, ::std::move(from)) {}
  inline Config_PositionConfig& operator=(const Config_PositionConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline Config_PositionConfig& operator=(Config_PositionConfig&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Config_PositionConfig& default_instance() {
    return *reinterpret_cast<const Config_PositionConfig*>(
        &_Config_PositionConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(Config_PositionConfig& a, Config_PositionConfig& b) { a.Swap(&b); }
  inline void Swap(Config_PositionConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Config_PositionConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Config_PositionConfig* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Config_PositionConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Config_PositionConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Config_PositionConfig& from) { Config_PositionConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Config_PositionConfig* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.Config.PositionConfig"; }

 protected:
  explicit Config_PositionConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Config_PositionConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Config_PositionConfig& from);
  Config_PositionConfig(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Config_PositionConfig&& from) noexcept
      : Config_PositionConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using PositionFlags = Config_PositionConfig_PositionFlags;
  static constexpr PositionFlags UNSET = Config_PositionConfig_PositionFlags_UNSET;
  static constexpr PositionFlags ALTITUDE = Config_PositionConfig_PositionFlags_ALTITUDE;
  static constexpr PositionFlags ALTITUDE_MSL = Config_PositionConfig_PositionFlags_ALTITUDE_MSL;
  static constexpr PositionFlags GEOIDAL_SEPARATION = Config_PositionConfig_PositionFlags_GEOIDAL_SEPARATION;
  static constexpr PositionFlags DOP = Config_PositionConfig_PositionFlags_DOP;
  static constexpr PositionFlags HVDOP = Config_PositionConfig_PositionFlags_HVDOP;
  static constexpr PositionFlags SATINVIEW = Config_PositionConfig_PositionFlags_SATINVIEW;
  static constexpr PositionFlags SEQ_NO = Config_PositionConfig_PositionFlags_SEQ_NO;
  static constexpr PositionFlags TIMESTAMP = Config_PositionConfig_PositionFlags_TIMESTAMP;
  static constexpr PositionFlags HEADING = Config_PositionConfig_PositionFlags_HEADING;
  static constexpr PositionFlags SPEED = Config_PositionConfig_PositionFlags_SPEED;
  static inline bool PositionFlags_IsValid(int value) {
    return Config_PositionConfig_PositionFlags_IsValid(value);
  }
  static constexpr PositionFlags PositionFlags_MIN = Config_PositionConfig_PositionFlags_PositionFlags_MIN;
  static constexpr PositionFlags PositionFlags_MAX = Config_PositionConfig_PositionFlags_PositionFlags_MAX;
  static constexpr int PositionFlags_ARRAYSIZE = Config_PositionConfig_PositionFlags_PositionFlags_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL PositionFlags_descriptor() {
    return Config_PositionConfig_PositionFlags_descriptor();
  }
  template <typename T>
  static inline const ::std::string& PositionFlags_Name(T value) {
    return Config_PositionConfig_PositionFlags_Name(value);
  }
  static inline bool PositionFlags_Parse(
      ::absl::string_view name, PositionFlags* PROTOBUF_NONNULL value) {
    return Config_PositionConfig_PositionFlags_Parse(name, value);
  }
  using GpsMode = Config_PositionConfig_GpsMode;
  static constexpr GpsMode DISABLED = Config_PositionConfig_GpsMode_DISABLED;
  static constexpr GpsMode ENABLED = Config_PositionConfig_GpsMode_ENABLED;
  static constexpr GpsMode NOT_PRESENT = Config_PositionConfig_GpsMode_NOT_PRESENT;
  static inline bool GpsMode_IsValid(int value) {
    return Config_PositionConfig_GpsMode_IsValid(value);
  }
  static constexpr GpsMode GpsMode_MIN = Config_PositionConfig_GpsMode_GpsMode_MIN;
  static constexpr GpsMode GpsMode_MAX = Config_PositionConfig_GpsMode_GpsMode_MAX;
  static constexpr int GpsMode_ARRAYSIZE = Config_PositionConfig_GpsMode_GpsMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL GpsMode_descriptor() {
    return Config_PositionConfig_GpsMode_descriptor();
  }
  template <typename T>
  static inline const ::std::string& GpsMode_Name(T value) {
    return Config_PositionConfig_GpsMode_Name(value);
  }
  static inline bool GpsMode_Parse(
      ::absl::string_view name, GpsMode* PROTOBUF_NONNULL value) {
    return Config_PositionConfig_GpsMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kPositionBroadcastSecsFieldNumber = 1,
    kPositionBroadcastSmartEnabledFieldNumber = 2,
    kFixedPositionFieldNumber = 3,
    kGpsEnabledFieldNumber = 4,
    kGpsUpdateIntervalFieldNumber = 5,
    kGpsAttemptTimeFieldNumber = 6,
    kPositionFlagsFieldNumber = 7,
    kRxGpioFieldNumber = 8,
    kTxGpioFieldNumber = 9,
    kBroadcastSmartMinimumDistanceFieldNumber = 10,
    kBroadcastSmartMinimumIntervalSecsFieldNumber = 11,
    kGpsEnGpioFieldNumber = 12,
    kGpsModeFieldNumber = 13,
  };
  // uint32 position_broadcast_secs = 1;
  void clear_position_broadcast_secs() ;
  ::uint32_t position_broadcast_secs() const;
  void set_position_broadcast_secs(::uint32_t value);

  private:
  ::uint32_t _internal_position_broadcast_secs() const;
  void _internal_set_position_broadcast_secs(::uint32_t value);

  public:
  // bool position_broadcast_smart_enabled = 2;
  void clear_position_broadcast_smart_enabled() ;
  bool position_broadcast_smart_enabled() const;
  void set_position_broadcast_smart_enabled(bool value);

  private:
  bool _internal_position_broadcast_smart_enabled() const;
  void _internal_set_position_broadcast_smart_enabled(bool value);

  public:
  // bool fixed_position = 3;
  void clear_fixed_position() ;
  bool fixed_position() const;
  void set_fixed_position(bool value);

  private:
  bool _internal_fixed_position() const;
  void _internal_set_fixed_position(bool value);

  public:
  // bool gps_enabled = 4 [deprecated = true];
  [[deprecated]]  void clear_gps_enabled() ;
  [[deprecated]] bool gps_enabled() const;
  [[deprecated]] void set_gps_enabled(bool value);

  private:
  bool _internal_gps_enabled() const;
  void _internal_set_gps_enabled(bool value);

  public:
  // uint32 gps_update_interval = 5;
  void clear_gps_update_interval() ;
  ::uint32_t gps_update_interval() const;
  void set_gps_update_interval(::uint32_t value);

  private:
  ::uint32_t _internal_gps_update_interval() const;
  void _internal_set_gps_update_interval(::uint32_t value);

  public:
  // uint32 gps_attempt_time = 6 [deprecated = true];
  [[deprecated]]  void clear_gps_attempt_time() ;
  [[deprecated]] ::uint32_t gps_attempt_time() const;
  [[deprecated]] void set_gps_attempt_time(::uint32_t value);

  private:
  ::uint32_t _internal_gps_attempt_time() const;
  void _internal_set_gps_attempt_time(::uint32_t value);

  public:
  // uint32 position_flags = 7;
  void clear_position_flags() ;
  ::uint32_t position_flags() const;
  void set_position_flags(::uint32_t value);

  private:
  ::uint32_t _internal_position_flags() const;
  void _internal_set_position_flags(::uint32_t value);

  public:
  // uint32 rx_gpio = 8;
  void clear_rx_gpio() ;
  ::uint32_t rx_gpio() const;
  void set_rx_gpio(::uint32_t value);

  private:
  ::uint32_t _internal_rx_gpio() const;
  void _internal_set_rx_gpio(::uint32_t value);

  public:
  // uint32 tx_gpio = 9;
  void clear_tx_gpio() ;
  ::uint32_t tx_gpio() const;
  void set_tx_gpio(::uint32_t value);

  private:
  ::uint32_t _internal_tx_gpio() const;
  void _internal_set_tx_gpio(::uint32_t value);

  public:
  // uint32 broadcast_smart_minimum_distance = 10;
  void clear_broadcast_smart_minimum_distance() ;
  ::uint32_t broadcast_smart_minimum_distance() const;
  void set_broadcast_smart_minimum_distance(::uint32_t value);

  private:
  ::uint32_t _internal_broadcast_smart_minimum_distance() const;
  void _internal_set_broadcast_smart_minimum_distance(::uint32_t value);

  public:
  // uint32 broadcast_smart_minimum_interval_secs = 11;
  void clear_broadcast_smart_minimum_interval_secs() ;
  ::uint32_t broadcast_smart_minimum_interval_secs() const;
  void set_broadcast_smart_minimum_interval_secs(::uint32_t value);

  private:
  ::uint32_t _internal_broadcast_smart_minimum_interval_secs() const;
  void _internal_set_broadcast_smart_minimum_interval_secs(::uint32_t value);

  public:
  // uint32 gps_en_gpio = 12;
  void clear_gps_en_gpio() ;
  ::uint32_t gps_en_gpio() const;
  void set_gps_en_gpio(::uint32_t value);

  private:
  ::uint32_t _internal_gps_en_gpio() const;
  void _internal_set_gps_en_gpio(::uint32_t value);

  public:
  // .meshtastic.Config.PositionConfig.GpsMode gps_mode = 13;
  void clear_gps_mode() ;
  ::meshtastic::Config_PositionConfig_GpsMode gps_mode() const;
  void set_gps_mode(::meshtastic::Config_PositionConfig_GpsMode value);

  private:
  ::meshtastic::Config_PositionConfig_GpsMode _internal_gps_mode() const;
  void _internal_set_gps_mode(::meshtastic::Config_PositionConfig_GpsMode value);

  public:
  // @@protoc_insertion_point(class_scope:meshtastic.Config.PositionConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 13,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Config_PositionConfig& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t position_broadcast_secs_;
    bool position_broadcast_smart_enabled_;
    bool fixed_position_;
    bool gps_enabled_;
    ::uint32_t gps_update_interval_;
    ::uint32_t gps_attempt_time_;
    ::uint32_t position_flags_;
    ::uint32_t rx_gpio_;
    ::uint32_t tx_gpio_;
    ::uint32_t broadcast_smart_minimum_distance_;
    ::uint32_t broadcast_smart_minimum_interval_secs_;
    ::uint32_t gps_en_gpio_;
    int gps_mode_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fconfig_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Config_PositionConfig_class_data_;
// -------------------------------------------------------------------

class Config_NetworkConfig_IpV4Config final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.Config.NetworkConfig.IpV4Config) */ {
 public:
  inline Config_NetworkConfig_IpV4Config() : Config_NetworkConfig_IpV4Config(nullptr) {}
  ~Config_NetworkConfig_IpV4Config() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Config_NetworkConfig_IpV4Config* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Config_NetworkConfig_IpV4Config));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Config_NetworkConfig_IpV4Config(::google::protobuf::internal::ConstantInitialized);

  inline Config_NetworkConfig_IpV4Config(const Config_NetworkConfig_IpV4Config& from) : Config_NetworkConfig_IpV4Config(nullptr, from) {}
  inline Config_NetworkConfig_IpV4Config(Config_NetworkConfig_IpV4Config&& from) noexcept
      : Config_NetworkConfig_IpV4Config(nullptr, ::std::move(from)) {}
  inline Config_NetworkConfig_IpV4Config& operator=(const Config_NetworkConfig_IpV4Config& from) {
    CopyFrom(from);
    return *this;
  }
  inline Config_NetworkConfig_IpV4Config& operator=(Config_NetworkConfig_IpV4Config&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Config_NetworkConfig_IpV4Config& default_instance() {
    return *reinterpret_cast<const Config_NetworkConfig_IpV4Config*>(
        &_Config_NetworkConfig_IpV4Config_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(Config_NetworkConfig_IpV4Config& a, Config_NetworkConfig_IpV4Config& b) { a.Swap(&b); }
  inline void Swap(Config_NetworkConfig_IpV4Config* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Config_NetworkConfig_IpV4Config* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Config_NetworkConfig_IpV4Config* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Config_NetworkConfig_IpV4Config>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Config_NetworkConfig_IpV4Config& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Config_NetworkConfig_IpV4Config& from) { Config_NetworkConfig_IpV4Config::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Config_NetworkConfig_IpV4Config* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.Config.NetworkConfig.IpV4Config"; }

 protected:
  explicit Config_NetworkConfig_IpV4Config(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Config_NetworkConfig_IpV4Config(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Config_NetworkConfig_IpV4Config& from);
  Config_NetworkConfig_IpV4Config(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Config_NetworkConfig_IpV4Config&& from) noexcept
      : Config_NetworkConfig_IpV4Config(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIpFieldNumber = 1,
    kGatewayFieldNumber = 2,
    kSubnetFieldNumber = 3,
    kDnsFieldNumber = 4,
  };
  // fixed32 ip = 1;
  void clear_ip() ;
  ::uint32_t ip() const;
  void set_ip(::uint32_t value);

  private:
  ::uint32_t _internal_ip() const;
  void _internal_set_ip(::uint32_t value);

  public:
  // fixed32 gateway = 2;
  void clear_gateway() ;
  ::uint32_t gateway() const;
  void set_gateway(::uint32_t value);

  private:
  ::uint32_t _internal_gateway() const;
  void _internal_set_gateway(::uint32_t value);

  public:
  // fixed32 subnet = 3;
  void clear_subnet() ;
  ::uint32_t subnet() const;
  void set_subnet(::uint32_t value);

  private:
  ::uint32_t _internal_subnet() const;
  void _internal_set_subnet(::uint32_t value);

  public:
  // fixed32 dns = 4;
  void clear_dns() ;
  ::uint32_t dns() const;
  void set_dns(::uint32_t value);

  private:
  ::uint32_t _internal_dns() const;
  void _internal_set_dns(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:meshtastic.Config.NetworkConfig.IpV4Config)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Config_NetworkConfig_IpV4Config& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t ip_;
    ::uint32_t gateway_;
    ::uint32_t subnet_;
    ::uint32_t dns_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fconfig_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Config_NetworkConfig_IpV4Config_class_data_;
// -------------------------------------------------------------------

class Config_LoRaConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.Config.LoRaConfig) */ {
 public:
  inline Config_LoRaConfig() : Config_LoRaConfig(nullptr) {}
  ~Config_LoRaConfig() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Config_LoRaConfig* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Config_LoRaConfig));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Config_LoRaConfig(::google::protobuf::internal::ConstantInitialized);

  inline Config_LoRaConfig(const Config_LoRaConfig& from) : Config_LoRaConfig(nullptr, from) {}
  inline Config_LoRaConfig(Config_LoRaConfig&& from) noexcept
      : Config_LoRaConfig(nullptr, ::std::move(from)) {}
  inline Config_LoRaConfig& operator=(const Config_LoRaConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline Config_LoRaConfig& operator=(Config_LoRaConfig&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Config_LoRaConfig& default_instance() {
    return *reinterpret_cast<const Config_LoRaConfig*>(
        &_Config_LoRaConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(Config_LoRaConfig& a, Config_LoRaConfig& b) { a.Swap(&b); }
  inline void Swap(Config_LoRaConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Config_LoRaConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Config_LoRaConfig* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Config_LoRaConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Config_LoRaConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Config_LoRaConfig& from) { Config_LoRaConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Config_LoRaConfig* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.Config.LoRaConfig"; }

 protected:
  explicit Config_LoRaConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Config_LoRaConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Config_LoRaConfig& from);
  Config_LoRaConfig(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Config_LoRaConfig&& from) noexcept
      : Config_LoRaConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using RegionCode = Config_LoRaConfig_RegionCode;
  static constexpr RegionCode UNSET = Config_LoRaConfig_RegionCode_UNSET;
  static constexpr RegionCode US = Config_LoRaConfig_RegionCode_US;
  static constexpr RegionCode EU_433 = Config_LoRaConfig_RegionCode_EU_433;
  static constexpr RegionCode EU_868 = Config_LoRaConfig_RegionCode_EU_868;
  static constexpr RegionCode CN = Config_LoRaConfig_RegionCode_CN;
  static constexpr RegionCode JP = Config_LoRaConfig_RegionCode_JP;
  static constexpr RegionCode ANZ = Config_LoRaConfig_RegionCode_ANZ;
  static constexpr RegionCode KR = Config_LoRaConfig_RegionCode_KR;
  static constexpr RegionCode TW = Config_LoRaConfig_RegionCode_TW;
  static constexpr RegionCode RU = Config_LoRaConfig_RegionCode_RU;
  static constexpr RegionCode IN = Config_LoRaConfig_RegionCode_IN;
  static constexpr RegionCode NZ_865 = Config_LoRaConfig_RegionCode_NZ_865;
  static constexpr RegionCode TH = Config_LoRaConfig_RegionCode_TH;
  static constexpr RegionCode LORA_24 = Config_LoRaConfig_RegionCode_LORA_24;
  static constexpr RegionCode UA_433 = Config_LoRaConfig_RegionCode_UA_433;
  static constexpr RegionCode UA_868 = Config_LoRaConfig_RegionCode_UA_868;
  static constexpr RegionCode MY_433 = Config_LoRaConfig_RegionCode_MY_433;
  static constexpr RegionCode MY_919 = Config_LoRaConfig_RegionCode_MY_919;
  static constexpr RegionCode SG_923 = Config_LoRaConfig_RegionCode_SG_923;
  static constexpr RegionCode PH_433 = Config_LoRaConfig_RegionCode_PH_433;
  static constexpr RegionCode PH_868 = Config_LoRaConfig_RegionCode_PH_868;
  static constexpr RegionCode PH_915 = Config_LoRaConfig_RegionCode_PH_915;
  static constexpr RegionCode ANZ_433 = Config_LoRaConfig_RegionCode_ANZ_433;
  static constexpr RegionCode KZ_433 = Config_LoRaConfig_RegionCode_KZ_433;
  static constexpr RegionCode KZ_863 = Config_LoRaConfig_RegionCode_KZ_863;
  static constexpr RegionCode NP_865 = Config_LoRaConfig_RegionCode_NP_865;
  static constexpr RegionCode BR_902 = Config_LoRaConfig_RegionCode_BR_902;
  static inline bool RegionCode_IsValid(int value) {
    return Config_LoRaConfig_RegionCode_IsValid(value);
  }
  static constexpr RegionCode RegionCode_MIN = Config_LoRaConfig_RegionCode_RegionCode_MIN;
  static constexpr RegionCode RegionCode_MAX = Config_LoRaConfig_RegionCode_RegionCode_MAX;
  static constexpr int RegionCode_ARRAYSIZE = Config_LoRaConfig_RegionCode_RegionCode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL RegionCode_descriptor() {
    return Config_LoRaConfig_RegionCode_descriptor();
  }
  template <typename T>
  static inline const ::std::string& RegionCode_Name(T value) {
    return Config_LoRaConfig_RegionCode_Name(value);
  }
  static inline bool RegionCode_Parse(
      ::absl::string_view name, RegionCode* PROTOBUF_NONNULL value) {
    return Config_LoRaConfig_RegionCode_Parse(name, value);
  }
  using ModemPreset = Config_LoRaConfig_ModemPreset;
  static constexpr ModemPreset LONG_FAST = Config_LoRaConfig_ModemPreset_LONG_FAST;
  static constexpr ModemPreset LONG_SLOW = Config_LoRaConfig_ModemPreset_LONG_SLOW;
  [[deprecated]] static constexpr ModemPreset VERY_LONG_SLOW = Config_LoRaConfig_ModemPreset_VERY_LONG_SLOW;
  static constexpr ModemPreset MEDIUM_SLOW = Config_LoRaConfig_ModemPreset_MEDIUM_SLOW;
  static constexpr ModemPreset MEDIUM_FAST = Config_LoRaConfig_ModemPreset_MEDIUM_FAST;
  static constexpr ModemPreset SHORT_SLOW = Config_LoRaConfig_ModemPreset_SHORT_SLOW;
  static constexpr ModemPreset SHORT_FAST = Config_LoRaConfig_ModemPreset_SHORT_FAST;
  static constexpr ModemPreset LONG_MODERATE = Config_LoRaConfig_ModemPreset_LONG_MODERATE;
  static constexpr ModemPreset SHORT_TURBO = Config_LoRaConfig_ModemPreset_SHORT_TURBO;
  static inline bool ModemPreset_IsValid(int value) {
    return Config_LoRaConfig_ModemPreset_IsValid(value);
  }
  static constexpr ModemPreset ModemPreset_MIN = Config_LoRaConfig_ModemPreset_ModemPreset_MIN;
  static constexpr ModemPreset ModemPreset_MAX = Config_LoRaConfig_ModemPreset_ModemPreset_MAX;
  static constexpr int ModemPreset_ARRAYSIZE = Config_LoRaConfig_ModemPreset_ModemPreset_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ModemPreset_descriptor() {
    return Config_LoRaConfig_ModemPreset_descriptor();
  }
  template <typename T>
  static inline const ::std::string& ModemPreset_Name(T value) {
    return Config_LoRaConfig_ModemPreset_Name(value);
  }
  static inline bool ModemPreset_Parse(
      ::absl::string_view name, ModemPreset* PROTOBUF_NONNULL value) {
    return Config_LoRaConfig_ModemPreset_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kIgnoreIncomingFieldNumber = 103,
    kModemPresetFieldNumber = 2,
    kBandwidthFieldNumber = 3,
    kSpreadFactorFieldNumber = 4,
    kCodingRateFieldNumber = 5,
    kFrequencyOffsetFieldNumber = 6,
    kRegionFieldNumber = 7,
    kHopLimitFieldNumber = 8,
    kUsePresetFieldNumber = 1,
    kTxEnabledFieldNumber = 9,
    kOverrideDutyCycleFieldNumber = 12,
    kSx126XRxBoostedGainFieldNumber = 13,
    kTxPowerFieldNumber = 10,
    kChannelNumFieldNumber = 11,
    kOverrideFrequencyFieldNumber = 14,
    kPaFanDisabledFieldNumber = 15,
    kIgnoreMqttFieldNumber = 104,
    kConfigOkToMqttFieldNumber = 105,
  };
  // repeated uint32 ignore_incoming = 103;
  int ignore_incoming_size() const;
  private:
  int _internal_ignore_incoming_size() const;

  public:
  void clear_ignore_incoming() ;
  ::uint32_t ignore_incoming(int index) const;
  void set_ignore_incoming(int index, ::uint32_t value);
  void add_ignore_incoming(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& ignore_incoming() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL mutable_ignore_incoming();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_ignore_incoming() const;
  ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL _internal_mutable_ignore_incoming();

  public:
  // .meshtastic.Config.LoRaConfig.ModemPreset modem_preset = 2;
  void clear_modem_preset() ;
  ::meshtastic::Config_LoRaConfig_ModemPreset modem_preset() const;
  void set_modem_preset(::meshtastic::Config_LoRaConfig_ModemPreset value);

  private:
  ::meshtastic::Config_LoRaConfig_ModemPreset _internal_modem_preset() const;
  void _internal_set_modem_preset(::meshtastic::Config_LoRaConfig_ModemPreset value);

  public:
  // uint32 bandwidth = 3;
  void clear_bandwidth() ;
  ::uint32_t bandwidth() const;
  void set_bandwidth(::uint32_t value);

  private:
  ::uint32_t _internal_bandwidth() const;
  void _internal_set_bandwidth(::uint32_t value);

  public:
  // uint32 spread_factor = 4;
  void clear_spread_factor() ;
  ::uint32_t spread_factor() const;
  void set_spread_factor(::uint32_t value);

  private:
  ::uint32_t _internal_spread_factor() const;
  void _internal_set_spread_factor(::uint32_t value);

  public:
  // uint32 coding_rate = 5;
  void clear_coding_rate() ;
  ::uint32_t coding_rate() const;
  void set_coding_rate(::uint32_t value);

  private:
  ::uint32_t _internal_coding_rate() const;
  void _internal_set_coding_rate(::uint32_t value);

  public:
  // float frequency_offset = 6;
  void clear_frequency_offset() ;
  float frequency_offset() const;
  void set_frequency_offset(float value);

  private:
  float _internal_frequency_offset() const;
  void _internal_set_frequency_offset(float value);

  public:
  // .meshtastic.Config.LoRaConfig.RegionCode region = 7;
  void clear_region() ;
  ::meshtastic::Config_LoRaConfig_RegionCode region() const;
  void set_region(::meshtastic::Config_LoRaConfig_RegionCode value);

  private:
  ::meshtastic::Config_LoRaConfig_RegionCode _internal_region() const;
  void _internal_set_region(::meshtastic::Config_LoRaConfig_RegionCode value);

  public:
  // uint32 hop_limit = 8;
  void clear_hop_limit() ;
  ::uint32_t hop_limit() const;
  void set_hop_limit(::uint32_t value);

  private:
  ::uint32_t _internal_hop_limit() const;
  void _internal_set_hop_limit(::uint32_t value);

  public:
  // bool use_preset = 1;
  void clear_use_preset() ;
  bool use_preset() const;
  void set_use_preset(bool value);

  private:
  bool _internal_use_preset() const;
  void _internal_set_use_preset(bool value);

  public:
  // bool tx_enabled = 9;
  void clear_tx_enabled() ;
  bool tx_enabled() const;
  void set_tx_enabled(bool value);

  private:
  bool _internal_tx_enabled() const;
  void _internal_set_tx_enabled(bool value);

  public:
  // bool override_duty_cycle = 12;
  void clear_override_duty_cycle() ;
  bool override_duty_cycle() const;
  void set_override_duty_cycle(bool value);

  private:
  bool _internal_override_duty_cycle() const;
  void _internal_set_override_duty_cycle(bool value);

  public:
  // bool sx126x_rx_boosted_gain = 13;
  void clear_sx126x_rx_boosted_gain() ;
  bool sx126x_rx_boosted_gain() const;
  void set_sx126x_rx_boosted_gain(bool value);

  private:
  bool _internal_sx126x_rx_boosted_gain() const;
  void _internal_set_sx126x_rx_boosted_gain(bool value);

  public:
  // int32 tx_power = 10;
  void clear_tx_power() ;
  ::int32_t tx_power() const;
  void set_tx_power(::int32_t value);

  private:
  ::int32_t _internal_tx_power() const;
  void _internal_set_tx_power(::int32_t value);

  public:
  // uint32 channel_num = 11;
  void clear_channel_num() ;
  ::uint32_t channel_num() const;
  void set_channel_num(::uint32_t value);

  private:
  ::uint32_t _internal_channel_num() const;
  void _internal_set_channel_num(::uint32_t value);

  public:
  // float override_frequency = 14;
  void clear_override_frequency() ;
  float override_frequency() const;
  void set_override_frequency(float value);

  private:
  float _internal_override_frequency() const;
  void _internal_set_override_frequency(float value);

  public:
  // bool pa_fan_disabled = 15;
  void clear_pa_fan_disabled() ;
  bool pa_fan_disabled() const;
  void set_pa_fan_disabled(bool value);

  private:
  bool _internal_pa_fan_disabled() const;
  void _internal_set_pa_fan_disabled(bool value);

  public:
  // bool ignore_mqtt = 104;
  void clear_ignore_mqtt() ;
  bool ignore_mqtt() const;
  void set_ignore_mqtt(bool value);

  private:
  bool _internal_ignore_mqtt() const;
  void _internal_set_ignore_mqtt(bool value);

  public:
  // bool config_ok_to_mqtt = 105;
  void clear_config_ok_to_mqtt() ;
  bool config_ok_to_mqtt() const;
  void set_config_ok_to_mqtt(bool value);

  private:
  bool _internal_config_ok_to_mqtt() const;
  void _internal_set_config_ok_to_mqtt(bool value);

  public:
  // @@protoc_insertion_point(class_scope:meshtastic.Config.LoRaConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<5, 18,
                                   0, 0,
                                   7>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Config_LoRaConfig& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::uint32_t> ignore_incoming_;
    ::google::protobuf::internal::CachedSize _ignore_incoming_cached_byte_size_;
    int modem_preset_;
    ::uint32_t bandwidth_;
    ::uint32_t spread_factor_;
    ::uint32_t coding_rate_;
    float frequency_offset_;
    int region_;
    ::uint32_t hop_limit_;
    bool use_preset_;
    bool tx_enabled_;
    bool override_duty_cycle_;
    bool sx126x_rx_boosted_gain_;
    ::int32_t tx_power_;
    ::uint32_t channel_num_;
    float override_frequency_;
    bool pa_fan_disabled_;
    bool ignore_mqtt_;
    bool config_ok_to_mqtt_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fconfig_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Config_LoRaConfig_class_data_;
// -------------------------------------------------------------------

class Config_DisplayConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.Config.DisplayConfig) */ {
 public:
  inline Config_DisplayConfig() : Config_DisplayConfig(nullptr) {}
  ~Config_DisplayConfig() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Config_DisplayConfig* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Config_DisplayConfig));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Config_DisplayConfig(::google::protobuf::internal::ConstantInitialized);

  inline Config_DisplayConfig(const Config_DisplayConfig& from) : Config_DisplayConfig(nullptr, from) {}
  inline Config_DisplayConfig(Config_DisplayConfig&& from) noexcept
      : Config_DisplayConfig(nullptr, ::std::move(from)) {}
  inline Config_DisplayConfig& operator=(const Config_DisplayConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline Config_DisplayConfig& operator=(Config_DisplayConfig&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Config_DisplayConfig& default_instance() {
    return *reinterpret_cast<const Config_DisplayConfig*>(
        &_Config_DisplayConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(Config_DisplayConfig& a, Config_DisplayConfig& b) { a.Swap(&b); }
  inline void Swap(Config_DisplayConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Config_DisplayConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Config_DisplayConfig* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Config_DisplayConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Config_DisplayConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Config_DisplayConfig& from) { Config_DisplayConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Config_DisplayConfig* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.Config.DisplayConfig"; }

 protected:
  explicit Config_DisplayConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Config_DisplayConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Config_DisplayConfig& from);
  Config_DisplayConfig(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Config_DisplayConfig&& from) noexcept
      : Config_DisplayConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using GpsCoordinateFormat = Config_DisplayConfig_GpsCoordinateFormat;
  static constexpr GpsCoordinateFormat DEC = Config_DisplayConfig_GpsCoordinateFormat_DEC;
  static constexpr GpsCoordinateFormat DMS = Config_DisplayConfig_GpsCoordinateFormat_DMS;
  static constexpr GpsCoordinateFormat UTM = Config_DisplayConfig_GpsCoordinateFormat_UTM;
  static constexpr GpsCoordinateFormat MGRS = Config_DisplayConfig_GpsCoordinateFormat_MGRS;
  static constexpr GpsCoordinateFormat OLC = Config_DisplayConfig_GpsCoordinateFormat_OLC;
  static constexpr GpsCoordinateFormat OSGR = Config_DisplayConfig_GpsCoordinateFormat_OSGR;
  static inline bool GpsCoordinateFormat_IsValid(int value) {
    return Config_DisplayConfig_GpsCoordinateFormat_IsValid(value);
  }
  static constexpr GpsCoordinateFormat GpsCoordinateFormat_MIN = Config_DisplayConfig_GpsCoordinateFormat_GpsCoordinateFormat_MIN;
  static constexpr GpsCoordinateFormat GpsCoordinateFormat_MAX = Config_DisplayConfig_GpsCoordinateFormat_GpsCoordinateFormat_MAX;
  static constexpr int GpsCoordinateFormat_ARRAYSIZE = Config_DisplayConfig_GpsCoordinateFormat_GpsCoordinateFormat_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL GpsCoordinateFormat_descriptor() {
    return Config_DisplayConfig_GpsCoordinateFormat_descriptor();
  }
  template <typename T>
  static inline const ::std::string& GpsCoordinateFormat_Name(T value) {
    return Config_DisplayConfig_GpsCoordinateFormat_Name(value);
  }
  static inline bool GpsCoordinateFormat_Parse(
      ::absl::string_view name, GpsCoordinateFormat* PROTOBUF_NONNULL value) {
    return Config_DisplayConfig_GpsCoordinateFormat_Parse(name, value);
  }
  using DisplayUnits = Config_DisplayConfig_DisplayUnits;
  static constexpr DisplayUnits METRIC = Config_DisplayConfig_DisplayUnits_METRIC;
  static constexpr DisplayUnits IMPERIAL = Config_DisplayConfig_DisplayUnits_IMPERIAL;
  static inline bool DisplayUnits_IsValid(int value) {
    return Config_DisplayConfig_DisplayUnits_IsValid(value);
  }
  static constexpr DisplayUnits DisplayUnits_MIN = Config_DisplayConfig_DisplayUnits_DisplayUnits_MIN;
  static constexpr DisplayUnits DisplayUnits_MAX = Config_DisplayConfig_DisplayUnits_DisplayUnits_MAX;
  static constexpr int DisplayUnits_ARRAYSIZE = Config_DisplayConfig_DisplayUnits_DisplayUnits_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL DisplayUnits_descriptor() {
    return Config_DisplayConfig_DisplayUnits_descriptor();
  }
  template <typename T>
  static inline const ::std::string& DisplayUnits_Name(T value) {
    return Config_DisplayConfig_DisplayUnits_Name(value);
  }
  static inline bool DisplayUnits_Parse(
      ::absl::string_view name, DisplayUnits* PROTOBUF_NONNULL value) {
    return Config_DisplayConfig_DisplayUnits_Parse(name, value);
  }
  using OledType = Config_DisplayConfig_OledType;
  static constexpr OledType OLED_AUTO = Config_DisplayConfig_OledType_OLED_AUTO;
  static constexpr OledType OLED_SSD1306 = Config_DisplayConfig_OledType_OLED_SSD1306;
  static constexpr OledType OLED_SH1106 = Config_DisplayConfig_OledType_OLED_SH1106;
  static constexpr OledType OLED_SH1107 = Config_DisplayConfig_OledType_OLED_SH1107;
  static constexpr OledType OLED_SH1107_128_128 = Config_DisplayConfig_OledType_OLED_SH1107_128_128;
  static inline bool OledType_IsValid(int value) {
    return Config_DisplayConfig_OledType_IsValid(value);
  }
  static constexpr OledType OledType_MIN = Config_DisplayConfig_OledType_OledType_MIN;
  static constexpr OledType OledType_MAX = Config_DisplayConfig_OledType_OledType_MAX;
  static constexpr int OledType_ARRAYSIZE = Config_DisplayConfig_OledType_OledType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL OledType_descriptor() {
    return Config_DisplayConfig_OledType_descriptor();
  }
  template <typename T>
  static inline const ::std::string& OledType_Name(T value) {
    return Config_DisplayConfig_OledType_Name(value);
  }
  static inline bool OledType_Parse(
      ::absl::string_view name, OledType* PROTOBUF_NONNULL value) {
    return Config_DisplayConfig_OledType_Parse(name, value);
  }
  using DisplayMode = Config_DisplayConfig_DisplayMode;
  static constexpr DisplayMode DEFAULT = Config_DisplayConfig_DisplayMode_DEFAULT;
  static constexpr DisplayMode TWOCOLOR = Config_DisplayConfig_DisplayMode_TWOCOLOR;
  static constexpr DisplayMode INVERTED = Config_DisplayConfig_DisplayMode_INVERTED;
  static constexpr DisplayMode COLOR = Config_DisplayConfig_DisplayMode_COLOR;
  static inline bool DisplayMode_IsValid(int value) {
    return Config_DisplayConfig_DisplayMode_IsValid(value);
  }
  static constexpr DisplayMode DisplayMode_MIN = Config_DisplayConfig_DisplayMode_DisplayMode_MIN;
  static constexpr DisplayMode DisplayMode_MAX = Config_DisplayConfig_DisplayMode_DisplayMode_MAX;
  static constexpr int DisplayMode_ARRAYSIZE = Config_DisplayConfig_DisplayMode_DisplayMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL DisplayMode_descriptor() {
    return Config_DisplayConfig_DisplayMode_descriptor();
  }
  template <typename T>
  static inline const ::std::string& DisplayMode_Name(T value) {
    return Config_DisplayConfig_DisplayMode_Name(value);
  }
  static inline bool DisplayMode_Parse(
      ::absl::string_view name, DisplayMode* PROTOBUF_NONNULL value) {
    return Config_DisplayConfig_DisplayMode_Parse(name, value);
  }
  using CompassOrientation = Config_DisplayConfig_CompassOrientation;
  static constexpr CompassOrientation DEGREES_0 = Config_DisplayConfig_CompassOrientation_DEGREES_0;
  static constexpr CompassOrientation DEGREES_90 = Config_DisplayConfig_CompassOrientation_DEGREES_90;
  static constexpr CompassOrientation DEGREES_180 = Config_DisplayConfig_CompassOrientation_DEGREES_180;
  static constexpr CompassOrientation DEGREES_270 = Config_DisplayConfig_CompassOrientation_DEGREES_270;
  static constexpr CompassOrientation DEGREES_0_INVERTED = Config_DisplayConfig_CompassOrientation_DEGREES_0_INVERTED;
  static constexpr CompassOrientation DEGREES_90_INVERTED = Config_DisplayConfig_CompassOrientation_DEGREES_90_INVERTED;
  static constexpr CompassOrientation DEGREES_180_INVERTED = Config_DisplayConfig_CompassOrientation_DEGREES_180_INVERTED;
  static constexpr CompassOrientation DEGREES_270_INVERTED = Config_DisplayConfig_CompassOrientation_DEGREES_270_INVERTED;
  static inline bool CompassOrientation_IsValid(int value) {
    return Config_DisplayConfig_CompassOrientation_IsValid(value);
  }
  static constexpr CompassOrientation CompassOrientation_MIN = Config_DisplayConfig_CompassOrientation_CompassOrientation_MIN;
  static constexpr CompassOrientation CompassOrientation_MAX = Config_DisplayConfig_CompassOrientation_CompassOrientation_MAX;
  static constexpr int CompassOrientation_ARRAYSIZE = Config_DisplayConfig_CompassOrientation_CompassOrientation_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL CompassOrientation_descriptor() {
    return Config_DisplayConfig_CompassOrientation_descriptor();
  }
  template <typename T>
  static inline const ::std::string& CompassOrientation_Name(T value) {
    return Config_DisplayConfig_CompassOrientation_Name(value);
  }
  static inline bool CompassOrientation_Parse(
      ::absl::string_view name, CompassOrientation* PROTOBUF_NONNULL value) {
    return Config_DisplayConfig_CompassOrientation_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kScreenOnSecsFieldNumber = 1,
    kGpsFormatFieldNumber = 2,
    kAutoScreenCarouselSecsFieldNumber = 3,
    kUnitsFieldNumber = 6,
    kOledFieldNumber = 7,
    kCompassNorthTopFieldNumber = 4,
    kFlipScreenFieldNumber = 5,
    kHeadingBoldFieldNumber = 9,
    kWakeOnTapOrMotionFieldNumber = 10,
    kDisplaymodeFieldNumber = 8,
    kCompassOrientationFieldNumber = 11,
    kUse12HClockFieldNumber = 12,
  };
  // uint32 screen_on_secs = 1;
  void clear_screen_on_secs() ;
  ::uint32_t screen_on_secs() const;
  void set_screen_on_secs(::uint32_t value);

  private:
  ::uint32_t _internal_screen_on_secs() const;
  void _internal_set_screen_on_secs(::uint32_t value);

  public:
  // .meshtastic.Config.DisplayConfig.GpsCoordinateFormat gps_format = 2 [deprecated = true];
  [[deprecated]]  void clear_gps_format() ;
  [[deprecated]] ::meshtastic::Config_DisplayConfig_GpsCoordinateFormat gps_format() const;
  [[deprecated]] void set_gps_format(::meshtastic::Config_DisplayConfig_GpsCoordinateFormat value);

  private:
  ::meshtastic::Config_DisplayConfig_GpsCoordinateFormat _internal_gps_format() const;
  void _internal_set_gps_format(::meshtastic::Config_DisplayConfig_GpsCoordinateFormat value);

  public:
  // uint32 auto_screen_carousel_secs = 3;
  void clear_auto_screen_carousel_secs() ;
  ::uint32_t auto_screen_carousel_secs() const;
  void set_auto_screen_carousel_secs(::uint32_t value);

  private:
  ::uint32_t _internal_auto_screen_carousel_secs() const;
  void _internal_set_auto_screen_carousel_secs(::uint32_t value);

  public:
  // .meshtastic.Config.DisplayConfig.DisplayUnits units = 6;
  void clear_units() ;
  ::meshtastic::Config_DisplayConfig_DisplayUnits units() const;
  void set_units(::meshtastic::Config_DisplayConfig_DisplayUnits value);

  private:
  ::meshtastic::Config_DisplayConfig_DisplayUnits _internal_units() const;
  void _internal_set_units(::meshtastic::Config_DisplayConfig_DisplayUnits value);

  public:
  // .meshtastic.Config.DisplayConfig.OledType oled = 7;
  void clear_oled() ;
  ::meshtastic::Config_DisplayConfig_OledType oled() const;
  void set_oled(::meshtastic::Config_DisplayConfig_OledType value);

  private:
  ::meshtastic::Config_DisplayConfig_OledType _internal_oled() const;
  void _internal_set_oled(::meshtastic::Config_DisplayConfig_OledType value);

  public:
  // bool compass_north_top = 4 [deprecated = true];
  [[deprecated]]  void clear_compass_north_top() ;
  [[deprecated]] bool compass_north_top() const;
  [[deprecated]] void set_compass_north_top(bool value);

  private:
  bool _internal_compass_north_top() const;
  void _internal_set_compass_north_top(bool value);

  public:
  // bool flip_screen = 5;
  void clear_flip_screen() ;
  bool flip_screen() const;
  void set_flip_screen(bool value);

  private:
  bool _internal_flip_screen() const;
  void _internal_set_flip_screen(bool value);

  public:
  // bool heading_bold = 9;
  void clear_heading_bold() ;
  bool heading_bold() const;
  void set_heading_bold(bool value);

  private:
  bool _internal_heading_bold() const;
  void _internal_set_heading_bold(bool value);

  public:
  // bool wake_on_tap_or_motion = 10;
  void clear_wake_on_tap_or_motion() ;
  bool wake_on_tap_or_motion() const;
  void set_wake_on_tap_or_motion(bool value);

  private:
  bool _internal_wake_on_tap_or_motion() const;
  void _internal_set_wake_on_tap_or_motion(bool value);

  public:
  // .meshtastic.Config.DisplayConfig.DisplayMode displaymode = 8;
  void clear_displaymode() ;
  ::meshtastic::Config_DisplayConfig_DisplayMode displaymode() const;
  void set_displaymode(::meshtastic::Config_DisplayConfig_DisplayMode value);

  private:
  ::meshtastic::Config_DisplayConfig_DisplayMode _internal_displaymode() const;
  void _internal_set_displaymode(::meshtastic::Config_DisplayConfig_DisplayMode value);

  public:
  // .meshtastic.Config.DisplayConfig.CompassOrientation compass_orientation = 11;
  void clear_compass_orientation() ;
  ::meshtastic::Config_DisplayConfig_CompassOrientation compass_orientation() const;
  void set_compass_orientation(::meshtastic::Config_DisplayConfig_CompassOrientation value);

  private:
  ::meshtastic::Config_DisplayConfig_CompassOrientation _internal_compass_orientation() const;
  void _internal_set_compass_orientation(::meshtastic::Config_DisplayConfig_CompassOrientation value);

  public:
  // bool use_12h_clock = 12;
  void clear_use_12h_clock() ;
  bool use_12h_clock() const;
  void set_use_12h_clock(bool value);

  private:
  bool _internal_use_12h_clock() const;
  void _internal_set_use_12h_clock(bool value);

  public:
  // @@protoc_insertion_point(class_scope:meshtastic.Config.DisplayConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 12,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Config_DisplayConfig& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t screen_on_secs_;
    int gps_format_;
    ::uint32_t auto_screen_carousel_secs_;
    int units_;
    int oled_;
    bool compass_north_top_;
    bool flip_screen_;
    bool heading_bold_;
    bool wake_on_tap_or_motion_;
    int displaymode_;
    int compass_orientation_;
    bool use_12h_clock_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fconfig_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Config_DisplayConfig_class_data_;
// -------------------------------------------------------------------

class Config_DeviceConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.Config.DeviceConfig) */ {
 public:
  inline Config_DeviceConfig() : Config_DeviceConfig(nullptr) {}
  ~Config_DeviceConfig() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Config_DeviceConfig* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Config_DeviceConfig));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Config_DeviceConfig(::google::protobuf::internal::ConstantInitialized);

  inline Config_DeviceConfig(const Config_DeviceConfig& from) : Config_DeviceConfig(nullptr, from) {}
  inline Config_DeviceConfig(Config_DeviceConfig&& from) noexcept
      : Config_DeviceConfig(nullptr, ::std::move(from)) {}
  inline Config_DeviceConfig& operator=(const Config_DeviceConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline Config_DeviceConfig& operator=(Config_DeviceConfig&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Config_DeviceConfig& default_instance() {
    return *reinterpret_cast<const Config_DeviceConfig*>(
        &_Config_DeviceConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Config_DeviceConfig& a, Config_DeviceConfig& b) { a.Swap(&b); }
  inline void Swap(Config_DeviceConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Config_DeviceConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Config_DeviceConfig* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Config_DeviceConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Config_DeviceConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Config_DeviceConfig& from) { Config_DeviceConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Config_DeviceConfig* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.Config.DeviceConfig"; }

 protected:
  explicit Config_DeviceConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Config_DeviceConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Config_DeviceConfig& from);
  Config_DeviceConfig(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Config_DeviceConfig&& from) noexcept
      : Config_DeviceConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Role = Config_DeviceConfig_Role;
  static constexpr Role CLIENT = Config_DeviceConfig_Role_CLIENT;
  static constexpr Role CLIENT_MUTE = Config_DeviceConfig_Role_CLIENT_MUTE;
  static constexpr Role ROUTER = Config_DeviceConfig_Role_ROUTER;
  [[deprecated]] static constexpr Role ROUTER_CLIENT = Config_DeviceConfig_Role_ROUTER_CLIENT;
  static constexpr Role REPEATER = Config_DeviceConfig_Role_REPEATER;
  static constexpr Role TRACKER = Config_DeviceConfig_Role_TRACKER;
  static constexpr Role SENSOR = Config_DeviceConfig_Role_SENSOR;
  static constexpr Role TAK = Config_DeviceConfig_Role_TAK;
  static constexpr Role CLIENT_HIDDEN = Config_DeviceConfig_Role_CLIENT_HIDDEN;
  static constexpr Role LOST_AND_FOUND = Config_DeviceConfig_Role_LOST_AND_FOUND;
  static constexpr Role TAK_TRACKER = Config_DeviceConfig_Role_TAK_TRACKER;
  static constexpr Role ROUTER_LATE = Config_DeviceConfig_Role_ROUTER_LATE;
  static inline bool Role_IsValid(int value) {
    return Config_DeviceConfig_Role_IsValid(value);
  }
  static constexpr Role Role_MIN = Config_DeviceConfig_Role_Role_MIN;
  static constexpr Role Role_MAX = Config_DeviceConfig_Role_Role_MAX;
  static constexpr int Role_ARRAYSIZE = Config_DeviceConfig_Role_Role_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Role_descriptor() {
    return Config_DeviceConfig_Role_descriptor();
  }
  template <typename T>
  static inline const ::std::string& Role_Name(T value) {
    return Config_DeviceConfig_Role_Name(value);
  }
  static inline bool Role_Parse(
      ::absl::string_view name, Role* PROTOBUF_NONNULL value) {
    return Config_DeviceConfig_Role_Parse(name, value);
  }
  using RebroadcastMode = Config_DeviceConfig_RebroadcastMode;
  static constexpr RebroadcastMode ALL = Config_DeviceConfig_RebroadcastMode_ALL;
  static constexpr RebroadcastMode ALL_SKIP_DECODING = Config_DeviceConfig_RebroadcastMode_ALL_SKIP_DECODING;
  static constexpr RebroadcastMode LOCAL_ONLY = Config_DeviceConfig_RebroadcastMode_LOCAL_ONLY;
  static constexpr RebroadcastMode KNOWN_ONLY = Config_DeviceConfig_RebroadcastMode_KNOWN_ONLY;
  static constexpr RebroadcastMode NONE = Config_DeviceConfig_RebroadcastMode_NONE;
  static constexpr RebroadcastMode CORE_PORTNUMS_ONLY = Config_DeviceConfig_RebroadcastMode_CORE_PORTNUMS_ONLY;
  static inline bool RebroadcastMode_IsValid(int value) {
    return Config_DeviceConfig_RebroadcastMode_IsValid(value);
  }
  static constexpr RebroadcastMode RebroadcastMode_MIN = Config_DeviceConfig_RebroadcastMode_RebroadcastMode_MIN;
  static constexpr RebroadcastMode RebroadcastMode_MAX = Config_DeviceConfig_RebroadcastMode_RebroadcastMode_MAX;
  static constexpr int RebroadcastMode_ARRAYSIZE = Config_DeviceConfig_RebroadcastMode_RebroadcastMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL RebroadcastMode_descriptor() {
    return Config_DeviceConfig_RebroadcastMode_descriptor();
  }
  template <typename T>
  static inline const ::std::string& RebroadcastMode_Name(T value) {
    return Config_DeviceConfig_RebroadcastMode_Name(value);
  }
  static inline bool RebroadcastMode_Parse(
      ::absl::string_view name, RebroadcastMode* PROTOBUF_NONNULL value) {
    return Config_DeviceConfig_RebroadcastMode_Parse(name, value);
  }
  using BuzzerMode = Config_DeviceConfig_BuzzerMode;
  static constexpr BuzzerMode ALL_ENABLED = Config_DeviceConfig_BuzzerMode_ALL_ENABLED;
  static constexpr BuzzerMode DISABLED = Config_DeviceConfig_BuzzerMode_DISABLED;
  static constexpr BuzzerMode NOTIFICATIONS_ONLY = Config_DeviceConfig_BuzzerMode_NOTIFICATIONS_ONLY;
  static constexpr BuzzerMode SYSTEM_ONLY = Config_DeviceConfig_BuzzerMode_SYSTEM_ONLY;
  static constexpr BuzzerMode DIRECT_MSG_ONLY = Config_DeviceConfig_BuzzerMode_DIRECT_MSG_ONLY;
  static inline bool BuzzerMode_IsValid(int value) {
    return Config_DeviceConfig_BuzzerMode_IsValid(value);
  }
  static constexpr BuzzerMode BuzzerMode_MIN = Config_DeviceConfig_BuzzerMode_BuzzerMode_MIN;
  static constexpr BuzzerMode BuzzerMode_MAX = Config_DeviceConfig_BuzzerMode_BuzzerMode_MAX;
  static constexpr int BuzzerMode_ARRAYSIZE = Config_DeviceConfig_BuzzerMode_BuzzerMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL BuzzerMode_descriptor() {
    return Config_DeviceConfig_BuzzerMode_descriptor();
  }
  template <typename T>
  static inline const ::std::string& BuzzerMode_Name(T value) {
    return Config_DeviceConfig_BuzzerMode_Name(value);
  }
  static inline bool BuzzerMode_Parse(
      ::absl::string_view name, BuzzerMode* PROTOBUF_NONNULL value) {
    return Config_DeviceConfig_BuzzerMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kTzdefFieldNumber = 11,
    kRoleFieldNumber = 1,
    kButtonGpioFieldNumber = 4,
    kBuzzerGpioFieldNumber = 5,
    kRebroadcastModeFieldNumber = 6,
    kNodeInfoBroadcastSecsFieldNumber = 7,
    kSerialEnabledFieldNumber = 2,
    kDoubleTapAsButtonPressFieldNumber = 8,
    kIsManagedFieldNumber = 9,
    kDisableTripleClickFieldNumber = 10,
    kLedHeartbeatDisabledFieldNumber = 12,
    kBuzzerModeFieldNumber = 13,
  };
  // string tzdef = 11;
  void clear_tzdef() ;
  const ::std::string& tzdef() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_tzdef(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_tzdef();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_tzdef();
  void set_allocated_tzdef(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_tzdef() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_tzdef(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_tzdef();

  public:
  // .meshtastic.Config.DeviceConfig.Role role = 1;
  void clear_role() ;
  ::meshtastic::Config_DeviceConfig_Role role() const;
  void set_role(::meshtastic::Config_DeviceConfig_Role value);

  private:
  ::meshtastic::Config_DeviceConfig_Role _internal_role() const;
  void _internal_set_role(::meshtastic::Config_DeviceConfig_Role value);

  public:
  // uint32 button_gpio = 4;
  void clear_button_gpio() ;
  ::uint32_t button_gpio() const;
  void set_button_gpio(::uint32_t value);

  private:
  ::uint32_t _internal_button_gpio() const;
  void _internal_set_button_gpio(::uint32_t value);

  public:
  // uint32 buzzer_gpio = 5;
  void clear_buzzer_gpio() ;
  ::uint32_t buzzer_gpio() const;
  void set_buzzer_gpio(::uint32_t value);

  private:
  ::uint32_t _internal_buzzer_gpio() const;
  void _internal_set_buzzer_gpio(::uint32_t value);

  public:
  // .meshtastic.Config.DeviceConfig.RebroadcastMode rebroadcast_mode = 6;
  void clear_rebroadcast_mode() ;
  ::meshtastic::Config_DeviceConfig_RebroadcastMode rebroadcast_mode() const;
  void set_rebroadcast_mode(::meshtastic::Config_DeviceConfig_RebroadcastMode value);

  private:
  ::meshtastic::Config_DeviceConfig_RebroadcastMode _internal_rebroadcast_mode() const;
  void _internal_set_rebroadcast_mode(::meshtastic::Config_DeviceConfig_RebroadcastMode value);

  public:
  // uint32 node_info_broadcast_secs = 7;
  void clear_node_info_broadcast_secs() ;
  ::uint32_t node_info_broadcast_secs() const;
  void set_node_info_broadcast_secs(::uint32_t value);

  private:
  ::uint32_t _internal_node_info_broadcast_secs() const;
  void _internal_set_node_info_broadcast_secs(::uint32_t value);

  public:
  // bool serial_enabled = 2 [deprecated = true];
  [[deprecated]]  void clear_serial_enabled() ;
  [[deprecated]] bool serial_enabled() const;
  [[deprecated]] void set_serial_enabled(bool value);

  private:
  bool _internal_serial_enabled() const;
  void _internal_set_serial_enabled(bool value);

  public:
  // bool double_tap_as_button_press = 8;
  void clear_double_tap_as_button_press() ;
  bool double_tap_as_button_press() const;
  void set_double_tap_as_button_press(bool value);

  private:
  bool _internal_double_tap_as_button_press() const;
  void _internal_set_double_tap_as_button_press(bool value);

  public:
  // bool is_managed = 9 [deprecated = true];
  [[deprecated]]  void clear_is_managed() ;
  [[deprecated]] bool is_managed() const;
  [[deprecated]] void set_is_managed(bool value);

  private:
  bool _internal_is_managed() const;
  void _internal_set_is_managed(bool value);

  public:
  // bool disable_triple_click = 10;
  void clear_disable_triple_click() ;
  bool disable_triple_click() const;
  void set_disable_triple_click(bool value);

  private:
  bool _internal_disable_triple_click() const;
  void _internal_set_disable_triple_click(bool value);

  public:
  // bool led_heartbeat_disabled = 12;
  void clear_led_heartbeat_disabled() ;
  bool led_heartbeat_disabled() const;
  void set_led_heartbeat_disabled(bool value);

  private:
  bool _internal_led_heartbeat_disabled() const;
  void _internal_set_led_heartbeat_disabled(bool value);

  public:
  // .meshtastic.Config.DeviceConfig.BuzzerMode buzzer_mode = 13;
  void clear_buzzer_mode() ;
  ::meshtastic::Config_DeviceConfig_BuzzerMode buzzer_mode() const;
  void set_buzzer_mode(::meshtastic::Config_DeviceConfig_BuzzerMode value);

  private:
  ::meshtastic::Config_DeviceConfig_BuzzerMode _internal_buzzer_mode() const;
  void _internal_set_buzzer_mode(::meshtastic::Config_DeviceConfig_BuzzerMode value);

  public:
  // @@protoc_insertion_point(class_scope:meshtastic.Config.DeviceConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 12,
                                   0, 52,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Config_DeviceConfig& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr tzdef_;
    int role_;
    ::uint32_t button_gpio_;
    ::uint32_t buzzer_gpio_;
    int rebroadcast_mode_;
    ::uint32_t node_info_broadcast_secs_;
    bool serial_enabled_;
    bool double_tap_as_button_press_;
    bool is_managed_;
    bool disable_triple_click_;
    bool led_heartbeat_disabled_;
    int buzzer_mode_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fconfig_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Config_DeviceConfig_class_data_;
// -------------------------------------------------------------------

class Config_BluetoothConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.Config.BluetoothConfig) */ {
 public:
  inline Config_BluetoothConfig() : Config_BluetoothConfig(nullptr) {}
  ~Config_BluetoothConfig() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Config_BluetoothConfig* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Config_BluetoothConfig));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Config_BluetoothConfig(::google::protobuf::internal::ConstantInitialized);

  inline Config_BluetoothConfig(const Config_BluetoothConfig& from) : Config_BluetoothConfig(nullptr, from) {}
  inline Config_BluetoothConfig(Config_BluetoothConfig&& from) noexcept
      : Config_BluetoothConfig(nullptr, ::std::move(from)) {}
  inline Config_BluetoothConfig& operator=(const Config_BluetoothConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline Config_BluetoothConfig& operator=(Config_BluetoothConfig&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Config_BluetoothConfig& default_instance() {
    return *reinterpret_cast<const Config_BluetoothConfig*>(
        &_Config_BluetoothConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(Config_BluetoothConfig& a, Config_BluetoothConfig& b) { a.Swap(&b); }
  inline void Swap(Config_BluetoothConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Config_BluetoothConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Config_BluetoothConfig* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Config_BluetoothConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Config_BluetoothConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Config_BluetoothConfig& from) { Config_BluetoothConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Config_BluetoothConfig* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.Config.BluetoothConfig"; }

 protected:
  explicit Config_BluetoothConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Config_BluetoothConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Config_BluetoothConfig& from);
  Config_BluetoothConfig(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Config_BluetoothConfig&& from) noexcept
      : Config_BluetoothConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using PairingMode = Config_BluetoothConfig_PairingMode;
  static constexpr PairingMode RANDOM_PIN = Config_BluetoothConfig_PairingMode_RANDOM_PIN;
  static constexpr PairingMode FIXED_PIN = Config_BluetoothConfig_PairingMode_FIXED_PIN;
  static constexpr PairingMode NO_PIN = Config_BluetoothConfig_PairingMode_NO_PIN;
  static inline bool PairingMode_IsValid(int value) {
    return Config_BluetoothConfig_PairingMode_IsValid(value);
  }
  static constexpr PairingMode PairingMode_MIN = Config_BluetoothConfig_PairingMode_PairingMode_MIN;
  static constexpr PairingMode PairingMode_MAX = Config_BluetoothConfig_PairingMode_PairingMode_MAX;
  static constexpr int PairingMode_ARRAYSIZE = Config_BluetoothConfig_PairingMode_PairingMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL PairingMode_descriptor() {
    return Config_BluetoothConfig_PairingMode_descriptor();
  }
  template <typename T>
  static inline const ::std::string& PairingMode_Name(T value) {
    return Config_BluetoothConfig_PairingMode_Name(value);
  }
  static inline bool PairingMode_Parse(
      ::absl::string_view name, PairingMode* PROTOBUF_NONNULL value) {
    return Config_BluetoothConfig_PairingMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kEnabledFieldNumber = 1,
    kModeFieldNumber = 2,
    kFixedPinFieldNumber = 3,
  };
  // bool enabled = 1;
  void clear_enabled() ;
  bool enabled() const;
  void set_enabled(bool value);

  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);

  public:
  // .meshtastic.Config.BluetoothConfig.PairingMode mode = 2;
  void clear_mode() ;
  ::meshtastic::Config_BluetoothConfig_PairingMode mode() const;
  void set_mode(::meshtastic::Config_BluetoothConfig_PairingMode value);

  private:
  ::meshtastic::Config_BluetoothConfig_PairingMode _internal_mode() const;
  void _internal_set_mode(::meshtastic::Config_BluetoothConfig_PairingMode value);

  public:
  // uint32 fixed_pin = 3;
  void clear_fixed_pin() ;
  ::uint32_t fixed_pin() const;
  void set_fixed_pin(::uint32_t value);

  private:
  ::uint32_t _internal_fixed_pin() const;
  void _internal_set_fixed_pin(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:meshtastic.Config.BluetoothConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Config_BluetoothConfig& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    bool enabled_;
    int mode_;
    ::uint32_t fixed_pin_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fconfig_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Config_BluetoothConfig_class_data_;
// -------------------------------------------------------------------

class Config_NetworkConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.Config.NetworkConfig) */ {
 public:
  inline Config_NetworkConfig() : Config_NetworkConfig(nullptr) {}
  ~Config_NetworkConfig() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Config_NetworkConfig* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Config_NetworkConfig));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Config_NetworkConfig(::google::protobuf::internal::ConstantInitialized);

  inline Config_NetworkConfig(const Config_NetworkConfig& from) : Config_NetworkConfig(nullptr, from) {}
  inline Config_NetworkConfig(Config_NetworkConfig&& from) noexcept
      : Config_NetworkConfig(nullptr, ::std::move(from)) {}
  inline Config_NetworkConfig& operator=(const Config_NetworkConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline Config_NetworkConfig& operator=(Config_NetworkConfig&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Config_NetworkConfig& default_instance() {
    return *reinterpret_cast<const Config_NetworkConfig*>(
        &_Config_NetworkConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(Config_NetworkConfig& a, Config_NetworkConfig& b) { a.Swap(&b); }
  inline void Swap(Config_NetworkConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Config_NetworkConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Config_NetworkConfig* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Config_NetworkConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Config_NetworkConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Config_NetworkConfig& from) { Config_NetworkConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Config_NetworkConfig* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.Config.NetworkConfig"; }

 protected:
  explicit Config_NetworkConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Config_NetworkConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Config_NetworkConfig& from);
  Config_NetworkConfig(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Config_NetworkConfig&& from) noexcept
      : Config_NetworkConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using IpV4Config = Config_NetworkConfig_IpV4Config;
  using AddressMode = Config_NetworkConfig_AddressMode;
  static constexpr AddressMode DHCP = Config_NetworkConfig_AddressMode_DHCP;
  static constexpr AddressMode STATIC = Config_NetworkConfig_AddressMode_STATIC;
  static inline bool AddressMode_IsValid(int value) {
    return Config_NetworkConfig_AddressMode_IsValid(value);
  }
  static constexpr AddressMode AddressMode_MIN = Config_NetworkConfig_AddressMode_AddressMode_MIN;
  static constexpr AddressMode AddressMode_MAX = Config_NetworkConfig_AddressMode_AddressMode_MAX;
  static constexpr int AddressMode_ARRAYSIZE = Config_NetworkConfig_AddressMode_AddressMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL AddressMode_descriptor() {
    return Config_NetworkConfig_AddressMode_descriptor();
  }
  template <typename T>
  static inline const ::std::string& AddressMode_Name(T value) {
    return Config_NetworkConfig_AddressMode_Name(value);
  }
  static inline bool AddressMode_Parse(
      ::absl::string_view name, AddressMode* PROTOBUF_NONNULL value) {
    return Config_NetworkConfig_AddressMode_Parse(name, value);
  }
  using ProtocolFlags = Config_NetworkConfig_ProtocolFlags;
  static constexpr ProtocolFlags NO_BROADCAST = Config_NetworkConfig_ProtocolFlags_NO_BROADCAST;
  static constexpr ProtocolFlags UDP_BROADCAST = Config_NetworkConfig_ProtocolFlags_UDP_BROADCAST;
  static inline bool ProtocolFlags_IsValid(int value) {
    return Config_NetworkConfig_ProtocolFlags_IsValid(value);
  }
  static constexpr ProtocolFlags ProtocolFlags_MIN = Config_NetworkConfig_ProtocolFlags_ProtocolFlags_MIN;
  static constexpr ProtocolFlags ProtocolFlags_MAX = Config_NetworkConfig_ProtocolFlags_ProtocolFlags_MAX;
  static constexpr int ProtocolFlags_ARRAYSIZE = Config_NetworkConfig_ProtocolFlags_ProtocolFlags_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ProtocolFlags_descriptor() {
    return Config_NetworkConfig_ProtocolFlags_descriptor();
  }
  template <typename T>
  static inline const ::std::string& ProtocolFlags_Name(T value) {
    return Config_NetworkConfig_ProtocolFlags_Name(value);
  }
  static inline bool ProtocolFlags_Parse(
      ::absl::string_view name, ProtocolFlags* PROTOBUF_NONNULL value) {
    return Config_NetworkConfig_ProtocolFlags_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kWifiSsidFieldNumber = 3,
    kWifiPskFieldNumber = 4,
    kNtpServerFieldNumber = 5,
    kRsyslogServerFieldNumber = 9,
    kIpv4ConfigFieldNumber = 8,
    kWifiEnabledFieldNumber = 1,
    kEthEnabledFieldNumber = 6,
    kIpv6EnabledFieldNumber = 11,
    kAddressModeFieldNumber = 7,
    kEnabledProtocolsFieldNumber = 10,
  };
  // string wifi_ssid = 3;
  void clear_wifi_ssid() ;
  const ::std::string& wifi_ssid() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_wifi_ssid(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_wifi_ssid();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_wifi_ssid();
  void set_allocated_wifi_ssid(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_wifi_ssid() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_wifi_ssid(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_wifi_ssid();

  public:
  // string wifi_psk = 4;
  void clear_wifi_psk() ;
  const ::std::string& wifi_psk() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_wifi_psk(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_wifi_psk();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_wifi_psk();
  void set_allocated_wifi_psk(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_wifi_psk() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_wifi_psk(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_wifi_psk();

  public:
  // string ntp_server = 5;
  void clear_ntp_server() ;
  const ::std::string& ntp_server() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_ntp_server(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_ntp_server();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_ntp_server();
  void set_allocated_ntp_server(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_ntp_server() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_ntp_server(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_ntp_server();

  public:
  // string rsyslog_server = 9;
  void clear_rsyslog_server() ;
  const ::std::string& rsyslog_server() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_rsyslog_server(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_rsyslog_server();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_rsyslog_server();
  void set_allocated_rsyslog_server(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_rsyslog_server() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_rsyslog_server(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_rsyslog_server();

  public:
  // .meshtastic.Config.NetworkConfig.IpV4Config ipv4_config = 8;
  bool has_ipv4_config() const;
  void clear_ipv4_config() ;
  const ::meshtastic::Config_NetworkConfig_IpV4Config& ipv4_config() const;
  [[nodiscard]] ::meshtastic::Config_NetworkConfig_IpV4Config* PROTOBUF_NULLABLE release_ipv4_config();
  ::meshtastic::Config_NetworkConfig_IpV4Config* PROTOBUF_NONNULL mutable_ipv4_config();
  void set_allocated_ipv4_config(::meshtastic::Config_NetworkConfig_IpV4Config* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_ipv4_config(::meshtastic::Config_NetworkConfig_IpV4Config* PROTOBUF_NULLABLE value);
  ::meshtastic::Config_NetworkConfig_IpV4Config* PROTOBUF_NULLABLE unsafe_arena_release_ipv4_config();

  private:
  const ::meshtastic::Config_NetworkConfig_IpV4Config& _internal_ipv4_config() const;
  ::meshtastic::Config_NetworkConfig_IpV4Config* PROTOBUF_NONNULL _internal_mutable_ipv4_config();

  public:
  // bool wifi_enabled = 1;
  void clear_wifi_enabled() ;
  bool wifi_enabled() const;
  void set_wifi_enabled(bool value);

  private:
  bool _internal_wifi_enabled() const;
  void _internal_set_wifi_enabled(bool value);

  public:
  // bool eth_enabled = 6;
  void clear_eth_enabled() ;
  bool eth_enabled() const;
  void set_eth_enabled(bool value);

  private:
  bool _internal_eth_enabled() const;
  void _internal_set_eth_enabled(bool value);

  public:
  // bool ipv6_enabled = 11;
  void clear_ipv6_enabled() ;
  bool ipv6_enabled() const;
  void set_ipv6_enabled(bool value);

  private:
  bool _internal_ipv6_enabled() const;
  void _internal_set_ipv6_enabled(bool value);

  public:
  // .meshtastic.Config.NetworkConfig.AddressMode address_mode = 7;
  void clear_address_mode() ;
  ::meshtastic::Config_NetworkConfig_AddressMode address_mode() const;
  void set_address_mode(::meshtastic::Config_NetworkConfig_AddressMode value);

  private:
  ::meshtastic::Config_NetworkConfig_AddressMode _internal_address_mode() const;
  void _internal_set_address_mode(::meshtastic::Config_NetworkConfig_AddressMode value);

  public:
  // uint32 enabled_protocols = 10;
  void clear_enabled_protocols() ;
  ::uint32_t enabled_protocols() const;
  void set_enabled_protocols(::uint32_t value);

  private:
  ::uint32_t _internal_enabled_protocols() const;
  void _internal_set_enabled_protocols(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:meshtastic.Config.NetworkConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 10,
                                   1, 89,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Config_NetworkConfig& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr wifi_ssid_;
    ::google::protobuf::internal::ArenaStringPtr wifi_psk_;
    ::google::protobuf::internal::ArenaStringPtr ntp_server_;
    ::google::protobuf::internal::ArenaStringPtr rsyslog_server_;
    ::meshtastic::Config_NetworkConfig_IpV4Config* PROTOBUF_NULLABLE ipv4_config_;
    bool wifi_enabled_;
    bool eth_enabled_;
    bool ipv6_enabled_;
    int address_mode_;
    ::uint32_t enabled_protocols_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fconfig_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Config_NetworkConfig_class_data_;
// -------------------------------------------------------------------

class Config final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.Config) */ {
 public:
  inline Config() : Config(nullptr) {}
  ~Config() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Config* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Config));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Config(::google::protobuf::internal::ConstantInitialized);

  inline Config(const Config& from) : Config(nullptr, from) {}
  inline Config(Config&& from) noexcept
      : Config(nullptr, ::std::move(from)) {}
  inline Config& operator=(const Config& from) {
    CopyFrom(from);
    return *this;
  }
  inline Config& operator=(Config&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Config& default_instance() {
    return *reinterpret_cast<const Config*>(
        &_Config_default_instance_);
  }
  enum PayloadVariantCase {
    kDevice = 1,
    kPosition = 2,
    kPower = 3,
    kNetwork = 4,
    kDisplay = 5,
    kLora = 6,
    kBluetooth = 7,
    kSecurity = 8,
    kSessionkey = 9,
    kDeviceUi = 10,
    PAYLOAD_VARIANT_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(Config& a, Config& b) { a.Swap(&b); }
  inline void Swap(Config* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Config* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Config* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Config>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Config& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Config& from) { Config::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Config* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.Config"; }

 protected:
  explicit Config(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Config(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Config& from);
  Config(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Config&& from) noexcept
      : Config(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using DeviceConfig = Config_DeviceConfig;
  using PositionConfig = Config_PositionConfig;
  using PowerConfig = Config_PowerConfig;
  using NetworkConfig = Config_NetworkConfig;
  using DisplayConfig = Config_DisplayConfig;
  using LoRaConfig = Config_LoRaConfig;
  using BluetoothConfig = Config_BluetoothConfig;
  using SecurityConfig = Config_SecurityConfig;
  using SessionkeyConfig = Config_SessionkeyConfig;

  // accessors -------------------------------------------------------
  enum : int {
    kDeviceFieldNumber = 1,
    kPositionFieldNumber = 2,
    kPowerFieldNumber = 3,
    kNetworkFieldNumber = 4,
    kDisplayFieldNumber = 5,
    kLoraFieldNumber = 6,
    kBluetoothFieldNumber = 7,
    kSecurityFieldNumber = 8,
    kSessionkeyFieldNumber = 9,
    kDeviceUiFieldNumber = 10,
  };
  // .meshtastic.Config.DeviceConfig device = 1;
  bool has_device() const;
  private:
  bool _internal_has_device() const;

  public:
  void clear_device() ;
  const ::meshtastic::Config_DeviceConfig& device() const;
  [[nodiscard]] ::meshtastic::Config_DeviceConfig* PROTOBUF_NULLABLE release_device();
  ::meshtastic::Config_DeviceConfig* PROTOBUF_NONNULL mutable_device();
  void set_allocated_device(::meshtastic::Config_DeviceConfig* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_device(::meshtastic::Config_DeviceConfig* PROTOBUF_NULLABLE value);
  ::meshtastic::Config_DeviceConfig* PROTOBUF_NULLABLE unsafe_arena_release_device();

  private:
  const ::meshtastic::Config_DeviceConfig& _internal_device() const;
  ::meshtastic::Config_DeviceConfig* PROTOBUF_NONNULL _internal_mutable_device();

  public:
  // .meshtastic.Config.PositionConfig position = 2;
  bool has_position() const;
  private:
  bool _internal_has_position() const;

  public:
  void clear_position() ;
  const ::meshtastic::Config_PositionConfig& position() const;
  [[nodiscard]] ::meshtastic::Config_PositionConfig* PROTOBUF_NULLABLE release_position();
  ::meshtastic::Config_PositionConfig* PROTOBUF_NONNULL mutable_position();
  void set_allocated_position(::meshtastic::Config_PositionConfig* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_position(::meshtastic::Config_PositionConfig* PROTOBUF_NULLABLE value);
  ::meshtastic::Config_PositionConfig* PROTOBUF_NULLABLE unsafe_arena_release_position();

  private:
  const ::meshtastic::Config_PositionConfig& _internal_position() const;
  ::meshtastic::Config_PositionConfig* PROTOBUF_NONNULL _internal_mutable_position();

  public:
  // .meshtastic.Config.PowerConfig power = 3;
  bool has_power() const;
  private:
  bool _internal_has_power() const;

  public:
  void clear_power() ;
  const ::meshtastic::Config_PowerConfig& power() const;
  [[nodiscard]] ::meshtastic::Config_PowerConfig* PROTOBUF_NULLABLE release_power();
  ::meshtastic::Config_PowerConfig* PROTOBUF_NONNULL mutable_power();
  void set_allocated_power(::meshtastic::Config_PowerConfig* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_power(::meshtastic::Config_PowerConfig* PROTOBUF_NULLABLE value);
  ::meshtastic::Config_PowerConfig* PROTOBUF_NULLABLE unsafe_arena_release_power();

  private:
  const ::meshtastic::Config_PowerConfig& _internal_power() const;
  ::meshtastic::Config_PowerConfig* PROTOBUF_NONNULL _internal_mutable_power();

  public:
  // .meshtastic.Config.NetworkConfig network = 4;
  bool has_network() const;
  private:
  bool _internal_has_network() const;

  public:
  void clear_network() ;
  const ::meshtastic::Config_NetworkConfig& network() const;
  [[nodiscard]] ::meshtastic::Config_NetworkConfig* PROTOBUF_NULLABLE release_network();
  ::meshtastic::Config_NetworkConfig* PROTOBUF_NONNULL mutable_network();
  void set_allocated_network(::meshtastic::Config_NetworkConfig* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_network(::meshtastic::Config_NetworkConfig* PROTOBUF_NULLABLE value);
  ::meshtastic::Config_NetworkConfig* PROTOBUF_NULLABLE unsafe_arena_release_network();

  private:
  const ::meshtastic::Config_NetworkConfig& _internal_network() const;
  ::meshtastic::Config_NetworkConfig* PROTOBUF_NONNULL _internal_mutable_network();

  public:
  // .meshtastic.Config.DisplayConfig display = 5;
  bool has_display() const;
  private:
  bool _internal_has_display() const;

  public:
  void clear_display() ;
  const ::meshtastic::Config_DisplayConfig& display() const;
  [[nodiscard]] ::meshtastic::Config_DisplayConfig* PROTOBUF_NULLABLE release_display();
  ::meshtastic::Config_DisplayConfig* PROTOBUF_NONNULL mutable_display();
  void set_allocated_display(::meshtastic::Config_DisplayConfig* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_display(::meshtastic::Config_DisplayConfig* PROTOBUF_NULLABLE value);
  ::meshtastic::Config_DisplayConfig* PROTOBUF_NULLABLE unsafe_arena_release_display();

  private:
  const ::meshtastic::Config_DisplayConfig& _internal_display() const;
  ::meshtastic::Config_DisplayConfig* PROTOBUF_NONNULL _internal_mutable_display();

  public:
  // .meshtastic.Config.LoRaConfig lora = 6;
  bool has_lora() const;
  private:
  bool _internal_has_lora() const;

  public:
  void clear_lora() ;
  const ::meshtastic::Config_LoRaConfig& lora() const;
  [[nodiscard]] ::meshtastic::Config_LoRaConfig* PROTOBUF_NULLABLE release_lora();
  ::meshtastic::Config_LoRaConfig* PROTOBUF_NONNULL mutable_lora();
  void set_allocated_lora(::meshtastic::Config_LoRaConfig* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_lora(::meshtastic::Config_LoRaConfig* PROTOBUF_NULLABLE value);
  ::meshtastic::Config_LoRaConfig* PROTOBUF_NULLABLE unsafe_arena_release_lora();

  private:
  const ::meshtastic::Config_LoRaConfig& _internal_lora() const;
  ::meshtastic::Config_LoRaConfig* PROTOBUF_NONNULL _internal_mutable_lora();

  public:
  // .meshtastic.Config.BluetoothConfig bluetooth = 7;
  bool has_bluetooth() const;
  private:
  bool _internal_has_bluetooth() const;

  public:
  void clear_bluetooth() ;
  const ::meshtastic::Config_BluetoothConfig& bluetooth() const;
  [[nodiscard]] ::meshtastic::Config_BluetoothConfig* PROTOBUF_NULLABLE release_bluetooth();
  ::meshtastic::Config_BluetoothConfig* PROTOBUF_NONNULL mutable_bluetooth();
  void set_allocated_bluetooth(::meshtastic::Config_BluetoothConfig* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_bluetooth(::meshtastic::Config_BluetoothConfig* PROTOBUF_NULLABLE value);
  ::meshtastic::Config_BluetoothConfig* PROTOBUF_NULLABLE unsafe_arena_release_bluetooth();

  private:
  const ::meshtastic::Config_BluetoothConfig& _internal_bluetooth() const;
  ::meshtastic::Config_BluetoothConfig* PROTOBUF_NONNULL _internal_mutable_bluetooth();

  public:
  // .meshtastic.Config.SecurityConfig security = 8;
  bool has_security() const;
  private:
  bool _internal_has_security() const;

  public:
  void clear_security() ;
  const ::meshtastic::Config_SecurityConfig& security() const;
  [[nodiscard]] ::meshtastic::Config_SecurityConfig* PROTOBUF_NULLABLE release_security();
  ::meshtastic::Config_SecurityConfig* PROTOBUF_NONNULL mutable_security();
  void set_allocated_security(::meshtastic::Config_SecurityConfig* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_security(::meshtastic::Config_SecurityConfig* PROTOBUF_NULLABLE value);
  ::meshtastic::Config_SecurityConfig* PROTOBUF_NULLABLE unsafe_arena_release_security();

  private:
  const ::meshtastic::Config_SecurityConfig& _internal_security() const;
  ::meshtastic::Config_SecurityConfig* PROTOBUF_NONNULL _internal_mutable_security();

  public:
  // .meshtastic.Config.SessionkeyConfig sessionkey = 9;
  bool has_sessionkey() const;
  private:
  bool _internal_has_sessionkey() const;

  public:
  void clear_sessionkey() ;
  const ::meshtastic::Config_SessionkeyConfig& sessionkey() const;
  [[nodiscard]] ::meshtastic::Config_SessionkeyConfig* PROTOBUF_NULLABLE release_sessionkey();
  ::meshtastic::Config_SessionkeyConfig* PROTOBUF_NONNULL mutable_sessionkey();
  void set_allocated_sessionkey(::meshtastic::Config_SessionkeyConfig* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_sessionkey(::meshtastic::Config_SessionkeyConfig* PROTOBUF_NULLABLE value);
  ::meshtastic::Config_SessionkeyConfig* PROTOBUF_NULLABLE unsafe_arena_release_sessionkey();

  private:
  const ::meshtastic::Config_SessionkeyConfig& _internal_sessionkey() const;
  ::meshtastic::Config_SessionkeyConfig* PROTOBUF_NONNULL _internal_mutable_sessionkey();

  public:
  // .meshtastic.DeviceUIConfig device_ui = 10;
  bool has_device_ui() const;
  private:
  bool _internal_has_device_ui() const;

  public:
  void clear_device_ui() ;
  const ::meshtastic::DeviceUIConfig& device_ui() const;
  [[nodiscard]] ::meshtastic::DeviceUIConfig* PROTOBUF_NULLABLE release_device_ui();
  ::meshtastic::DeviceUIConfig* PROTOBUF_NONNULL mutable_device_ui();
  void set_allocated_device_ui(::meshtastic::DeviceUIConfig* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_device_ui(::meshtastic::DeviceUIConfig* PROTOBUF_NULLABLE value);
  ::meshtastic::DeviceUIConfig* PROTOBUF_NULLABLE unsafe_arena_release_device_ui();

  private:
  const ::meshtastic::DeviceUIConfig& _internal_device_ui() const;
  ::meshtastic::DeviceUIConfig* PROTOBUF_NONNULL _internal_mutable_device_ui();

  public:
  void clear_payload_variant();
  PayloadVariantCase payload_variant_case() const;
  // @@protoc_insertion_point(class_scope:meshtastic.Config)
 private:
  class _Internal;
  void set_has_device();
  void set_has_position();
  void set_has_power();
  void set_has_network();
  void set_has_display();
  void set_has_lora();
  void set_has_bluetooth();
  void set_has_security();
  void set_has_sessionkey();
  void set_has_device_ui();
  inline bool has_payload_variant() const;
  inline void clear_has_payload_variant();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 10,
                                   10, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Config& from_msg);
    union PayloadVariantUnion {
      constexpr PayloadVariantUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE device_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE position_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE power_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE network_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE display_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE lora_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE bluetooth_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE security_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE sessionkey_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE device_ui_;
    } payload_variant_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fconfig_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Config_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Config_DeviceConfig

// .meshtastic.Config.DeviceConfig.Role role = 1;
inline void Config_DeviceConfig::clear_role() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.role_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::meshtastic::Config_DeviceConfig_Role Config_DeviceConfig::role() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.DeviceConfig.role)
  return _internal_role();
}
inline void Config_DeviceConfig::set_role(::meshtastic::Config_DeviceConfig_Role value) {
  _internal_set_role(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.DeviceConfig.role)
}
inline ::meshtastic::Config_DeviceConfig_Role Config_DeviceConfig::_internal_role() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::meshtastic::Config_DeviceConfig_Role>(_impl_.role_);
}
inline void Config_DeviceConfig::_internal_set_role(::meshtastic::Config_DeviceConfig_Role value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.role_ = value;
}

// bool serial_enabled = 2 [deprecated = true];
inline void Config_DeviceConfig::clear_serial_enabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.serial_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool Config_DeviceConfig::serial_enabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.DeviceConfig.serial_enabled)
  return _internal_serial_enabled();
}
inline void Config_DeviceConfig::set_serial_enabled(bool value) {
  _internal_set_serial_enabled(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.DeviceConfig.serial_enabled)
}
inline bool Config_DeviceConfig::_internal_serial_enabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.serial_enabled_;
}
inline void Config_DeviceConfig::_internal_set_serial_enabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.serial_enabled_ = value;
}

// uint32 button_gpio = 4;
inline void Config_DeviceConfig::clear_button_gpio() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.button_gpio_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t Config_DeviceConfig::button_gpio() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.DeviceConfig.button_gpio)
  return _internal_button_gpio();
}
inline void Config_DeviceConfig::set_button_gpio(::uint32_t value) {
  _internal_set_button_gpio(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.DeviceConfig.button_gpio)
}
inline ::uint32_t Config_DeviceConfig::_internal_button_gpio() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.button_gpio_;
}
inline void Config_DeviceConfig::_internal_set_button_gpio(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.button_gpio_ = value;
}

// uint32 buzzer_gpio = 5;
inline void Config_DeviceConfig::clear_buzzer_gpio() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.buzzer_gpio_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t Config_DeviceConfig::buzzer_gpio() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.DeviceConfig.buzzer_gpio)
  return _internal_buzzer_gpio();
}
inline void Config_DeviceConfig::set_buzzer_gpio(::uint32_t value) {
  _internal_set_buzzer_gpio(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.DeviceConfig.buzzer_gpio)
}
inline ::uint32_t Config_DeviceConfig::_internal_buzzer_gpio() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.buzzer_gpio_;
}
inline void Config_DeviceConfig::_internal_set_buzzer_gpio(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.buzzer_gpio_ = value;
}

// .meshtastic.Config.DeviceConfig.RebroadcastMode rebroadcast_mode = 6;
inline void Config_DeviceConfig::clear_rebroadcast_mode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rebroadcast_mode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::meshtastic::Config_DeviceConfig_RebroadcastMode Config_DeviceConfig::rebroadcast_mode() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.DeviceConfig.rebroadcast_mode)
  return _internal_rebroadcast_mode();
}
inline void Config_DeviceConfig::set_rebroadcast_mode(::meshtastic::Config_DeviceConfig_RebroadcastMode value) {
  _internal_set_rebroadcast_mode(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.DeviceConfig.rebroadcast_mode)
}
inline ::meshtastic::Config_DeviceConfig_RebroadcastMode Config_DeviceConfig::_internal_rebroadcast_mode() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::meshtastic::Config_DeviceConfig_RebroadcastMode>(_impl_.rebroadcast_mode_);
}
inline void Config_DeviceConfig::_internal_set_rebroadcast_mode(::meshtastic::Config_DeviceConfig_RebroadcastMode value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rebroadcast_mode_ = value;
}

// uint32 node_info_broadcast_secs = 7;
inline void Config_DeviceConfig::clear_node_info_broadcast_secs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.node_info_broadcast_secs_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint32_t Config_DeviceConfig::node_info_broadcast_secs() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.DeviceConfig.node_info_broadcast_secs)
  return _internal_node_info_broadcast_secs();
}
inline void Config_DeviceConfig::set_node_info_broadcast_secs(::uint32_t value) {
  _internal_set_node_info_broadcast_secs(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.DeviceConfig.node_info_broadcast_secs)
}
inline ::uint32_t Config_DeviceConfig::_internal_node_info_broadcast_secs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.node_info_broadcast_secs_;
}
inline void Config_DeviceConfig::_internal_set_node_info_broadcast_secs(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.node_info_broadcast_secs_ = value;
}

// bool double_tap_as_button_press = 8;
inline void Config_DeviceConfig::clear_double_tap_as_button_press() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.double_tap_as_button_press_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool Config_DeviceConfig::double_tap_as_button_press() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.DeviceConfig.double_tap_as_button_press)
  return _internal_double_tap_as_button_press();
}
inline void Config_DeviceConfig::set_double_tap_as_button_press(bool value) {
  _internal_set_double_tap_as_button_press(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.DeviceConfig.double_tap_as_button_press)
}
inline bool Config_DeviceConfig::_internal_double_tap_as_button_press() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.double_tap_as_button_press_;
}
inline void Config_DeviceConfig::_internal_set_double_tap_as_button_press(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.double_tap_as_button_press_ = value;
}

// bool is_managed = 9 [deprecated = true];
inline void Config_DeviceConfig::clear_is_managed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_managed_ = false;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool Config_DeviceConfig::is_managed() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.DeviceConfig.is_managed)
  return _internal_is_managed();
}
inline void Config_DeviceConfig::set_is_managed(bool value) {
  _internal_set_is_managed(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.DeviceConfig.is_managed)
}
inline bool Config_DeviceConfig::_internal_is_managed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_managed_;
}
inline void Config_DeviceConfig::_internal_set_is_managed(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_managed_ = value;
}

// bool disable_triple_click = 10;
inline void Config_DeviceConfig::clear_disable_triple_click() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.disable_triple_click_ = false;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline bool Config_DeviceConfig::disable_triple_click() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.DeviceConfig.disable_triple_click)
  return _internal_disable_triple_click();
}
inline void Config_DeviceConfig::set_disable_triple_click(bool value) {
  _internal_set_disable_triple_click(value);
  _impl_._has_bits_[0] |= 0x00000200u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.DeviceConfig.disable_triple_click)
}
inline bool Config_DeviceConfig::_internal_disable_triple_click() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.disable_triple_click_;
}
inline void Config_DeviceConfig::_internal_set_disable_triple_click(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.disable_triple_click_ = value;
}

// string tzdef = 11;
inline void Config_DeviceConfig::clear_tzdef() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tzdef_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& Config_DeviceConfig::tzdef() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.Config.DeviceConfig.tzdef)
  return _internal_tzdef();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Config_DeviceConfig::set_tzdef(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.tzdef_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:meshtastic.Config.DeviceConfig.tzdef)
}
inline ::std::string* PROTOBUF_NONNULL Config_DeviceConfig::mutable_tzdef()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_tzdef();
  // @@protoc_insertion_point(field_mutable:meshtastic.Config.DeviceConfig.tzdef)
  return _s;
}
inline const ::std::string& Config_DeviceConfig::_internal_tzdef() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tzdef_.Get();
}
inline void Config_DeviceConfig::_internal_set_tzdef(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.tzdef_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Config_DeviceConfig::_internal_mutable_tzdef() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.tzdef_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Config_DeviceConfig::release_tzdef() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.Config.DeviceConfig.tzdef)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.tzdef_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.tzdef_.Set("", GetArena());
  }
  return released;
}
inline void Config_DeviceConfig::set_allocated_tzdef(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.tzdef_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.tzdef_.IsDefault()) {
    _impl_.tzdef_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.Config.DeviceConfig.tzdef)
}

// bool led_heartbeat_disabled = 12;
inline void Config_DeviceConfig::clear_led_heartbeat_disabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.led_heartbeat_disabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline bool Config_DeviceConfig::led_heartbeat_disabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.DeviceConfig.led_heartbeat_disabled)
  return _internal_led_heartbeat_disabled();
}
inline void Config_DeviceConfig::set_led_heartbeat_disabled(bool value) {
  _internal_set_led_heartbeat_disabled(value);
  _impl_._has_bits_[0] |= 0x00000400u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.DeviceConfig.led_heartbeat_disabled)
}
inline bool Config_DeviceConfig::_internal_led_heartbeat_disabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.led_heartbeat_disabled_;
}
inline void Config_DeviceConfig::_internal_set_led_heartbeat_disabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.led_heartbeat_disabled_ = value;
}

// .meshtastic.Config.DeviceConfig.BuzzerMode buzzer_mode = 13;
inline void Config_DeviceConfig::clear_buzzer_mode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.buzzer_mode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::meshtastic::Config_DeviceConfig_BuzzerMode Config_DeviceConfig::buzzer_mode() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.DeviceConfig.buzzer_mode)
  return _internal_buzzer_mode();
}
inline void Config_DeviceConfig::set_buzzer_mode(::meshtastic::Config_DeviceConfig_BuzzerMode value) {
  _internal_set_buzzer_mode(value);
  _impl_._has_bits_[0] |= 0x00000800u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.DeviceConfig.buzzer_mode)
}
inline ::meshtastic::Config_DeviceConfig_BuzzerMode Config_DeviceConfig::_internal_buzzer_mode() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::meshtastic::Config_DeviceConfig_BuzzerMode>(_impl_.buzzer_mode_);
}
inline void Config_DeviceConfig::_internal_set_buzzer_mode(::meshtastic::Config_DeviceConfig_BuzzerMode value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.buzzer_mode_ = value;
}

// -------------------------------------------------------------------

// Config_PositionConfig

// uint32 position_broadcast_secs = 1;
inline void Config_PositionConfig::clear_position_broadcast_secs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.position_broadcast_secs_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t Config_PositionConfig::position_broadcast_secs() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.PositionConfig.position_broadcast_secs)
  return _internal_position_broadcast_secs();
}
inline void Config_PositionConfig::set_position_broadcast_secs(::uint32_t value) {
  _internal_set_position_broadcast_secs(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.PositionConfig.position_broadcast_secs)
}
inline ::uint32_t Config_PositionConfig::_internal_position_broadcast_secs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.position_broadcast_secs_;
}
inline void Config_PositionConfig::_internal_set_position_broadcast_secs(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.position_broadcast_secs_ = value;
}

// bool position_broadcast_smart_enabled = 2;
inline void Config_PositionConfig::clear_position_broadcast_smart_enabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.position_broadcast_smart_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool Config_PositionConfig::position_broadcast_smart_enabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.PositionConfig.position_broadcast_smart_enabled)
  return _internal_position_broadcast_smart_enabled();
}
inline void Config_PositionConfig::set_position_broadcast_smart_enabled(bool value) {
  _internal_set_position_broadcast_smart_enabled(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.PositionConfig.position_broadcast_smart_enabled)
}
inline bool Config_PositionConfig::_internal_position_broadcast_smart_enabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.position_broadcast_smart_enabled_;
}
inline void Config_PositionConfig::_internal_set_position_broadcast_smart_enabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.position_broadcast_smart_enabled_ = value;
}

// bool fixed_position = 3;
inline void Config_PositionConfig::clear_fixed_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fixed_position_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool Config_PositionConfig::fixed_position() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.PositionConfig.fixed_position)
  return _internal_fixed_position();
}
inline void Config_PositionConfig::set_fixed_position(bool value) {
  _internal_set_fixed_position(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.PositionConfig.fixed_position)
}
inline bool Config_PositionConfig::_internal_fixed_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fixed_position_;
}
inline void Config_PositionConfig::_internal_set_fixed_position(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fixed_position_ = value;
}

// bool gps_enabled = 4 [deprecated = true];
inline void Config_PositionConfig::clear_gps_enabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gps_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool Config_PositionConfig::gps_enabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.PositionConfig.gps_enabled)
  return _internal_gps_enabled();
}
inline void Config_PositionConfig::set_gps_enabled(bool value) {
  _internal_set_gps_enabled(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.PositionConfig.gps_enabled)
}
inline bool Config_PositionConfig::_internal_gps_enabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gps_enabled_;
}
inline void Config_PositionConfig::_internal_set_gps_enabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gps_enabled_ = value;
}

// uint32 gps_update_interval = 5;
inline void Config_PositionConfig::clear_gps_update_interval() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gps_update_interval_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t Config_PositionConfig::gps_update_interval() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.PositionConfig.gps_update_interval)
  return _internal_gps_update_interval();
}
inline void Config_PositionConfig::set_gps_update_interval(::uint32_t value) {
  _internal_set_gps_update_interval(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.PositionConfig.gps_update_interval)
}
inline ::uint32_t Config_PositionConfig::_internal_gps_update_interval() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gps_update_interval_;
}
inline void Config_PositionConfig::_internal_set_gps_update_interval(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gps_update_interval_ = value;
}

// uint32 gps_attempt_time = 6 [deprecated = true];
inline void Config_PositionConfig::clear_gps_attempt_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gps_attempt_time_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint32_t Config_PositionConfig::gps_attempt_time() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.PositionConfig.gps_attempt_time)
  return _internal_gps_attempt_time();
}
inline void Config_PositionConfig::set_gps_attempt_time(::uint32_t value) {
  _internal_set_gps_attempt_time(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.PositionConfig.gps_attempt_time)
}
inline ::uint32_t Config_PositionConfig::_internal_gps_attempt_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gps_attempt_time_;
}
inline void Config_PositionConfig::_internal_set_gps_attempt_time(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gps_attempt_time_ = value;
}

// uint32 position_flags = 7;
inline void Config_PositionConfig::clear_position_flags() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.position_flags_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint32_t Config_PositionConfig::position_flags() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.PositionConfig.position_flags)
  return _internal_position_flags();
}
inline void Config_PositionConfig::set_position_flags(::uint32_t value) {
  _internal_set_position_flags(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.PositionConfig.position_flags)
}
inline ::uint32_t Config_PositionConfig::_internal_position_flags() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.position_flags_;
}
inline void Config_PositionConfig::_internal_set_position_flags(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.position_flags_ = value;
}

// uint32 rx_gpio = 8;
inline void Config_PositionConfig::clear_rx_gpio() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rx_gpio_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::uint32_t Config_PositionConfig::rx_gpio() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.PositionConfig.rx_gpio)
  return _internal_rx_gpio();
}
inline void Config_PositionConfig::set_rx_gpio(::uint32_t value) {
  _internal_set_rx_gpio(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.PositionConfig.rx_gpio)
}
inline ::uint32_t Config_PositionConfig::_internal_rx_gpio() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.rx_gpio_;
}
inline void Config_PositionConfig::_internal_set_rx_gpio(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rx_gpio_ = value;
}

// uint32 tx_gpio = 9;
inline void Config_PositionConfig::clear_tx_gpio() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tx_gpio_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::uint32_t Config_PositionConfig::tx_gpio() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.PositionConfig.tx_gpio)
  return _internal_tx_gpio();
}
inline void Config_PositionConfig::set_tx_gpio(::uint32_t value) {
  _internal_set_tx_gpio(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.PositionConfig.tx_gpio)
}
inline ::uint32_t Config_PositionConfig::_internal_tx_gpio() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tx_gpio_;
}
inline void Config_PositionConfig::_internal_set_tx_gpio(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tx_gpio_ = value;
}

// uint32 broadcast_smart_minimum_distance = 10;
inline void Config_PositionConfig::clear_broadcast_smart_minimum_distance() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.broadcast_smart_minimum_distance_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::uint32_t Config_PositionConfig::broadcast_smart_minimum_distance() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.PositionConfig.broadcast_smart_minimum_distance)
  return _internal_broadcast_smart_minimum_distance();
}
inline void Config_PositionConfig::set_broadcast_smart_minimum_distance(::uint32_t value) {
  _internal_set_broadcast_smart_minimum_distance(value);
  _impl_._has_bits_[0] |= 0x00000200u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.PositionConfig.broadcast_smart_minimum_distance)
}
inline ::uint32_t Config_PositionConfig::_internal_broadcast_smart_minimum_distance() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.broadcast_smart_minimum_distance_;
}
inline void Config_PositionConfig::_internal_set_broadcast_smart_minimum_distance(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.broadcast_smart_minimum_distance_ = value;
}

// uint32 broadcast_smart_minimum_interval_secs = 11;
inline void Config_PositionConfig::clear_broadcast_smart_minimum_interval_secs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.broadcast_smart_minimum_interval_secs_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::uint32_t Config_PositionConfig::broadcast_smart_minimum_interval_secs() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.PositionConfig.broadcast_smart_minimum_interval_secs)
  return _internal_broadcast_smart_minimum_interval_secs();
}
inline void Config_PositionConfig::set_broadcast_smart_minimum_interval_secs(::uint32_t value) {
  _internal_set_broadcast_smart_minimum_interval_secs(value);
  _impl_._has_bits_[0] |= 0x00000400u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.PositionConfig.broadcast_smart_minimum_interval_secs)
}
inline ::uint32_t Config_PositionConfig::_internal_broadcast_smart_minimum_interval_secs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.broadcast_smart_minimum_interval_secs_;
}
inline void Config_PositionConfig::_internal_set_broadcast_smart_minimum_interval_secs(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.broadcast_smart_minimum_interval_secs_ = value;
}

// uint32 gps_en_gpio = 12;
inline void Config_PositionConfig::clear_gps_en_gpio() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gps_en_gpio_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::uint32_t Config_PositionConfig::gps_en_gpio() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.PositionConfig.gps_en_gpio)
  return _internal_gps_en_gpio();
}
inline void Config_PositionConfig::set_gps_en_gpio(::uint32_t value) {
  _internal_set_gps_en_gpio(value);
  _impl_._has_bits_[0] |= 0x00000800u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.PositionConfig.gps_en_gpio)
}
inline ::uint32_t Config_PositionConfig::_internal_gps_en_gpio() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gps_en_gpio_;
}
inline void Config_PositionConfig::_internal_set_gps_en_gpio(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gps_en_gpio_ = value;
}

// .meshtastic.Config.PositionConfig.GpsMode gps_mode = 13;
inline void Config_PositionConfig::clear_gps_mode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gps_mode_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline ::meshtastic::Config_PositionConfig_GpsMode Config_PositionConfig::gps_mode() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.PositionConfig.gps_mode)
  return _internal_gps_mode();
}
inline void Config_PositionConfig::set_gps_mode(::meshtastic::Config_PositionConfig_GpsMode value) {
  _internal_set_gps_mode(value);
  _impl_._has_bits_[0] |= 0x00001000u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.PositionConfig.gps_mode)
}
inline ::meshtastic::Config_PositionConfig_GpsMode Config_PositionConfig::_internal_gps_mode() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::meshtastic::Config_PositionConfig_GpsMode>(_impl_.gps_mode_);
}
inline void Config_PositionConfig::_internal_set_gps_mode(::meshtastic::Config_PositionConfig_GpsMode value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gps_mode_ = value;
}

// -------------------------------------------------------------------

// Config_PowerConfig

// bool is_power_saving = 1;
inline void Config_PowerConfig::clear_is_power_saving() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_power_saving_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool Config_PowerConfig::is_power_saving() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.PowerConfig.is_power_saving)
  return _internal_is_power_saving();
}
inline void Config_PowerConfig::set_is_power_saving(bool value) {
  _internal_set_is_power_saving(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.PowerConfig.is_power_saving)
}
inline bool Config_PowerConfig::_internal_is_power_saving() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_power_saving_;
}
inline void Config_PowerConfig::_internal_set_is_power_saving(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_power_saving_ = value;
}

// uint32 on_battery_shutdown_after_secs = 2;
inline void Config_PowerConfig::clear_on_battery_shutdown_after_secs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.on_battery_shutdown_after_secs_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t Config_PowerConfig::on_battery_shutdown_after_secs() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.PowerConfig.on_battery_shutdown_after_secs)
  return _internal_on_battery_shutdown_after_secs();
}
inline void Config_PowerConfig::set_on_battery_shutdown_after_secs(::uint32_t value) {
  _internal_set_on_battery_shutdown_after_secs(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.PowerConfig.on_battery_shutdown_after_secs)
}
inline ::uint32_t Config_PowerConfig::_internal_on_battery_shutdown_after_secs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.on_battery_shutdown_after_secs_;
}
inline void Config_PowerConfig::_internal_set_on_battery_shutdown_after_secs(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.on_battery_shutdown_after_secs_ = value;
}

// float adc_multiplier_override = 3;
inline void Config_PowerConfig::clear_adc_multiplier_override() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.adc_multiplier_override_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float Config_PowerConfig::adc_multiplier_override() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.PowerConfig.adc_multiplier_override)
  return _internal_adc_multiplier_override();
}
inline void Config_PowerConfig::set_adc_multiplier_override(float value) {
  _internal_set_adc_multiplier_override(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.PowerConfig.adc_multiplier_override)
}
inline float Config_PowerConfig::_internal_adc_multiplier_override() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.adc_multiplier_override_;
}
inline void Config_PowerConfig::_internal_set_adc_multiplier_override(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.adc_multiplier_override_ = value;
}

// uint32 wait_bluetooth_secs = 4;
inline void Config_PowerConfig::clear_wait_bluetooth_secs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wait_bluetooth_secs_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t Config_PowerConfig::wait_bluetooth_secs() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.PowerConfig.wait_bluetooth_secs)
  return _internal_wait_bluetooth_secs();
}
inline void Config_PowerConfig::set_wait_bluetooth_secs(::uint32_t value) {
  _internal_set_wait_bluetooth_secs(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.PowerConfig.wait_bluetooth_secs)
}
inline ::uint32_t Config_PowerConfig::_internal_wait_bluetooth_secs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.wait_bluetooth_secs_;
}
inline void Config_PowerConfig::_internal_set_wait_bluetooth_secs(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wait_bluetooth_secs_ = value;
}

// uint32 sds_secs = 6;
inline void Config_PowerConfig::clear_sds_secs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sds_secs_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t Config_PowerConfig::sds_secs() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.PowerConfig.sds_secs)
  return _internal_sds_secs();
}
inline void Config_PowerConfig::set_sds_secs(::uint32_t value) {
  _internal_set_sds_secs(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.PowerConfig.sds_secs)
}
inline ::uint32_t Config_PowerConfig::_internal_sds_secs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sds_secs_;
}
inline void Config_PowerConfig::_internal_set_sds_secs(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sds_secs_ = value;
}

// uint32 ls_secs = 7;
inline void Config_PowerConfig::clear_ls_secs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ls_secs_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint32_t Config_PowerConfig::ls_secs() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.PowerConfig.ls_secs)
  return _internal_ls_secs();
}
inline void Config_PowerConfig::set_ls_secs(::uint32_t value) {
  _internal_set_ls_secs(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.PowerConfig.ls_secs)
}
inline ::uint32_t Config_PowerConfig::_internal_ls_secs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ls_secs_;
}
inline void Config_PowerConfig::_internal_set_ls_secs(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ls_secs_ = value;
}

// uint32 min_wake_secs = 8;
inline void Config_PowerConfig::clear_min_wake_secs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_wake_secs_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint32_t Config_PowerConfig::min_wake_secs() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.PowerConfig.min_wake_secs)
  return _internal_min_wake_secs();
}
inline void Config_PowerConfig::set_min_wake_secs(::uint32_t value) {
  _internal_set_min_wake_secs(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.PowerConfig.min_wake_secs)
}
inline ::uint32_t Config_PowerConfig::_internal_min_wake_secs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.min_wake_secs_;
}
inline void Config_PowerConfig::_internal_set_min_wake_secs(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.min_wake_secs_ = value;
}

// uint32 device_battery_ina_address = 9;
inline void Config_PowerConfig::clear_device_battery_ina_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_battery_ina_address_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::uint32_t Config_PowerConfig::device_battery_ina_address() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.PowerConfig.device_battery_ina_address)
  return _internal_device_battery_ina_address();
}
inline void Config_PowerConfig::set_device_battery_ina_address(::uint32_t value) {
  _internal_set_device_battery_ina_address(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.PowerConfig.device_battery_ina_address)
}
inline ::uint32_t Config_PowerConfig::_internal_device_battery_ina_address() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.device_battery_ina_address_;
}
inline void Config_PowerConfig::_internal_set_device_battery_ina_address(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.device_battery_ina_address_ = value;
}

// uint64 powermon_enables = 32;
inline void Config_PowerConfig::clear_powermon_enables() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.powermon_enables_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::uint64_t Config_PowerConfig::powermon_enables() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.PowerConfig.powermon_enables)
  return _internal_powermon_enables();
}
inline void Config_PowerConfig::set_powermon_enables(::uint64_t value) {
  _internal_set_powermon_enables(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.PowerConfig.powermon_enables)
}
inline ::uint64_t Config_PowerConfig::_internal_powermon_enables() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.powermon_enables_;
}
inline void Config_PowerConfig::_internal_set_powermon_enables(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.powermon_enables_ = value;
}

// -------------------------------------------------------------------

// Config_NetworkConfig_IpV4Config

// fixed32 ip = 1;
inline void Config_NetworkConfig_IpV4Config::clear_ip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ip_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t Config_NetworkConfig_IpV4Config::ip() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.NetworkConfig.IpV4Config.ip)
  return _internal_ip();
}
inline void Config_NetworkConfig_IpV4Config::set_ip(::uint32_t value) {
  _internal_set_ip(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.NetworkConfig.IpV4Config.ip)
}
inline ::uint32_t Config_NetworkConfig_IpV4Config::_internal_ip() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ip_;
}
inline void Config_NetworkConfig_IpV4Config::_internal_set_ip(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ip_ = value;
}

// fixed32 gateway = 2;
inline void Config_NetworkConfig_IpV4Config::clear_gateway() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gateway_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t Config_NetworkConfig_IpV4Config::gateway() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.NetworkConfig.IpV4Config.gateway)
  return _internal_gateway();
}
inline void Config_NetworkConfig_IpV4Config::set_gateway(::uint32_t value) {
  _internal_set_gateway(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.NetworkConfig.IpV4Config.gateway)
}
inline ::uint32_t Config_NetworkConfig_IpV4Config::_internal_gateway() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gateway_;
}
inline void Config_NetworkConfig_IpV4Config::_internal_set_gateway(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gateway_ = value;
}

// fixed32 subnet = 3;
inline void Config_NetworkConfig_IpV4Config::clear_subnet() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.subnet_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t Config_NetworkConfig_IpV4Config::subnet() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.NetworkConfig.IpV4Config.subnet)
  return _internal_subnet();
}
inline void Config_NetworkConfig_IpV4Config::set_subnet(::uint32_t value) {
  _internal_set_subnet(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.NetworkConfig.IpV4Config.subnet)
}
inline ::uint32_t Config_NetworkConfig_IpV4Config::_internal_subnet() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.subnet_;
}
inline void Config_NetworkConfig_IpV4Config::_internal_set_subnet(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.subnet_ = value;
}

// fixed32 dns = 4;
inline void Config_NetworkConfig_IpV4Config::clear_dns() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dns_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t Config_NetworkConfig_IpV4Config::dns() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.NetworkConfig.IpV4Config.dns)
  return _internal_dns();
}
inline void Config_NetworkConfig_IpV4Config::set_dns(::uint32_t value) {
  _internal_set_dns(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.NetworkConfig.IpV4Config.dns)
}
inline ::uint32_t Config_NetworkConfig_IpV4Config::_internal_dns() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dns_;
}
inline void Config_NetworkConfig_IpV4Config::_internal_set_dns(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dns_ = value;
}

// -------------------------------------------------------------------

// Config_NetworkConfig

// bool wifi_enabled = 1;
inline void Config_NetworkConfig::clear_wifi_enabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wifi_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool Config_NetworkConfig::wifi_enabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.NetworkConfig.wifi_enabled)
  return _internal_wifi_enabled();
}
inline void Config_NetworkConfig::set_wifi_enabled(bool value) {
  _internal_set_wifi_enabled(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.NetworkConfig.wifi_enabled)
}
inline bool Config_NetworkConfig::_internal_wifi_enabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.wifi_enabled_;
}
inline void Config_NetworkConfig::_internal_set_wifi_enabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wifi_enabled_ = value;
}

// string wifi_ssid = 3;
inline void Config_NetworkConfig::clear_wifi_ssid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wifi_ssid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& Config_NetworkConfig::wifi_ssid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.Config.NetworkConfig.wifi_ssid)
  return _internal_wifi_ssid();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Config_NetworkConfig::set_wifi_ssid(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.wifi_ssid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:meshtastic.Config.NetworkConfig.wifi_ssid)
}
inline ::std::string* PROTOBUF_NONNULL Config_NetworkConfig::mutable_wifi_ssid()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_wifi_ssid();
  // @@protoc_insertion_point(field_mutable:meshtastic.Config.NetworkConfig.wifi_ssid)
  return _s;
}
inline const ::std::string& Config_NetworkConfig::_internal_wifi_ssid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.wifi_ssid_.Get();
}
inline void Config_NetworkConfig::_internal_set_wifi_ssid(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.wifi_ssid_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Config_NetworkConfig::_internal_mutable_wifi_ssid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.wifi_ssid_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Config_NetworkConfig::release_wifi_ssid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.Config.NetworkConfig.wifi_ssid)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.wifi_ssid_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.wifi_ssid_.Set("", GetArena());
  }
  return released;
}
inline void Config_NetworkConfig::set_allocated_wifi_ssid(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.wifi_ssid_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.wifi_ssid_.IsDefault()) {
    _impl_.wifi_ssid_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.Config.NetworkConfig.wifi_ssid)
}

// string wifi_psk = 4;
inline void Config_NetworkConfig::clear_wifi_psk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wifi_psk_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& Config_NetworkConfig::wifi_psk() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.Config.NetworkConfig.wifi_psk)
  return _internal_wifi_psk();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Config_NetworkConfig::set_wifi_psk(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.wifi_psk_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:meshtastic.Config.NetworkConfig.wifi_psk)
}
inline ::std::string* PROTOBUF_NONNULL Config_NetworkConfig::mutable_wifi_psk()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_wifi_psk();
  // @@protoc_insertion_point(field_mutable:meshtastic.Config.NetworkConfig.wifi_psk)
  return _s;
}
inline const ::std::string& Config_NetworkConfig::_internal_wifi_psk() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.wifi_psk_.Get();
}
inline void Config_NetworkConfig::_internal_set_wifi_psk(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.wifi_psk_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Config_NetworkConfig::_internal_mutable_wifi_psk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.wifi_psk_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Config_NetworkConfig::release_wifi_psk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.Config.NetworkConfig.wifi_psk)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.wifi_psk_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.wifi_psk_.Set("", GetArena());
  }
  return released;
}
inline void Config_NetworkConfig::set_allocated_wifi_psk(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.wifi_psk_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.wifi_psk_.IsDefault()) {
    _impl_.wifi_psk_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.Config.NetworkConfig.wifi_psk)
}

// string ntp_server = 5;
inline void Config_NetworkConfig::clear_ntp_server() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ntp_server_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& Config_NetworkConfig::ntp_server() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.Config.NetworkConfig.ntp_server)
  return _internal_ntp_server();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Config_NetworkConfig::set_ntp_server(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.ntp_server_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:meshtastic.Config.NetworkConfig.ntp_server)
}
inline ::std::string* PROTOBUF_NONNULL Config_NetworkConfig::mutable_ntp_server()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_ntp_server();
  // @@protoc_insertion_point(field_mutable:meshtastic.Config.NetworkConfig.ntp_server)
  return _s;
}
inline const ::std::string& Config_NetworkConfig::_internal_ntp_server() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ntp_server_.Get();
}
inline void Config_NetworkConfig::_internal_set_ntp_server(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.ntp_server_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Config_NetworkConfig::_internal_mutable_ntp_server() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.ntp_server_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Config_NetworkConfig::release_ntp_server() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.Config.NetworkConfig.ntp_server)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.ntp_server_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.ntp_server_.Set("", GetArena());
  }
  return released;
}
inline void Config_NetworkConfig::set_allocated_ntp_server(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.ntp_server_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.ntp_server_.IsDefault()) {
    _impl_.ntp_server_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.Config.NetworkConfig.ntp_server)
}

// bool eth_enabled = 6;
inline void Config_NetworkConfig::clear_eth_enabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.eth_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool Config_NetworkConfig::eth_enabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.NetworkConfig.eth_enabled)
  return _internal_eth_enabled();
}
inline void Config_NetworkConfig::set_eth_enabled(bool value) {
  _internal_set_eth_enabled(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.NetworkConfig.eth_enabled)
}
inline bool Config_NetworkConfig::_internal_eth_enabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.eth_enabled_;
}
inline void Config_NetworkConfig::_internal_set_eth_enabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.eth_enabled_ = value;
}

// .meshtastic.Config.NetworkConfig.AddressMode address_mode = 7;
inline void Config_NetworkConfig::clear_address_mode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.address_mode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::meshtastic::Config_NetworkConfig_AddressMode Config_NetworkConfig::address_mode() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.NetworkConfig.address_mode)
  return _internal_address_mode();
}
inline void Config_NetworkConfig::set_address_mode(::meshtastic::Config_NetworkConfig_AddressMode value) {
  _internal_set_address_mode(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.NetworkConfig.address_mode)
}
inline ::meshtastic::Config_NetworkConfig_AddressMode Config_NetworkConfig::_internal_address_mode() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::meshtastic::Config_NetworkConfig_AddressMode>(_impl_.address_mode_);
}
inline void Config_NetworkConfig::_internal_set_address_mode(::meshtastic::Config_NetworkConfig_AddressMode value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.address_mode_ = value;
}

// .meshtastic.Config.NetworkConfig.IpV4Config ipv4_config = 8;
inline bool Config_NetworkConfig::has_ipv4_config() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ipv4_config_ != nullptr);
  return value;
}
inline void Config_NetworkConfig::clear_ipv4_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ipv4_config_ != nullptr) _impl_.ipv4_config_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::meshtastic::Config_NetworkConfig_IpV4Config& Config_NetworkConfig::_internal_ipv4_config() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::meshtastic::Config_NetworkConfig_IpV4Config* p = _impl_.ipv4_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::Config_NetworkConfig_IpV4Config&>(::meshtastic::_Config_NetworkConfig_IpV4Config_default_instance_);
}
inline const ::meshtastic::Config_NetworkConfig_IpV4Config& Config_NetworkConfig::ipv4_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.Config.NetworkConfig.ipv4_config)
  return _internal_ipv4_config();
}
inline void Config_NetworkConfig::unsafe_arena_set_allocated_ipv4_config(
    ::meshtastic::Config_NetworkConfig_IpV4Config* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ipv4_config_);
  }
  _impl_.ipv4_config_ = reinterpret_cast<::meshtastic::Config_NetworkConfig_IpV4Config*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.Config.NetworkConfig.ipv4_config)
}
inline ::meshtastic::Config_NetworkConfig_IpV4Config* PROTOBUF_NULLABLE Config_NetworkConfig::release_ipv4_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::meshtastic::Config_NetworkConfig_IpV4Config* released = _impl_.ipv4_config_;
  _impl_.ipv4_config_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::meshtastic::Config_NetworkConfig_IpV4Config* PROTOBUF_NULLABLE Config_NetworkConfig::unsafe_arena_release_ipv4_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.Config.NetworkConfig.ipv4_config)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::meshtastic::Config_NetworkConfig_IpV4Config* temp = _impl_.ipv4_config_;
  _impl_.ipv4_config_ = nullptr;
  return temp;
}
inline ::meshtastic::Config_NetworkConfig_IpV4Config* PROTOBUF_NONNULL Config_NetworkConfig::_internal_mutable_ipv4_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.ipv4_config_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::meshtastic::Config_NetworkConfig_IpV4Config>(GetArena());
    _impl_.ipv4_config_ = reinterpret_cast<::meshtastic::Config_NetworkConfig_IpV4Config*>(p);
  }
  return _impl_.ipv4_config_;
}
inline ::meshtastic::Config_NetworkConfig_IpV4Config* PROTOBUF_NONNULL Config_NetworkConfig::mutable_ipv4_config()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::meshtastic::Config_NetworkConfig_IpV4Config* _msg = _internal_mutable_ipv4_config();
  // @@protoc_insertion_point(field_mutable:meshtastic.Config.NetworkConfig.ipv4_config)
  return _msg;
}
inline void Config_NetworkConfig::set_allocated_ipv4_config(::meshtastic::Config_NetworkConfig_IpV4Config* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ipv4_config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.ipv4_config_ = reinterpret_cast<::meshtastic::Config_NetworkConfig_IpV4Config*>(value);
  // @@protoc_insertion_point(field_set_allocated:meshtastic.Config.NetworkConfig.ipv4_config)
}

// string rsyslog_server = 9;
inline void Config_NetworkConfig::clear_rsyslog_server() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rsyslog_server_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::std::string& Config_NetworkConfig::rsyslog_server() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.Config.NetworkConfig.rsyslog_server)
  return _internal_rsyslog_server();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Config_NetworkConfig::set_rsyslog_server(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.rsyslog_server_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:meshtastic.Config.NetworkConfig.rsyslog_server)
}
inline ::std::string* PROTOBUF_NONNULL Config_NetworkConfig::mutable_rsyslog_server()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_rsyslog_server();
  // @@protoc_insertion_point(field_mutable:meshtastic.Config.NetworkConfig.rsyslog_server)
  return _s;
}
inline const ::std::string& Config_NetworkConfig::_internal_rsyslog_server() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.rsyslog_server_.Get();
}
inline void Config_NetworkConfig::_internal_set_rsyslog_server(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.rsyslog_server_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Config_NetworkConfig::_internal_mutable_rsyslog_server() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.rsyslog_server_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Config_NetworkConfig::release_rsyslog_server() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.Config.NetworkConfig.rsyslog_server)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.rsyslog_server_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.rsyslog_server_.Set("", GetArena());
  }
  return released;
}
inline void Config_NetworkConfig::set_allocated_rsyslog_server(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.rsyslog_server_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.rsyslog_server_.IsDefault()) {
    _impl_.rsyslog_server_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.Config.NetworkConfig.rsyslog_server)
}

// uint32 enabled_protocols = 10;
inline void Config_NetworkConfig::clear_enabled_protocols() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enabled_protocols_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::uint32_t Config_NetworkConfig::enabled_protocols() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.NetworkConfig.enabled_protocols)
  return _internal_enabled_protocols();
}
inline void Config_NetworkConfig::set_enabled_protocols(::uint32_t value) {
  _internal_set_enabled_protocols(value);
  _impl_._has_bits_[0] |= 0x00000200u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.NetworkConfig.enabled_protocols)
}
inline ::uint32_t Config_NetworkConfig::_internal_enabled_protocols() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enabled_protocols_;
}
inline void Config_NetworkConfig::_internal_set_enabled_protocols(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enabled_protocols_ = value;
}

// bool ipv6_enabled = 11;
inline void Config_NetworkConfig::clear_ipv6_enabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ipv6_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool Config_NetworkConfig::ipv6_enabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.NetworkConfig.ipv6_enabled)
  return _internal_ipv6_enabled();
}
inline void Config_NetworkConfig::set_ipv6_enabled(bool value) {
  _internal_set_ipv6_enabled(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.NetworkConfig.ipv6_enabled)
}
inline bool Config_NetworkConfig::_internal_ipv6_enabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ipv6_enabled_;
}
inline void Config_NetworkConfig::_internal_set_ipv6_enabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ipv6_enabled_ = value;
}

// -------------------------------------------------------------------

// Config_DisplayConfig

// uint32 screen_on_secs = 1;
inline void Config_DisplayConfig::clear_screen_on_secs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.screen_on_secs_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t Config_DisplayConfig::screen_on_secs() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.DisplayConfig.screen_on_secs)
  return _internal_screen_on_secs();
}
inline void Config_DisplayConfig::set_screen_on_secs(::uint32_t value) {
  _internal_set_screen_on_secs(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.DisplayConfig.screen_on_secs)
}
inline ::uint32_t Config_DisplayConfig::_internal_screen_on_secs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.screen_on_secs_;
}
inline void Config_DisplayConfig::_internal_set_screen_on_secs(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.screen_on_secs_ = value;
}

// .meshtastic.Config.DisplayConfig.GpsCoordinateFormat gps_format = 2 [deprecated = true];
inline void Config_DisplayConfig::clear_gps_format() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gps_format_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::meshtastic::Config_DisplayConfig_GpsCoordinateFormat Config_DisplayConfig::gps_format() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.DisplayConfig.gps_format)
  return _internal_gps_format();
}
inline void Config_DisplayConfig::set_gps_format(::meshtastic::Config_DisplayConfig_GpsCoordinateFormat value) {
  _internal_set_gps_format(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.DisplayConfig.gps_format)
}
inline ::meshtastic::Config_DisplayConfig_GpsCoordinateFormat Config_DisplayConfig::_internal_gps_format() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::meshtastic::Config_DisplayConfig_GpsCoordinateFormat>(_impl_.gps_format_);
}
inline void Config_DisplayConfig::_internal_set_gps_format(::meshtastic::Config_DisplayConfig_GpsCoordinateFormat value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gps_format_ = value;
}

// uint32 auto_screen_carousel_secs = 3;
inline void Config_DisplayConfig::clear_auto_screen_carousel_secs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.auto_screen_carousel_secs_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t Config_DisplayConfig::auto_screen_carousel_secs() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.DisplayConfig.auto_screen_carousel_secs)
  return _internal_auto_screen_carousel_secs();
}
inline void Config_DisplayConfig::set_auto_screen_carousel_secs(::uint32_t value) {
  _internal_set_auto_screen_carousel_secs(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.DisplayConfig.auto_screen_carousel_secs)
}
inline ::uint32_t Config_DisplayConfig::_internal_auto_screen_carousel_secs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.auto_screen_carousel_secs_;
}
inline void Config_DisplayConfig::_internal_set_auto_screen_carousel_secs(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.auto_screen_carousel_secs_ = value;
}

// bool compass_north_top = 4 [deprecated = true];
inline void Config_DisplayConfig::clear_compass_north_top() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compass_north_top_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool Config_DisplayConfig::compass_north_top() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.DisplayConfig.compass_north_top)
  return _internal_compass_north_top();
}
inline void Config_DisplayConfig::set_compass_north_top(bool value) {
  _internal_set_compass_north_top(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.DisplayConfig.compass_north_top)
}
inline bool Config_DisplayConfig::_internal_compass_north_top() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.compass_north_top_;
}
inline void Config_DisplayConfig::_internal_set_compass_north_top(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compass_north_top_ = value;
}

// bool flip_screen = 5;
inline void Config_DisplayConfig::clear_flip_screen() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.flip_screen_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool Config_DisplayConfig::flip_screen() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.DisplayConfig.flip_screen)
  return _internal_flip_screen();
}
inline void Config_DisplayConfig::set_flip_screen(bool value) {
  _internal_set_flip_screen(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.DisplayConfig.flip_screen)
}
inline bool Config_DisplayConfig::_internal_flip_screen() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.flip_screen_;
}
inline void Config_DisplayConfig::_internal_set_flip_screen(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.flip_screen_ = value;
}

// .meshtastic.Config.DisplayConfig.DisplayUnits units = 6;
inline void Config_DisplayConfig::clear_units() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.units_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::meshtastic::Config_DisplayConfig_DisplayUnits Config_DisplayConfig::units() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.DisplayConfig.units)
  return _internal_units();
}
inline void Config_DisplayConfig::set_units(::meshtastic::Config_DisplayConfig_DisplayUnits value) {
  _internal_set_units(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.DisplayConfig.units)
}
inline ::meshtastic::Config_DisplayConfig_DisplayUnits Config_DisplayConfig::_internal_units() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::meshtastic::Config_DisplayConfig_DisplayUnits>(_impl_.units_);
}
inline void Config_DisplayConfig::_internal_set_units(::meshtastic::Config_DisplayConfig_DisplayUnits value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.units_ = value;
}

// .meshtastic.Config.DisplayConfig.OledType oled = 7;
inline void Config_DisplayConfig::clear_oled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.oled_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::meshtastic::Config_DisplayConfig_OledType Config_DisplayConfig::oled() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.DisplayConfig.oled)
  return _internal_oled();
}
inline void Config_DisplayConfig::set_oled(::meshtastic::Config_DisplayConfig_OledType value) {
  _internal_set_oled(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.DisplayConfig.oled)
}
inline ::meshtastic::Config_DisplayConfig_OledType Config_DisplayConfig::_internal_oled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::meshtastic::Config_DisplayConfig_OledType>(_impl_.oled_);
}
inline void Config_DisplayConfig::_internal_set_oled(::meshtastic::Config_DisplayConfig_OledType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.oled_ = value;
}

// .meshtastic.Config.DisplayConfig.DisplayMode displaymode = 8;
inline void Config_DisplayConfig::clear_displaymode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.displaymode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::meshtastic::Config_DisplayConfig_DisplayMode Config_DisplayConfig::displaymode() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.DisplayConfig.displaymode)
  return _internal_displaymode();
}
inline void Config_DisplayConfig::set_displaymode(::meshtastic::Config_DisplayConfig_DisplayMode value) {
  _internal_set_displaymode(value);
  _impl_._has_bits_[0] |= 0x00000200u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.DisplayConfig.displaymode)
}
inline ::meshtastic::Config_DisplayConfig_DisplayMode Config_DisplayConfig::_internal_displaymode() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::meshtastic::Config_DisplayConfig_DisplayMode>(_impl_.displaymode_);
}
inline void Config_DisplayConfig::_internal_set_displaymode(::meshtastic::Config_DisplayConfig_DisplayMode value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.displaymode_ = value;
}

// bool heading_bold = 9;
inline void Config_DisplayConfig::clear_heading_bold() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.heading_bold_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool Config_DisplayConfig::heading_bold() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.DisplayConfig.heading_bold)
  return _internal_heading_bold();
}
inline void Config_DisplayConfig::set_heading_bold(bool value) {
  _internal_set_heading_bold(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.DisplayConfig.heading_bold)
}
inline bool Config_DisplayConfig::_internal_heading_bold() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.heading_bold_;
}
inline void Config_DisplayConfig::_internal_set_heading_bold(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.heading_bold_ = value;
}

// bool wake_on_tap_or_motion = 10;
inline void Config_DisplayConfig::clear_wake_on_tap_or_motion() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wake_on_tap_or_motion_ = false;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool Config_DisplayConfig::wake_on_tap_or_motion() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.DisplayConfig.wake_on_tap_or_motion)
  return _internal_wake_on_tap_or_motion();
}
inline void Config_DisplayConfig::set_wake_on_tap_or_motion(bool value) {
  _internal_set_wake_on_tap_or_motion(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.DisplayConfig.wake_on_tap_or_motion)
}
inline bool Config_DisplayConfig::_internal_wake_on_tap_or_motion() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.wake_on_tap_or_motion_;
}
inline void Config_DisplayConfig::_internal_set_wake_on_tap_or_motion(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wake_on_tap_or_motion_ = value;
}

// .meshtastic.Config.DisplayConfig.CompassOrientation compass_orientation = 11;
inline void Config_DisplayConfig::clear_compass_orientation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compass_orientation_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::meshtastic::Config_DisplayConfig_CompassOrientation Config_DisplayConfig::compass_orientation() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.DisplayConfig.compass_orientation)
  return _internal_compass_orientation();
}
inline void Config_DisplayConfig::set_compass_orientation(::meshtastic::Config_DisplayConfig_CompassOrientation value) {
  _internal_set_compass_orientation(value);
  _impl_._has_bits_[0] |= 0x00000400u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.DisplayConfig.compass_orientation)
}
inline ::meshtastic::Config_DisplayConfig_CompassOrientation Config_DisplayConfig::_internal_compass_orientation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::meshtastic::Config_DisplayConfig_CompassOrientation>(_impl_.compass_orientation_);
}
inline void Config_DisplayConfig::_internal_set_compass_orientation(::meshtastic::Config_DisplayConfig_CompassOrientation value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compass_orientation_ = value;
}

// bool use_12h_clock = 12;
inline void Config_DisplayConfig::clear_use_12h_clock() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.use_12h_clock_ = false;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline bool Config_DisplayConfig::use_12h_clock() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.DisplayConfig.use_12h_clock)
  return _internal_use_12h_clock();
}
inline void Config_DisplayConfig::set_use_12h_clock(bool value) {
  _internal_set_use_12h_clock(value);
  _impl_._has_bits_[0] |= 0x00000800u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.DisplayConfig.use_12h_clock)
}
inline bool Config_DisplayConfig::_internal_use_12h_clock() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.use_12h_clock_;
}
inline void Config_DisplayConfig::_internal_set_use_12h_clock(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.use_12h_clock_ = value;
}

// -------------------------------------------------------------------

// Config_LoRaConfig

// bool use_preset = 1;
inline void Config_LoRaConfig::clear_use_preset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.use_preset_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool Config_LoRaConfig::use_preset() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.LoRaConfig.use_preset)
  return _internal_use_preset();
}
inline void Config_LoRaConfig::set_use_preset(bool value) {
  _internal_set_use_preset(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.LoRaConfig.use_preset)
}
inline bool Config_LoRaConfig::_internal_use_preset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.use_preset_;
}
inline void Config_LoRaConfig::_internal_set_use_preset(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.use_preset_ = value;
}

// .meshtastic.Config.LoRaConfig.ModemPreset modem_preset = 2;
inline void Config_LoRaConfig::clear_modem_preset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.modem_preset_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::meshtastic::Config_LoRaConfig_ModemPreset Config_LoRaConfig::modem_preset() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.LoRaConfig.modem_preset)
  return _internal_modem_preset();
}
inline void Config_LoRaConfig::set_modem_preset(::meshtastic::Config_LoRaConfig_ModemPreset value) {
  _internal_set_modem_preset(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.LoRaConfig.modem_preset)
}
inline ::meshtastic::Config_LoRaConfig_ModemPreset Config_LoRaConfig::_internal_modem_preset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::meshtastic::Config_LoRaConfig_ModemPreset>(_impl_.modem_preset_);
}
inline void Config_LoRaConfig::_internal_set_modem_preset(::meshtastic::Config_LoRaConfig_ModemPreset value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.modem_preset_ = value;
}

// uint32 bandwidth = 3;
inline void Config_LoRaConfig::clear_bandwidth() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bandwidth_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t Config_LoRaConfig::bandwidth() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.LoRaConfig.bandwidth)
  return _internal_bandwidth();
}
inline void Config_LoRaConfig::set_bandwidth(::uint32_t value) {
  _internal_set_bandwidth(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.LoRaConfig.bandwidth)
}
inline ::uint32_t Config_LoRaConfig::_internal_bandwidth() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.bandwidth_;
}
inline void Config_LoRaConfig::_internal_set_bandwidth(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bandwidth_ = value;
}

// uint32 spread_factor = 4;
inline void Config_LoRaConfig::clear_spread_factor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.spread_factor_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t Config_LoRaConfig::spread_factor() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.LoRaConfig.spread_factor)
  return _internal_spread_factor();
}
inline void Config_LoRaConfig::set_spread_factor(::uint32_t value) {
  _internal_set_spread_factor(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.LoRaConfig.spread_factor)
}
inline ::uint32_t Config_LoRaConfig::_internal_spread_factor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.spread_factor_;
}
inline void Config_LoRaConfig::_internal_set_spread_factor(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.spread_factor_ = value;
}

// uint32 coding_rate = 5;
inline void Config_LoRaConfig::clear_coding_rate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.coding_rate_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t Config_LoRaConfig::coding_rate() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.LoRaConfig.coding_rate)
  return _internal_coding_rate();
}
inline void Config_LoRaConfig::set_coding_rate(::uint32_t value) {
  _internal_set_coding_rate(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.LoRaConfig.coding_rate)
}
inline ::uint32_t Config_LoRaConfig::_internal_coding_rate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.coding_rate_;
}
inline void Config_LoRaConfig::_internal_set_coding_rate(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.coding_rate_ = value;
}

// float frequency_offset = 6;
inline void Config_LoRaConfig::clear_frequency_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.frequency_offset_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float Config_LoRaConfig::frequency_offset() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.LoRaConfig.frequency_offset)
  return _internal_frequency_offset();
}
inline void Config_LoRaConfig::set_frequency_offset(float value) {
  _internal_set_frequency_offset(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.LoRaConfig.frequency_offset)
}
inline float Config_LoRaConfig::_internal_frequency_offset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.frequency_offset_;
}
inline void Config_LoRaConfig::_internal_set_frequency_offset(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.frequency_offset_ = value;
}

// .meshtastic.Config.LoRaConfig.RegionCode region = 7;
inline void Config_LoRaConfig::clear_region() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.region_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::meshtastic::Config_LoRaConfig_RegionCode Config_LoRaConfig::region() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.LoRaConfig.region)
  return _internal_region();
}
inline void Config_LoRaConfig::set_region(::meshtastic::Config_LoRaConfig_RegionCode value) {
  _internal_set_region(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.LoRaConfig.region)
}
inline ::meshtastic::Config_LoRaConfig_RegionCode Config_LoRaConfig::_internal_region() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::meshtastic::Config_LoRaConfig_RegionCode>(_impl_.region_);
}
inline void Config_LoRaConfig::_internal_set_region(::meshtastic::Config_LoRaConfig_RegionCode value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.region_ = value;
}

// uint32 hop_limit = 8;
inline void Config_LoRaConfig::clear_hop_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hop_limit_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint32_t Config_LoRaConfig::hop_limit() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.LoRaConfig.hop_limit)
  return _internal_hop_limit();
}
inline void Config_LoRaConfig::set_hop_limit(::uint32_t value) {
  _internal_set_hop_limit(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.LoRaConfig.hop_limit)
}
inline ::uint32_t Config_LoRaConfig::_internal_hop_limit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hop_limit_;
}
inline void Config_LoRaConfig::_internal_set_hop_limit(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hop_limit_ = value;
}

// bool tx_enabled = 9;
inline void Config_LoRaConfig::clear_tx_enabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tx_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool Config_LoRaConfig::tx_enabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.LoRaConfig.tx_enabled)
  return _internal_tx_enabled();
}
inline void Config_LoRaConfig::set_tx_enabled(bool value) {
  _internal_set_tx_enabled(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.LoRaConfig.tx_enabled)
}
inline bool Config_LoRaConfig::_internal_tx_enabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tx_enabled_;
}
inline void Config_LoRaConfig::_internal_set_tx_enabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tx_enabled_ = value;
}

// int32 tx_power = 10;
inline void Config_LoRaConfig::clear_tx_power() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tx_power_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::int32_t Config_LoRaConfig::tx_power() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.LoRaConfig.tx_power)
  return _internal_tx_power();
}
inline void Config_LoRaConfig::set_tx_power(::int32_t value) {
  _internal_set_tx_power(value);
  _impl_._has_bits_[0] |= 0x00000800u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.LoRaConfig.tx_power)
}
inline ::int32_t Config_LoRaConfig::_internal_tx_power() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tx_power_;
}
inline void Config_LoRaConfig::_internal_set_tx_power(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tx_power_ = value;
}

// uint32 channel_num = 11;
inline void Config_LoRaConfig::clear_channel_num() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channel_num_ = 0u;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline ::uint32_t Config_LoRaConfig::channel_num() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.LoRaConfig.channel_num)
  return _internal_channel_num();
}
inline void Config_LoRaConfig::set_channel_num(::uint32_t value) {
  _internal_set_channel_num(value);
  _impl_._has_bits_[0] |= 0x00001000u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.LoRaConfig.channel_num)
}
inline ::uint32_t Config_LoRaConfig::_internal_channel_num() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.channel_num_;
}
inline void Config_LoRaConfig::_internal_set_channel_num(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channel_num_ = value;
}

// bool override_duty_cycle = 12;
inline void Config_LoRaConfig::clear_override_duty_cycle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.override_duty_cycle_ = false;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline bool Config_LoRaConfig::override_duty_cycle() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.LoRaConfig.override_duty_cycle)
  return _internal_override_duty_cycle();
}
inline void Config_LoRaConfig::set_override_duty_cycle(bool value) {
  _internal_set_override_duty_cycle(value);
  _impl_._has_bits_[0] |= 0x00000200u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.LoRaConfig.override_duty_cycle)
}
inline bool Config_LoRaConfig::_internal_override_duty_cycle() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.override_duty_cycle_;
}
inline void Config_LoRaConfig::_internal_set_override_duty_cycle(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.override_duty_cycle_ = value;
}

// bool sx126x_rx_boosted_gain = 13;
inline void Config_LoRaConfig::clear_sx126x_rx_boosted_gain() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sx126x_rx_boosted_gain_ = false;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline bool Config_LoRaConfig::sx126x_rx_boosted_gain() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.LoRaConfig.sx126x_rx_boosted_gain)
  return _internal_sx126x_rx_boosted_gain();
}
inline void Config_LoRaConfig::set_sx126x_rx_boosted_gain(bool value) {
  _internal_set_sx126x_rx_boosted_gain(value);
  _impl_._has_bits_[0] |= 0x00000400u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.LoRaConfig.sx126x_rx_boosted_gain)
}
inline bool Config_LoRaConfig::_internal_sx126x_rx_boosted_gain() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sx126x_rx_boosted_gain_;
}
inline void Config_LoRaConfig::_internal_set_sx126x_rx_boosted_gain(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sx126x_rx_boosted_gain_ = value;
}

// float override_frequency = 14;
inline void Config_LoRaConfig::clear_override_frequency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.override_frequency_ = 0;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline float Config_LoRaConfig::override_frequency() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.LoRaConfig.override_frequency)
  return _internal_override_frequency();
}
inline void Config_LoRaConfig::set_override_frequency(float value) {
  _internal_set_override_frequency(value);
  _impl_._has_bits_[0] |= 0x00002000u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.LoRaConfig.override_frequency)
}
inline float Config_LoRaConfig::_internal_override_frequency() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.override_frequency_;
}
inline void Config_LoRaConfig::_internal_set_override_frequency(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.override_frequency_ = value;
}

// bool pa_fan_disabled = 15;
inline void Config_LoRaConfig::clear_pa_fan_disabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pa_fan_disabled_ = false;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline bool Config_LoRaConfig::pa_fan_disabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.LoRaConfig.pa_fan_disabled)
  return _internal_pa_fan_disabled();
}
inline void Config_LoRaConfig::set_pa_fan_disabled(bool value) {
  _internal_set_pa_fan_disabled(value);
  _impl_._has_bits_[0] |= 0x00004000u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.LoRaConfig.pa_fan_disabled)
}
inline bool Config_LoRaConfig::_internal_pa_fan_disabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pa_fan_disabled_;
}
inline void Config_LoRaConfig::_internal_set_pa_fan_disabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pa_fan_disabled_ = value;
}

// repeated uint32 ignore_incoming = 103;
inline int Config_LoRaConfig::_internal_ignore_incoming_size() const {
  return _internal_ignore_incoming().size();
}
inline int Config_LoRaConfig::ignore_incoming_size() const {
  return _internal_ignore_incoming_size();
}
inline void Config_LoRaConfig::clear_ignore_incoming() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ignore_incoming_.Clear();
}
inline ::uint32_t Config_LoRaConfig::ignore_incoming(int index) const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.LoRaConfig.ignore_incoming)
  return _internal_ignore_incoming().Get(index);
}
inline void Config_LoRaConfig::set_ignore_incoming(int index, ::uint32_t value) {
  _internal_mutable_ignore_incoming()->Set(index, value);
  // @@protoc_insertion_point(field_set:meshtastic.Config.LoRaConfig.ignore_incoming)
}
inline void Config_LoRaConfig::add_ignore_incoming(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_ignore_incoming()->Add(value);
  // @@protoc_insertion_point(field_add:meshtastic.Config.LoRaConfig.ignore_incoming)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& Config_LoRaConfig::ignore_incoming() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:meshtastic.Config.LoRaConfig.ignore_incoming)
  return _internal_ignore_incoming();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL Config_LoRaConfig::mutable_ignore_incoming()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:meshtastic.Config.LoRaConfig.ignore_incoming)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_ignore_incoming();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
Config_LoRaConfig::_internal_ignore_incoming() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ignore_incoming_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PROTOBUF_NONNULL
Config_LoRaConfig::_internal_mutable_ignore_incoming() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.ignore_incoming_;
}

// bool ignore_mqtt = 104;
inline void Config_LoRaConfig::clear_ignore_mqtt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ignore_mqtt_ = false;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline bool Config_LoRaConfig::ignore_mqtt() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.LoRaConfig.ignore_mqtt)
  return _internal_ignore_mqtt();
}
inline void Config_LoRaConfig::set_ignore_mqtt(bool value) {
  _internal_set_ignore_mqtt(value);
  _impl_._has_bits_[0] |= 0x00008000u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.LoRaConfig.ignore_mqtt)
}
inline bool Config_LoRaConfig::_internal_ignore_mqtt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ignore_mqtt_;
}
inline void Config_LoRaConfig::_internal_set_ignore_mqtt(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ignore_mqtt_ = value;
}

// bool config_ok_to_mqtt = 105;
inline void Config_LoRaConfig::clear_config_ok_to_mqtt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.config_ok_to_mqtt_ = false;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline bool Config_LoRaConfig::config_ok_to_mqtt() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.LoRaConfig.config_ok_to_mqtt)
  return _internal_config_ok_to_mqtt();
}
inline void Config_LoRaConfig::set_config_ok_to_mqtt(bool value) {
  _internal_set_config_ok_to_mqtt(value);
  _impl_._has_bits_[0] |= 0x00010000u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.LoRaConfig.config_ok_to_mqtt)
}
inline bool Config_LoRaConfig::_internal_config_ok_to_mqtt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.config_ok_to_mqtt_;
}
inline void Config_LoRaConfig::_internal_set_config_ok_to_mqtt(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.config_ok_to_mqtt_ = value;
}

// -------------------------------------------------------------------

// Config_BluetoothConfig

// bool enabled = 1;
inline void Config_BluetoothConfig::clear_enabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool Config_BluetoothConfig::enabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.BluetoothConfig.enabled)
  return _internal_enabled();
}
inline void Config_BluetoothConfig::set_enabled(bool value) {
  _internal_set_enabled(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.BluetoothConfig.enabled)
}
inline bool Config_BluetoothConfig::_internal_enabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enabled_;
}
inline void Config_BluetoothConfig::_internal_set_enabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enabled_ = value;
}

// .meshtastic.Config.BluetoothConfig.PairingMode mode = 2;
inline void Config_BluetoothConfig::clear_mode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::meshtastic::Config_BluetoothConfig_PairingMode Config_BluetoothConfig::mode() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.BluetoothConfig.mode)
  return _internal_mode();
}
inline void Config_BluetoothConfig::set_mode(::meshtastic::Config_BluetoothConfig_PairingMode value) {
  _internal_set_mode(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.BluetoothConfig.mode)
}
inline ::meshtastic::Config_BluetoothConfig_PairingMode Config_BluetoothConfig::_internal_mode() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::meshtastic::Config_BluetoothConfig_PairingMode>(_impl_.mode_);
}
inline void Config_BluetoothConfig::_internal_set_mode(::meshtastic::Config_BluetoothConfig_PairingMode value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mode_ = value;
}

// uint32 fixed_pin = 3;
inline void Config_BluetoothConfig::clear_fixed_pin() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fixed_pin_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t Config_BluetoothConfig::fixed_pin() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.BluetoothConfig.fixed_pin)
  return _internal_fixed_pin();
}
inline void Config_BluetoothConfig::set_fixed_pin(::uint32_t value) {
  _internal_set_fixed_pin(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.BluetoothConfig.fixed_pin)
}
inline ::uint32_t Config_BluetoothConfig::_internal_fixed_pin() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fixed_pin_;
}
inline void Config_BluetoothConfig::_internal_set_fixed_pin(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fixed_pin_ = value;
}

// -------------------------------------------------------------------

// Config_SecurityConfig

// bytes public_key = 1;
inline void Config_SecurityConfig::clear_public_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.public_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& Config_SecurityConfig::public_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.Config.SecurityConfig.public_key)
  return _internal_public_key();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Config_SecurityConfig::set_public_key(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.public_key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:meshtastic.Config.SecurityConfig.public_key)
}
inline ::std::string* PROTOBUF_NONNULL Config_SecurityConfig::mutable_public_key()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_public_key();
  // @@protoc_insertion_point(field_mutable:meshtastic.Config.SecurityConfig.public_key)
  return _s;
}
inline const ::std::string& Config_SecurityConfig::_internal_public_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.public_key_.Get();
}
inline void Config_SecurityConfig::_internal_set_public_key(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.public_key_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Config_SecurityConfig::_internal_mutable_public_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.public_key_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Config_SecurityConfig::release_public_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.Config.SecurityConfig.public_key)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.public_key_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.public_key_.Set("", GetArena());
  }
  return released;
}
inline void Config_SecurityConfig::set_allocated_public_key(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.public_key_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.public_key_.IsDefault()) {
    _impl_.public_key_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.Config.SecurityConfig.public_key)
}

// bytes private_key = 2;
inline void Config_SecurityConfig::clear_private_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.private_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& Config_SecurityConfig::private_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.Config.SecurityConfig.private_key)
  return _internal_private_key();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void Config_SecurityConfig::set_private_key(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.private_key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:meshtastic.Config.SecurityConfig.private_key)
}
inline ::std::string* PROTOBUF_NONNULL Config_SecurityConfig::mutable_private_key()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_private_key();
  // @@protoc_insertion_point(field_mutable:meshtastic.Config.SecurityConfig.private_key)
  return _s;
}
inline const ::std::string& Config_SecurityConfig::_internal_private_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.private_key_.Get();
}
inline void Config_SecurityConfig::_internal_set_private_key(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.private_key_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL Config_SecurityConfig::_internal_mutable_private_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.private_key_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE Config_SecurityConfig::release_private_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.Config.SecurityConfig.private_key)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.private_key_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.private_key_.Set("", GetArena());
  }
  return released;
}
inline void Config_SecurityConfig::set_allocated_private_key(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.private_key_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.private_key_.IsDefault()) {
    _impl_.private_key_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.Config.SecurityConfig.private_key)
}

// repeated bytes admin_key = 3;
inline int Config_SecurityConfig::_internal_admin_key_size() const {
  return _internal_admin_key().size();
}
inline int Config_SecurityConfig::admin_key_size() const {
  return _internal_admin_key_size();
}
inline void Config_SecurityConfig::clear_admin_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.admin_key_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL Config_SecurityConfig::add_admin_key()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_admin_key()->Add();
  // @@protoc_insertion_point(field_add_mutable:meshtastic.Config.SecurityConfig.admin_key)
  return _s;
}
inline const ::std::string& Config_SecurityConfig::admin_key(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.Config.SecurityConfig.admin_key)
  return _internal_admin_key().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL Config_SecurityConfig::mutable_admin_key(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:meshtastic.Config.SecurityConfig.admin_key)
  return _internal_mutable_admin_key()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void Config_SecurityConfig::set_admin_key(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_admin_key()->Mutable(index), ::std::forward<Arg_>(value),
                        args... , ::google::protobuf::internal::BytesTag{});
  // @@protoc_insertion_point(field_set:meshtastic.Config.SecurityConfig.admin_key)
}
template <typename Arg_, typename... Args_>
inline void Config_SecurityConfig::add_admin_key(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_admin_key(),
                               ::std::forward<Arg_>(value),
                               args... , ::google::protobuf::internal::BytesTag{});
  // @@protoc_insertion_point(field_add:meshtastic.Config.SecurityConfig.admin_key)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& Config_SecurityConfig::admin_key()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:meshtastic.Config.SecurityConfig.admin_key)
  return _internal_admin_key();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
Config_SecurityConfig::mutable_admin_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:meshtastic.Config.SecurityConfig.admin_key)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_admin_key();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
Config_SecurityConfig::_internal_admin_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.admin_key_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
Config_SecurityConfig::_internal_mutable_admin_key() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.admin_key_;
}

// bool is_managed = 4;
inline void Config_SecurityConfig::clear_is_managed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_managed_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool Config_SecurityConfig::is_managed() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.SecurityConfig.is_managed)
  return _internal_is_managed();
}
inline void Config_SecurityConfig::set_is_managed(bool value) {
  _internal_set_is_managed(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.SecurityConfig.is_managed)
}
inline bool Config_SecurityConfig::_internal_is_managed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_managed_;
}
inline void Config_SecurityConfig::_internal_set_is_managed(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_managed_ = value;
}

// bool serial_enabled = 5;
inline void Config_SecurityConfig::clear_serial_enabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.serial_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool Config_SecurityConfig::serial_enabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.SecurityConfig.serial_enabled)
  return _internal_serial_enabled();
}
inline void Config_SecurityConfig::set_serial_enabled(bool value) {
  _internal_set_serial_enabled(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.SecurityConfig.serial_enabled)
}
inline bool Config_SecurityConfig::_internal_serial_enabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.serial_enabled_;
}
inline void Config_SecurityConfig::_internal_set_serial_enabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.serial_enabled_ = value;
}

// bool debug_log_api_enabled = 6;
inline void Config_SecurityConfig::clear_debug_log_api_enabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.debug_log_api_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool Config_SecurityConfig::debug_log_api_enabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.SecurityConfig.debug_log_api_enabled)
  return _internal_debug_log_api_enabled();
}
inline void Config_SecurityConfig::set_debug_log_api_enabled(bool value) {
  _internal_set_debug_log_api_enabled(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.SecurityConfig.debug_log_api_enabled)
}
inline bool Config_SecurityConfig::_internal_debug_log_api_enabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.debug_log_api_enabled_;
}
inline void Config_SecurityConfig::_internal_set_debug_log_api_enabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.debug_log_api_enabled_ = value;
}

// bool admin_channel_enabled = 8;
inline void Config_SecurityConfig::clear_admin_channel_enabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.admin_channel_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool Config_SecurityConfig::admin_channel_enabled() const {
  // @@protoc_insertion_point(field_get:meshtastic.Config.SecurityConfig.admin_channel_enabled)
  return _internal_admin_channel_enabled();
}
inline void Config_SecurityConfig::set_admin_channel_enabled(bool value) {
  _internal_set_admin_channel_enabled(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:meshtastic.Config.SecurityConfig.admin_channel_enabled)
}
inline bool Config_SecurityConfig::_internal_admin_channel_enabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.admin_channel_enabled_;
}
inline void Config_SecurityConfig::_internal_set_admin_channel_enabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.admin_channel_enabled_ = value;
}

// -------------------------------------------------------------------

// Config_SessionkeyConfig

// -------------------------------------------------------------------

// Config

// .meshtastic.Config.DeviceConfig device = 1;
inline bool Config::has_device() const {
  return payload_variant_case() == kDevice;
}
inline bool Config::_internal_has_device() const {
  return payload_variant_case() == kDevice;
}
inline void Config::set_has_device() {
  _impl_._oneof_case_[0] = kDevice;
}
inline void Config::clear_device() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kDevice) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_variant_.device_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.device_);
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::Config_DeviceConfig* PROTOBUF_NULLABLE Config::release_device() {
  // @@protoc_insertion_point(field_release:meshtastic.Config.device)
  if (payload_variant_case() == kDevice) {
    clear_has_payload_variant();
    auto* temp = reinterpret_cast<::meshtastic::Config_DeviceConfig*>(_impl_.payload_variant_.device_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.device_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::Config_DeviceConfig& Config::_internal_device() const {
  return payload_variant_case() == kDevice ? *reinterpret_cast<::meshtastic::Config_DeviceConfig*>(_impl_.payload_variant_.device_) : reinterpret_cast<::meshtastic::Config_DeviceConfig&>(::meshtastic::_Config_DeviceConfig_default_instance_);
}
inline const ::meshtastic::Config_DeviceConfig& Config::device() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.Config.device)
  return _internal_device();
}
inline ::meshtastic::Config_DeviceConfig* PROTOBUF_NULLABLE Config::unsafe_arena_release_device() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.Config.device)
  if (payload_variant_case() == kDevice) {
    clear_has_payload_variant();
    auto* temp = reinterpret_cast<::meshtastic::Config_DeviceConfig*>(_impl_.payload_variant_.device_);
    _impl_.payload_variant_.device_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Config::unsafe_arena_set_allocated_device(
    ::meshtastic::Config_DeviceConfig* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_device();
    _impl_.payload_variant_.device_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.Config.device)
}
inline ::meshtastic::Config_DeviceConfig* PROTOBUF_NONNULL Config::_internal_mutable_device() {
  if (payload_variant_case() != kDevice) {
    clear_payload_variant();
    set_has_device();
    _impl_.payload_variant_.device_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::Config_DeviceConfig>(GetArena()));
  }
  return reinterpret_cast<::meshtastic::Config_DeviceConfig*>(_impl_.payload_variant_.device_);
}
inline ::meshtastic::Config_DeviceConfig* PROTOBUF_NONNULL Config::mutable_device()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::Config_DeviceConfig* _msg = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:meshtastic.Config.device)
  return _msg;
}

// .meshtastic.Config.PositionConfig position = 2;
inline bool Config::has_position() const {
  return payload_variant_case() == kPosition;
}
inline bool Config::_internal_has_position() const {
  return payload_variant_case() == kPosition;
}
inline void Config::set_has_position() {
  _impl_._oneof_case_[0] = kPosition;
}
inline void Config::clear_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kPosition) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_variant_.position_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.position_);
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::Config_PositionConfig* PROTOBUF_NULLABLE Config::release_position() {
  // @@protoc_insertion_point(field_release:meshtastic.Config.position)
  if (payload_variant_case() == kPosition) {
    clear_has_payload_variant();
    auto* temp = reinterpret_cast<::meshtastic::Config_PositionConfig*>(_impl_.payload_variant_.position_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.position_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::Config_PositionConfig& Config::_internal_position() const {
  return payload_variant_case() == kPosition ? *reinterpret_cast<::meshtastic::Config_PositionConfig*>(_impl_.payload_variant_.position_) : reinterpret_cast<::meshtastic::Config_PositionConfig&>(::meshtastic::_Config_PositionConfig_default_instance_);
}
inline const ::meshtastic::Config_PositionConfig& Config::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.Config.position)
  return _internal_position();
}
inline ::meshtastic::Config_PositionConfig* PROTOBUF_NULLABLE Config::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.Config.position)
  if (payload_variant_case() == kPosition) {
    clear_has_payload_variant();
    auto* temp = reinterpret_cast<::meshtastic::Config_PositionConfig*>(_impl_.payload_variant_.position_);
    _impl_.payload_variant_.position_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Config::unsafe_arena_set_allocated_position(
    ::meshtastic::Config_PositionConfig* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_position();
    _impl_.payload_variant_.position_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.Config.position)
}
inline ::meshtastic::Config_PositionConfig* PROTOBUF_NONNULL Config::_internal_mutable_position() {
  if (payload_variant_case() != kPosition) {
    clear_payload_variant();
    set_has_position();
    _impl_.payload_variant_.position_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::Config_PositionConfig>(GetArena()));
  }
  return reinterpret_cast<::meshtastic::Config_PositionConfig*>(_impl_.payload_variant_.position_);
}
inline ::meshtastic::Config_PositionConfig* PROTOBUF_NONNULL Config::mutable_position()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::Config_PositionConfig* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:meshtastic.Config.position)
  return _msg;
}

// .meshtastic.Config.PowerConfig power = 3;
inline bool Config::has_power() const {
  return payload_variant_case() == kPower;
}
inline bool Config::_internal_has_power() const {
  return payload_variant_case() == kPower;
}
inline void Config::set_has_power() {
  _impl_._oneof_case_[0] = kPower;
}
inline void Config::clear_power() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kPower) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_variant_.power_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.power_);
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::Config_PowerConfig* PROTOBUF_NULLABLE Config::release_power() {
  // @@protoc_insertion_point(field_release:meshtastic.Config.power)
  if (payload_variant_case() == kPower) {
    clear_has_payload_variant();
    auto* temp = reinterpret_cast<::meshtastic::Config_PowerConfig*>(_impl_.payload_variant_.power_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.power_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::Config_PowerConfig& Config::_internal_power() const {
  return payload_variant_case() == kPower ? *reinterpret_cast<::meshtastic::Config_PowerConfig*>(_impl_.payload_variant_.power_) : reinterpret_cast<::meshtastic::Config_PowerConfig&>(::meshtastic::_Config_PowerConfig_default_instance_);
}
inline const ::meshtastic::Config_PowerConfig& Config::power() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.Config.power)
  return _internal_power();
}
inline ::meshtastic::Config_PowerConfig* PROTOBUF_NULLABLE Config::unsafe_arena_release_power() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.Config.power)
  if (payload_variant_case() == kPower) {
    clear_has_payload_variant();
    auto* temp = reinterpret_cast<::meshtastic::Config_PowerConfig*>(_impl_.payload_variant_.power_);
    _impl_.payload_variant_.power_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Config::unsafe_arena_set_allocated_power(
    ::meshtastic::Config_PowerConfig* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_power();
    _impl_.payload_variant_.power_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.Config.power)
}
inline ::meshtastic::Config_PowerConfig* PROTOBUF_NONNULL Config::_internal_mutable_power() {
  if (payload_variant_case() != kPower) {
    clear_payload_variant();
    set_has_power();
    _impl_.payload_variant_.power_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::Config_PowerConfig>(GetArena()));
  }
  return reinterpret_cast<::meshtastic::Config_PowerConfig*>(_impl_.payload_variant_.power_);
}
inline ::meshtastic::Config_PowerConfig* PROTOBUF_NONNULL Config::mutable_power()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::Config_PowerConfig* _msg = _internal_mutable_power();
  // @@protoc_insertion_point(field_mutable:meshtastic.Config.power)
  return _msg;
}

// .meshtastic.Config.NetworkConfig network = 4;
inline bool Config::has_network() const {
  return payload_variant_case() == kNetwork;
}
inline bool Config::_internal_has_network() const {
  return payload_variant_case() == kNetwork;
}
inline void Config::set_has_network() {
  _impl_._oneof_case_[0] = kNetwork;
}
inline void Config::clear_network() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kNetwork) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_variant_.network_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.network_);
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::Config_NetworkConfig* PROTOBUF_NULLABLE Config::release_network() {
  // @@protoc_insertion_point(field_release:meshtastic.Config.network)
  if (payload_variant_case() == kNetwork) {
    clear_has_payload_variant();
    auto* temp = reinterpret_cast<::meshtastic::Config_NetworkConfig*>(_impl_.payload_variant_.network_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.network_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::Config_NetworkConfig& Config::_internal_network() const {
  return payload_variant_case() == kNetwork ? *reinterpret_cast<::meshtastic::Config_NetworkConfig*>(_impl_.payload_variant_.network_) : reinterpret_cast<::meshtastic::Config_NetworkConfig&>(::meshtastic::_Config_NetworkConfig_default_instance_);
}
inline const ::meshtastic::Config_NetworkConfig& Config::network() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.Config.network)
  return _internal_network();
}
inline ::meshtastic::Config_NetworkConfig* PROTOBUF_NULLABLE Config::unsafe_arena_release_network() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.Config.network)
  if (payload_variant_case() == kNetwork) {
    clear_has_payload_variant();
    auto* temp = reinterpret_cast<::meshtastic::Config_NetworkConfig*>(_impl_.payload_variant_.network_);
    _impl_.payload_variant_.network_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Config::unsafe_arena_set_allocated_network(
    ::meshtastic::Config_NetworkConfig* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_network();
    _impl_.payload_variant_.network_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.Config.network)
}
inline ::meshtastic::Config_NetworkConfig* PROTOBUF_NONNULL Config::_internal_mutable_network() {
  if (payload_variant_case() != kNetwork) {
    clear_payload_variant();
    set_has_network();
    _impl_.payload_variant_.network_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::Config_NetworkConfig>(GetArena()));
  }
  return reinterpret_cast<::meshtastic::Config_NetworkConfig*>(_impl_.payload_variant_.network_);
}
inline ::meshtastic::Config_NetworkConfig* PROTOBUF_NONNULL Config::mutable_network()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::Config_NetworkConfig* _msg = _internal_mutable_network();
  // @@protoc_insertion_point(field_mutable:meshtastic.Config.network)
  return _msg;
}

// .meshtastic.Config.DisplayConfig display = 5;
inline bool Config::has_display() const {
  return payload_variant_case() == kDisplay;
}
inline bool Config::_internal_has_display() const {
  return payload_variant_case() == kDisplay;
}
inline void Config::set_has_display() {
  _impl_._oneof_case_[0] = kDisplay;
}
inline void Config::clear_display() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kDisplay) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_variant_.display_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.display_);
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::Config_DisplayConfig* PROTOBUF_NULLABLE Config::release_display() {
  // @@protoc_insertion_point(field_release:meshtastic.Config.display)
  if (payload_variant_case() == kDisplay) {
    clear_has_payload_variant();
    auto* temp = reinterpret_cast<::meshtastic::Config_DisplayConfig*>(_impl_.payload_variant_.display_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.display_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::Config_DisplayConfig& Config::_internal_display() const {
  return payload_variant_case() == kDisplay ? *reinterpret_cast<::meshtastic::Config_DisplayConfig*>(_impl_.payload_variant_.display_) : reinterpret_cast<::meshtastic::Config_DisplayConfig&>(::meshtastic::_Config_DisplayConfig_default_instance_);
}
inline const ::meshtastic::Config_DisplayConfig& Config::display() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.Config.display)
  return _internal_display();
}
inline ::meshtastic::Config_DisplayConfig* PROTOBUF_NULLABLE Config::unsafe_arena_release_display() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.Config.display)
  if (payload_variant_case() == kDisplay) {
    clear_has_payload_variant();
    auto* temp = reinterpret_cast<::meshtastic::Config_DisplayConfig*>(_impl_.payload_variant_.display_);
    _impl_.payload_variant_.display_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Config::unsafe_arena_set_allocated_display(
    ::meshtastic::Config_DisplayConfig* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_display();
    _impl_.payload_variant_.display_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.Config.display)
}
inline ::meshtastic::Config_DisplayConfig* PROTOBUF_NONNULL Config::_internal_mutable_display() {
  if (payload_variant_case() != kDisplay) {
    clear_payload_variant();
    set_has_display();
    _impl_.payload_variant_.display_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::Config_DisplayConfig>(GetArena()));
  }
  return reinterpret_cast<::meshtastic::Config_DisplayConfig*>(_impl_.payload_variant_.display_);
}
inline ::meshtastic::Config_DisplayConfig* PROTOBUF_NONNULL Config::mutable_display()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::Config_DisplayConfig* _msg = _internal_mutable_display();
  // @@protoc_insertion_point(field_mutable:meshtastic.Config.display)
  return _msg;
}

// .meshtastic.Config.LoRaConfig lora = 6;
inline bool Config::has_lora() const {
  return payload_variant_case() == kLora;
}
inline bool Config::_internal_has_lora() const {
  return payload_variant_case() == kLora;
}
inline void Config::set_has_lora() {
  _impl_._oneof_case_[0] = kLora;
}
inline void Config::clear_lora() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kLora) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_variant_.lora_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.lora_);
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::Config_LoRaConfig* PROTOBUF_NULLABLE Config::release_lora() {
  // @@protoc_insertion_point(field_release:meshtastic.Config.lora)
  if (payload_variant_case() == kLora) {
    clear_has_payload_variant();
    auto* temp = reinterpret_cast<::meshtastic::Config_LoRaConfig*>(_impl_.payload_variant_.lora_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.lora_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::Config_LoRaConfig& Config::_internal_lora() const {
  return payload_variant_case() == kLora ? *reinterpret_cast<::meshtastic::Config_LoRaConfig*>(_impl_.payload_variant_.lora_) : reinterpret_cast<::meshtastic::Config_LoRaConfig&>(::meshtastic::_Config_LoRaConfig_default_instance_);
}
inline const ::meshtastic::Config_LoRaConfig& Config::lora() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.Config.lora)
  return _internal_lora();
}
inline ::meshtastic::Config_LoRaConfig* PROTOBUF_NULLABLE Config::unsafe_arena_release_lora() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.Config.lora)
  if (payload_variant_case() == kLora) {
    clear_has_payload_variant();
    auto* temp = reinterpret_cast<::meshtastic::Config_LoRaConfig*>(_impl_.payload_variant_.lora_);
    _impl_.payload_variant_.lora_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Config::unsafe_arena_set_allocated_lora(
    ::meshtastic::Config_LoRaConfig* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_lora();
    _impl_.payload_variant_.lora_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.Config.lora)
}
inline ::meshtastic::Config_LoRaConfig* PROTOBUF_NONNULL Config::_internal_mutable_lora() {
  if (payload_variant_case() != kLora) {
    clear_payload_variant();
    set_has_lora();
    _impl_.payload_variant_.lora_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::Config_LoRaConfig>(GetArena()));
  }
  return reinterpret_cast<::meshtastic::Config_LoRaConfig*>(_impl_.payload_variant_.lora_);
}
inline ::meshtastic::Config_LoRaConfig* PROTOBUF_NONNULL Config::mutable_lora()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::Config_LoRaConfig* _msg = _internal_mutable_lora();
  // @@protoc_insertion_point(field_mutable:meshtastic.Config.lora)
  return _msg;
}

// .meshtastic.Config.BluetoothConfig bluetooth = 7;
inline bool Config::has_bluetooth() const {
  return payload_variant_case() == kBluetooth;
}
inline bool Config::_internal_has_bluetooth() const {
  return payload_variant_case() == kBluetooth;
}
inline void Config::set_has_bluetooth() {
  _impl_._oneof_case_[0] = kBluetooth;
}
inline void Config::clear_bluetooth() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kBluetooth) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_variant_.bluetooth_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.bluetooth_);
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::Config_BluetoothConfig* PROTOBUF_NULLABLE Config::release_bluetooth() {
  // @@protoc_insertion_point(field_release:meshtastic.Config.bluetooth)
  if (payload_variant_case() == kBluetooth) {
    clear_has_payload_variant();
    auto* temp = reinterpret_cast<::meshtastic::Config_BluetoothConfig*>(_impl_.payload_variant_.bluetooth_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.bluetooth_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::Config_BluetoothConfig& Config::_internal_bluetooth() const {
  return payload_variant_case() == kBluetooth ? *reinterpret_cast<::meshtastic::Config_BluetoothConfig*>(_impl_.payload_variant_.bluetooth_) : reinterpret_cast<::meshtastic::Config_BluetoothConfig&>(::meshtastic::_Config_BluetoothConfig_default_instance_);
}
inline const ::meshtastic::Config_BluetoothConfig& Config::bluetooth() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.Config.bluetooth)
  return _internal_bluetooth();
}
inline ::meshtastic::Config_BluetoothConfig* PROTOBUF_NULLABLE Config::unsafe_arena_release_bluetooth() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.Config.bluetooth)
  if (payload_variant_case() == kBluetooth) {
    clear_has_payload_variant();
    auto* temp = reinterpret_cast<::meshtastic::Config_BluetoothConfig*>(_impl_.payload_variant_.bluetooth_);
    _impl_.payload_variant_.bluetooth_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Config::unsafe_arena_set_allocated_bluetooth(
    ::meshtastic::Config_BluetoothConfig* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_bluetooth();
    _impl_.payload_variant_.bluetooth_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.Config.bluetooth)
}
inline ::meshtastic::Config_BluetoothConfig* PROTOBUF_NONNULL Config::_internal_mutable_bluetooth() {
  if (payload_variant_case() != kBluetooth) {
    clear_payload_variant();
    set_has_bluetooth();
    _impl_.payload_variant_.bluetooth_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::Config_BluetoothConfig>(GetArena()));
  }
  return reinterpret_cast<::meshtastic::Config_BluetoothConfig*>(_impl_.payload_variant_.bluetooth_);
}
inline ::meshtastic::Config_BluetoothConfig* PROTOBUF_NONNULL Config::mutable_bluetooth()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::Config_BluetoothConfig* _msg = _internal_mutable_bluetooth();
  // @@protoc_insertion_point(field_mutable:meshtastic.Config.bluetooth)
  return _msg;
}

// .meshtastic.Config.SecurityConfig security = 8;
inline bool Config::has_security() const {
  return payload_variant_case() == kSecurity;
}
inline bool Config::_internal_has_security() const {
  return payload_variant_case() == kSecurity;
}
inline void Config::set_has_security() {
  _impl_._oneof_case_[0] = kSecurity;
}
inline void Config::clear_security() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kSecurity) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_variant_.security_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.security_);
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::Config_SecurityConfig* PROTOBUF_NULLABLE Config::release_security() {
  // @@protoc_insertion_point(field_release:meshtastic.Config.security)
  if (payload_variant_case() == kSecurity) {
    clear_has_payload_variant();
    auto* temp = reinterpret_cast<::meshtastic::Config_SecurityConfig*>(_impl_.payload_variant_.security_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.security_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::Config_SecurityConfig& Config::_internal_security() const {
  return payload_variant_case() == kSecurity ? *reinterpret_cast<::meshtastic::Config_SecurityConfig*>(_impl_.payload_variant_.security_) : reinterpret_cast<::meshtastic::Config_SecurityConfig&>(::meshtastic::_Config_SecurityConfig_default_instance_);
}
inline const ::meshtastic::Config_SecurityConfig& Config::security() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.Config.security)
  return _internal_security();
}
inline ::meshtastic::Config_SecurityConfig* PROTOBUF_NULLABLE Config::unsafe_arena_release_security() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.Config.security)
  if (payload_variant_case() == kSecurity) {
    clear_has_payload_variant();
    auto* temp = reinterpret_cast<::meshtastic::Config_SecurityConfig*>(_impl_.payload_variant_.security_);
    _impl_.payload_variant_.security_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Config::unsafe_arena_set_allocated_security(
    ::meshtastic::Config_SecurityConfig* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_security();
    _impl_.payload_variant_.security_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.Config.security)
}
inline ::meshtastic::Config_SecurityConfig* PROTOBUF_NONNULL Config::_internal_mutable_security() {
  if (payload_variant_case() != kSecurity) {
    clear_payload_variant();
    set_has_security();
    _impl_.payload_variant_.security_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::Config_SecurityConfig>(GetArena()));
  }
  return reinterpret_cast<::meshtastic::Config_SecurityConfig*>(_impl_.payload_variant_.security_);
}
inline ::meshtastic::Config_SecurityConfig* PROTOBUF_NONNULL Config::mutable_security()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::Config_SecurityConfig* _msg = _internal_mutable_security();
  // @@protoc_insertion_point(field_mutable:meshtastic.Config.security)
  return _msg;
}

// .meshtastic.Config.SessionkeyConfig sessionkey = 9;
inline bool Config::has_sessionkey() const {
  return payload_variant_case() == kSessionkey;
}
inline bool Config::_internal_has_sessionkey() const {
  return payload_variant_case() == kSessionkey;
}
inline void Config::set_has_sessionkey() {
  _impl_._oneof_case_[0] = kSessionkey;
}
inline void Config::clear_sessionkey() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kSessionkey) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_variant_.sessionkey_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.sessionkey_);
    }
    clear_has_payload_variant();
  }
}
inline ::meshtastic::Config_SessionkeyConfig* PROTOBUF_NULLABLE Config::release_sessionkey() {
  // @@protoc_insertion_point(field_release:meshtastic.Config.sessionkey)
  if (payload_variant_case() == kSessionkey) {
    clear_has_payload_variant();
    auto* temp = reinterpret_cast<::meshtastic::Config_SessionkeyConfig*>(_impl_.payload_variant_.sessionkey_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.sessionkey_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::Config_SessionkeyConfig& Config::_internal_sessionkey() const {
  return payload_variant_case() == kSessionkey ? *reinterpret_cast<::meshtastic::Config_SessionkeyConfig*>(_impl_.payload_variant_.sessionkey_) : reinterpret_cast<::meshtastic::Config_SessionkeyConfig&>(::meshtastic::_Config_SessionkeyConfig_default_instance_);
}
inline const ::meshtastic::Config_SessionkeyConfig& Config::sessionkey() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.Config.sessionkey)
  return _internal_sessionkey();
}
inline ::meshtastic::Config_SessionkeyConfig* PROTOBUF_NULLABLE Config::unsafe_arena_release_sessionkey() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.Config.sessionkey)
  if (payload_variant_case() == kSessionkey) {
    clear_has_payload_variant();
    auto* temp = reinterpret_cast<::meshtastic::Config_SessionkeyConfig*>(_impl_.payload_variant_.sessionkey_);
    _impl_.payload_variant_.sessionkey_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Config::unsafe_arena_set_allocated_sessionkey(
    ::meshtastic::Config_SessionkeyConfig* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_sessionkey();
    _impl_.payload_variant_.sessionkey_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.Config.sessionkey)
}
inline ::meshtastic::Config_SessionkeyConfig* PROTOBUF_NONNULL Config::_internal_mutable_sessionkey() {
  if (payload_variant_case() != kSessionkey) {
    clear_payload_variant();
    set_has_sessionkey();
    _impl_.payload_variant_.sessionkey_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::Config_SessionkeyConfig>(GetArena()));
  }
  return reinterpret_cast<::meshtastic::Config_SessionkeyConfig*>(_impl_.payload_variant_.sessionkey_);
}
inline ::meshtastic::Config_SessionkeyConfig* PROTOBUF_NONNULL Config::mutable_sessionkey()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::Config_SessionkeyConfig* _msg = _internal_mutable_sessionkey();
  // @@protoc_insertion_point(field_mutable:meshtastic.Config.sessionkey)
  return _msg;
}

// .meshtastic.DeviceUIConfig device_ui = 10;
inline bool Config::has_device_ui() const {
  return payload_variant_case() == kDeviceUi;
}
inline bool Config::_internal_has_device_ui() const {
  return payload_variant_case() == kDeviceUi;
}
inline void Config::set_has_device_ui() {
  _impl_._oneof_case_[0] = kDeviceUi;
}
inline ::meshtastic::DeviceUIConfig* PROTOBUF_NULLABLE Config::release_device_ui() {
  // @@protoc_insertion_point(field_release:meshtastic.Config.device_ui)
  if (payload_variant_case() == kDeviceUi) {
    clear_has_payload_variant();
    auto* temp = reinterpret_cast<::meshtastic::DeviceUIConfig*>(_impl_.payload_variant_.device_ui_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_variant_.device_ui_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::meshtastic::DeviceUIConfig& Config::_internal_device_ui() const {
  return payload_variant_case() == kDeviceUi ? *reinterpret_cast<::meshtastic::DeviceUIConfig*>(_impl_.payload_variant_.device_ui_) : reinterpret_cast<::meshtastic::DeviceUIConfig&>(::meshtastic::_DeviceUIConfig_default_instance_);
}
inline const ::meshtastic::DeviceUIConfig& Config::device_ui() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.Config.device_ui)
  return _internal_device_ui();
}
inline ::meshtastic::DeviceUIConfig* PROTOBUF_NULLABLE Config::unsafe_arena_release_device_ui() {
  // @@protoc_insertion_point(field_unsafe_arena_release:meshtastic.Config.device_ui)
  if (payload_variant_case() == kDeviceUi) {
    clear_has_payload_variant();
    auto* temp = reinterpret_cast<::meshtastic::DeviceUIConfig*>(_impl_.payload_variant_.device_ui_);
    _impl_.payload_variant_.device_ui_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Config::unsafe_arena_set_allocated_device_ui(
    ::meshtastic::DeviceUIConfig* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload_variant();
  if (value) {
    set_has_device_ui();
    _impl_.payload_variant_.device_ui_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.Config.device_ui)
}
inline ::meshtastic::DeviceUIConfig* PROTOBUF_NONNULL Config::_internal_mutable_device_ui() {
  if (payload_variant_case() != kDeviceUi) {
    clear_payload_variant();
    set_has_device_ui();
    _impl_.payload_variant_.device_ui_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::meshtastic::DeviceUIConfig>(GetArena()));
  }
  return reinterpret_cast<::meshtastic::DeviceUIConfig*>(_impl_.payload_variant_.device_ui_);
}
inline ::meshtastic::DeviceUIConfig* PROTOBUF_NONNULL Config::mutable_device_ui()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::meshtastic::DeviceUIConfig* _msg = _internal_mutable_device_ui();
  // @@protoc_insertion_point(field_mutable:meshtastic.Config.device_ui)
  return _msg;
}

inline bool Config::has_payload_variant() const {
  return payload_variant_case() != PAYLOAD_VARIANT_NOT_SET;
}
inline void Config::clear_has_payload_variant() {
  _impl_._oneof_case_[0] = PAYLOAD_VARIANT_NOT_SET;
}
inline Config::PayloadVariantCase Config::payload_variant_case() const {
  return Config::PayloadVariantCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace meshtastic


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::meshtastic::Config_DeviceConfig_Role> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::meshtastic::Config_DeviceConfig_Role>() {
  return ::meshtastic::Config_DeviceConfig_Role_descriptor();
}
template <>
struct is_proto_enum<::meshtastic::Config_DeviceConfig_RebroadcastMode> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::meshtastic::Config_DeviceConfig_RebroadcastMode>() {
  return ::meshtastic::Config_DeviceConfig_RebroadcastMode_descriptor();
}
template <>
struct is_proto_enum<::meshtastic::Config_DeviceConfig_BuzzerMode> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::meshtastic::Config_DeviceConfig_BuzzerMode>() {
  return ::meshtastic::Config_DeviceConfig_BuzzerMode_descriptor();
}
template <>
struct is_proto_enum<::meshtastic::Config_PositionConfig_PositionFlags> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::meshtastic::Config_PositionConfig_PositionFlags>() {
  return ::meshtastic::Config_PositionConfig_PositionFlags_descriptor();
}
template <>
struct is_proto_enum<::meshtastic::Config_PositionConfig_GpsMode> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::meshtastic::Config_PositionConfig_GpsMode>() {
  return ::meshtastic::Config_PositionConfig_GpsMode_descriptor();
}
template <>
struct is_proto_enum<::meshtastic::Config_NetworkConfig_AddressMode> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::meshtastic::Config_NetworkConfig_AddressMode>() {
  return ::meshtastic::Config_NetworkConfig_AddressMode_descriptor();
}
template <>
struct is_proto_enum<::meshtastic::Config_NetworkConfig_ProtocolFlags> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::meshtastic::Config_NetworkConfig_ProtocolFlags>() {
  return ::meshtastic::Config_NetworkConfig_ProtocolFlags_descriptor();
}
template <>
struct is_proto_enum<::meshtastic::Config_DisplayConfig_GpsCoordinateFormat> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::meshtastic::Config_DisplayConfig_GpsCoordinateFormat>() {
  return ::meshtastic::Config_DisplayConfig_GpsCoordinateFormat_descriptor();
}
template <>
struct is_proto_enum<::meshtastic::Config_DisplayConfig_DisplayUnits> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::meshtastic::Config_DisplayConfig_DisplayUnits>() {
  return ::meshtastic::Config_DisplayConfig_DisplayUnits_descriptor();
}
template <>
struct is_proto_enum<::meshtastic::Config_DisplayConfig_OledType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::meshtastic::Config_DisplayConfig_OledType>() {
  return ::meshtastic::Config_DisplayConfig_OledType_descriptor();
}
template <>
struct is_proto_enum<::meshtastic::Config_DisplayConfig_DisplayMode> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::meshtastic::Config_DisplayConfig_DisplayMode>() {
  return ::meshtastic::Config_DisplayConfig_DisplayMode_descriptor();
}
template <>
struct is_proto_enum<::meshtastic::Config_DisplayConfig_CompassOrientation> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::meshtastic::Config_DisplayConfig_CompassOrientation>() {
  return ::meshtastic::Config_DisplayConfig_CompassOrientation_descriptor();
}
template <>
struct is_proto_enum<::meshtastic::Config_LoRaConfig_RegionCode> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::meshtastic::Config_LoRaConfig_RegionCode>() {
  return ::meshtastic::Config_LoRaConfig_RegionCode_descriptor();
}
template <>
struct is_proto_enum<::meshtastic::Config_LoRaConfig_ModemPreset> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::meshtastic::Config_LoRaConfig_ModemPreset>() {
  return ::meshtastic::Config_LoRaConfig_ModemPreset_descriptor();
}
template <>
struct is_proto_enum<::meshtastic::Config_BluetoothConfig_PairingMode> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::meshtastic::Config_BluetoothConfig_PairingMode>() {
  return ::meshtastic::Config_BluetoothConfig_PairingMode_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // meshtastic_2fconfig_2eproto_2epb_2eh
