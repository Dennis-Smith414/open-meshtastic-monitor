// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: meshtastic/deviceonly.proto
// Protobuf C++ Version: 6.32.0

#ifndef meshtastic_2fdeviceonly_2eproto_2epb_2eh
#define meshtastic_2fdeviceonly_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6032000
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "meshtastic/channel.pb.h"
#include "meshtastic/config.pb.h"
#include "meshtastic/localonly.pb.h"
#include "meshtastic/mesh.pb.h"
#include "meshtastic/telemetry.pb.h"
#include "nanopb.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_meshtastic_2fdeviceonly_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_meshtastic_2fdeviceonly_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable descriptor_table_meshtastic_2fdeviceonly_2eproto;
}  // extern "C"
namespace meshtastic {
class BackupPreferences;
struct BackupPreferencesDefaultTypeInternal;
extern BackupPreferencesDefaultTypeInternal _BackupPreferences_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull BackupPreferences_class_data_;
class ChannelFile;
struct ChannelFileDefaultTypeInternal;
extern ChannelFileDefaultTypeInternal _ChannelFile_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ChannelFile_class_data_;
class DeviceState;
struct DeviceStateDefaultTypeInternal;
extern DeviceStateDefaultTypeInternal _DeviceState_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DeviceState_class_data_;
class NodeDatabase;
struct NodeDatabaseDefaultTypeInternal;
extern NodeDatabaseDefaultTypeInternal _NodeDatabase_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull NodeDatabase_class_data_;
class NodeInfoLite;
struct NodeInfoLiteDefaultTypeInternal;
extern NodeInfoLiteDefaultTypeInternal _NodeInfoLite_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull NodeInfoLite_class_data_;
class PositionLite;
struct PositionLiteDefaultTypeInternal;
extern PositionLiteDefaultTypeInternal _PositionLite_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PositionLite_class_data_;
class UserLite;
struct UserLiteDefaultTypeInternal;
extern UserLiteDefaultTypeInternal _UserLite_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull UserLite_class_data_;
}  // namespace meshtastic
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace meshtastic {

// ===================================================================


// -------------------------------------------------------------------

class UserLite final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.UserLite) */ {
 public:
  inline UserLite() : UserLite(nullptr) {}
  ~UserLite() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UserLite* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UserLite));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UserLite(::google::protobuf::internal::ConstantInitialized);

  inline UserLite(const UserLite& from) : UserLite(nullptr, from) {}
  inline UserLite(UserLite&& from) noexcept
      : UserLite(nullptr, ::std::move(from)) {}
  inline UserLite& operator=(const UserLite& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserLite& operator=(UserLite&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserLite& default_instance() {
    return *reinterpret_cast<const UserLite*>(
        &_UserLite_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(UserLite& a, UserLite& b) { a.Swap(&b); }
  inline void Swap(UserLite* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserLite* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserLite* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UserLite>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserLite& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UserLite& from) { UserLite::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UserLite* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.UserLite"; }

 protected:
  explicit UserLite(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  UserLite(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const UserLite& from);
  UserLite(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, UserLite&& from) noexcept
      : UserLite(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMacaddrFieldNumber = 1,
    kLongNameFieldNumber = 2,
    kShortNameFieldNumber = 3,
    kPublicKeyFieldNumber = 7,
    kHwModelFieldNumber = 4,
    kRoleFieldNumber = 6,
    kIsLicensedFieldNumber = 5,
    kIsUnmessagableFieldNumber = 9,
  };
  // bytes macaddr = 1 [deprecated = true];
  [[deprecated]]  void clear_macaddr() ;
  [[deprecated]] const ::std::string& macaddr() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  [[deprecated]] void set_macaddr(Arg_&& arg, Args_... args);
  [[deprecated]] ::std::string* PROTOBUF_NONNULL mutable_macaddr();
  [[deprecated]] [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_macaddr();
  [[deprecated]] void set_allocated_macaddr(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_macaddr() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_macaddr(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_macaddr();

  public:
  // string long_name = 2;
  void clear_long_name() ;
  const ::std::string& long_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_long_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_long_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_long_name();
  void set_allocated_long_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_long_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_long_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_long_name();

  public:
  // string short_name = 3;
  void clear_short_name() ;
  const ::std::string& short_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_short_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_short_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_short_name();
  void set_allocated_short_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_short_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_short_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_short_name();

  public:
  // bytes public_key = 7;
  void clear_public_key() ;
  const ::std::string& public_key() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_public_key(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_public_key();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_public_key();
  void set_allocated_public_key(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_public_key() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_public_key(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_public_key();

  public:
  // .meshtastic.HardwareModel hw_model = 4;
  void clear_hw_model() ;
  ::meshtastic::HardwareModel hw_model() const;
  void set_hw_model(::meshtastic::HardwareModel value);

  private:
  ::meshtastic::HardwareModel _internal_hw_model() const;
  void _internal_set_hw_model(::meshtastic::HardwareModel value);

  public:
  // .meshtastic.Config.DeviceConfig.Role role = 6;
  void clear_role() ;
  ::meshtastic::Config_DeviceConfig_Role role() const;
  void set_role(::meshtastic::Config_DeviceConfig_Role value);

  private:
  ::meshtastic::Config_DeviceConfig_Role _internal_role() const;
  void _internal_set_role(::meshtastic::Config_DeviceConfig_Role value);

  public:
  // bool is_licensed = 5;
  void clear_is_licensed() ;
  bool is_licensed() const;
  void set_is_licensed(bool value);

  private:
  bool _internal_is_licensed() const;
  void _internal_set_is_licensed(bool value);

  public:
  // optional bool is_unmessagable = 9;
  bool has_is_unmessagable() const;
  void clear_is_unmessagable() ;
  bool is_unmessagable() const;
  void set_is_unmessagable(bool value);

  private:
  bool _internal_is_unmessagable() const;
  void _internal_set_is_unmessagable(bool value);

  public:
  // @@protoc_insertion_point(class_scope:meshtastic.UserLite)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 8,
                                   0, 55,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const UserLite& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr macaddr_;
    ::google::protobuf::internal::ArenaStringPtr long_name_;
    ::google::protobuf::internal::ArenaStringPtr short_name_;
    ::google::protobuf::internal::ArenaStringPtr public_key_;
    int hw_model_;
    int role_;
    bool is_licensed_;
    bool is_unmessagable_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fdeviceonly_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull UserLite_class_data_;
// -------------------------------------------------------------------

class PositionLite final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.PositionLite) */ {
 public:
  inline PositionLite() : PositionLite(nullptr) {}
  ~PositionLite() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PositionLite* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PositionLite));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PositionLite(::google::protobuf::internal::ConstantInitialized);

  inline PositionLite(const PositionLite& from) : PositionLite(nullptr, from) {}
  inline PositionLite(PositionLite&& from) noexcept
      : PositionLite(nullptr, ::std::move(from)) {}
  inline PositionLite& operator=(const PositionLite& from) {
    CopyFrom(from);
    return *this;
  }
  inline PositionLite& operator=(PositionLite&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PositionLite& default_instance() {
    return *reinterpret_cast<const PositionLite*>(
        &_PositionLite_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(PositionLite& a, PositionLite& b) { a.Swap(&b); }
  inline void Swap(PositionLite* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PositionLite* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PositionLite* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PositionLite>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PositionLite& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PositionLite& from) { PositionLite::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PositionLite* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.PositionLite"; }

 protected:
  explicit PositionLite(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PositionLite(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PositionLite& from);
  PositionLite(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PositionLite&& from) noexcept
      : PositionLite(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLatitudeIFieldNumber = 1,
    kLongitudeIFieldNumber = 2,
    kAltitudeFieldNumber = 3,
    kTimeFieldNumber = 4,
    kLocationSourceFieldNumber = 5,
  };
  // sfixed32 latitude_i = 1;
  void clear_latitude_i() ;
  ::int32_t latitude_i() const;
  void set_latitude_i(::int32_t value);

  private:
  ::int32_t _internal_latitude_i() const;
  void _internal_set_latitude_i(::int32_t value);

  public:
  // sfixed32 longitude_i = 2;
  void clear_longitude_i() ;
  ::int32_t longitude_i() const;
  void set_longitude_i(::int32_t value);

  private:
  ::int32_t _internal_longitude_i() const;
  void _internal_set_longitude_i(::int32_t value);

  public:
  // int32 altitude = 3;
  void clear_altitude() ;
  ::int32_t altitude() const;
  void set_altitude(::int32_t value);

  private:
  ::int32_t _internal_altitude() const;
  void _internal_set_altitude(::int32_t value);

  public:
  // fixed32 time = 4;
  void clear_time() ;
  ::uint32_t time() const;
  void set_time(::uint32_t value);

  private:
  ::uint32_t _internal_time() const;
  void _internal_set_time(::uint32_t value);

  public:
  // .meshtastic.Position.LocSource location_source = 5;
  void clear_location_source() ;
  ::meshtastic::Position_LocSource location_source() const;
  void set_location_source(::meshtastic::Position_LocSource value);

  private:
  ::meshtastic::Position_LocSource _internal_location_source() const;
  void _internal_set_location_source(::meshtastic::Position_LocSource value);

  public:
  // @@protoc_insertion_point(class_scope:meshtastic.PositionLite)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PositionLite& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t latitude_i_;
    ::int32_t longitude_i_;
    ::int32_t altitude_;
    ::uint32_t time_;
    int location_source_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fdeviceonly_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PositionLite_class_data_;
// -------------------------------------------------------------------

class NodeInfoLite final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.NodeInfoLite) */ {
 public:
  inline NodeInfoLite() : NodeInfoLite(nullptr) {}
  ~NodeInfoLite() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(NodeInfoLite* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(NodeInfoLite));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NodeInfoLite(::google::protobuf::internal::ConstantInitialized);

  inline NodeInfoLite(const NodeInfoLite& from) : NodeInfoLite(nullptr, from) {}
  inline NodeInfoLite(NodeInfoLite&& from) noexcept
      : NodeInfoLite(nullptr, ::std::move(from)) {}
  inline NodeInfoLite& operator=(const NodeInfoLite& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeInfoLite& operator=(NodeInfoLite&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeInfoLite& default_instance() {
    return *reinterpret_cast<const NodeInfoLite*>(
        &_NodeInfoLite_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(NodeInfoLite& a, NodeInfoLite& b) { a.Swap(&b); }
  inline void Swap(NodeInfoLite* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeInfoLite* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeInfoLite* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<NodeInfoLite>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NodeInfoLite& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NodeInfoLite& from) { NodeInfoLite::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(NodeInfoLite* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.NodeInfoLite"; }

 protected:
  explicit NodeInfoLite(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  NodeInfoLite(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const NodeInfoLite& from);
  NodeInfoLite(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, NodeInfoLite&& from) noexcept
      : NodeInfoLite(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUserFieldNumber = 2,
    kPositionFieldNumber = 3,
    kDeviceMetricsFieldNumber = 6,
    kNumFieldNumber = 1,
    kSnrFieldNumber = 4,
    kLastHeardFieldNumber = 5,
    kChannelFieldNumber = 7,
    kHopsAwayFieldNumber = 9,
    kViaMqttFieldNumber = 8,
    kIsFavoriteFieldNumber = 10,
    kIsIgnoredFieldNumber = 11,
    kNextHopFieldNumber = 12,
    kBitfieldFieldNumber = 13,
  };
  // .meshtastic.UserLite user = 2;
  bool has_user() const;
  void clear_user() ;
  const ::meshtastic::UserLite& user() const;
  [[nodiscard]] ::meshtastic::UserLite* PROTOBUF_NULLABLE release_user();
  ::meshtastic::UserLite* PROTOBUF_NONNULL mutable_user();
  void set_allocated_user(::meshtastic::UserLite* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_user(::meshtastic::UserLite* PROTOBUF_NULLABLE value);
  ::meshtastic::UserLite* PROTOBUF_NULLABLE unsafe_arena_release_user();

  private:
  const ::meshtastic::UserLite& _internal_user() const;
  ::meshtastic::UserLite* PROTOBUF_NONNULL _internal_mutable_user();

  public:
  // .meshtastic.PositionLite position = 3;
  bool has_position() const;
  void clear_position() ;
  const ::meshtastic::PositionLite& position() const;
  [[nodiscard]] ::meshtastic::PositionLite* PROTOBUF_NULLABLE release_position();
  ::meshtastic::PositionLite* PROTOBUF_NONNULL mutable_position();
  void set_allocated_position(::meshtastic::PositionLite* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_position(::meshtastic::PositionLite* PROTOBUF_NULLABLE value);
  ::meshtastic::PositionLite* PROTOBUF_NULLABLE unsafe_arena_release_position();

  private:
  const ::meshtastic::PositionLite& _internal_position() const;
  ::meshtastic::PositionLite* PROTOBUF_NONNULL _internal_mutable_position();

  public:
  // .meshtastic.DeviceMetrics device_metrics = 6;
  bool has_device_metrics() const;
  void clear_device_metrics() ;
  const ::meshtastic::DeviceMetrics& device_metrics() const;
  [[nodiscard]] ::meshtastic::DeviceMetrics* PROTOBUF_NULLABLE release_device_metrics();
  ::meshtastic::DeviceMetrics* PROTOBUF_NONNULL mutable_device_metrics();
  void set_allocated_device_metrics(::meshtastic::DeviceMetrics* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_device_metrics(::meshtastic::DeviceMetrics* PROTOBUF_NULLABLE value);
  ::meshtastic::DeviceMetrics* PROTOBUF_NULLABLE unsafe_arena_release_device_metrics();

  private:
  const ::meshtastic::DeviceMetrics& _internal_device_metrics() const;
  ::meshtastic::DeviceMetrics* PROTOBUF_NONNULL _internal_mutable_device_metrics();

  public:
  // uint32 num = 1;
  void clear_num() ;
  ::uint32_t num() const;
  void set_num(::uint32_t value);

  private:
  ::uint32_t _internal_num() const;
  void _internal_set_num(::uint32_t value);

  public:
  // float snr = 4;
  void clear_snr() ;
  float snr() const;
  void set_snr(float value);

  private:
  float _internal_snr() const;
  void _internal_set_snr(float value);

  public:
  // fixed32 last_heard = 5;
  void clear_last_heard() ;
  ::uint32_t last_heard() const;
  void set_last_heard(::uint32_t value);

  private:
  ::uint32_t _internal_last_heard() const;
  void _internal_set_last_heard(::uint32_t value);

  public:
  // uint32 channel = 7;
  void clear_channel() ;
  ::uint32_t channel() const;
  void set_channel(::uint32_t value);

  private:
  ::uint32_t _internal_channel() const;
  void _internal_set_channel(::uint32_t value);

  public:
  // optional uint32 hops_away = 9;
  bool has_hops_away() const;
  void clear_hops_away() ;
  ::uint32_t hops_away() const;
  void set_hops_away(::uint32_t value);

  private:
  ::uint32_t _internal_hops_away() const;
  void _internal_set_hops_away(::uint32_t value);

  public:
  // bool via_mqtt = 8;
  void clear_via_mqtt() ;
  bool via_mqtt() const;
  void set_via_mqtt(bool value);

  private:
  bool _internal_via_mqtt() const;
  void _internal_set_via_mqtt(bool value);

  public:
  // bool is_favorite = 10;
  void clear_is_favorite() ;
  bool is_favorite() const;
  void set_is_favorite(bool value);

  private:
  bool _internal_is_favorite() const;
  void _internal_set_is_favorite(bool value);

  public:
  // bool is_ignored = 11;
  void clear_is_ignored() ;
  bool is_ignored() const;
  void set_is_ignored(bool value);

  private:
  bool _internal_is_ignored() const;
  void _internal_set_is_ignored(bool value);

  public:
  // uint32 next_hop = 12;
  void clear_next_hop() ;
  ::uint32_t next_hop() const;
  void set_next_hop(::uint32_t value);

  private:
  ::uint32_t _internal_next_hop() const;
  void _internal_set_next_hop(::uint32_t value);

  public:
  // uint32 bitfield = 13;
  void clear_bitfield() ;
  ::uint32_t bitfield() const;
  void set_bitfield(::uint32_t value);

  private:
  ::uint32_t _internal_bitfield() const;
  void _internal_set_bitfield(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:meshtastic.NodeInfoLite)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 13,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const NodeInfoLite& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::meshtastic::UserLite* PROTOBUF_NULLABLE user_;
    ::meshtastic::PositionLite* PROTOBUF_NULLABLE position_;
    ::meshtastic::DeviceMetrics* PROTOBUF_NULLABLE device_metrics_;
    ::uint32_t num_;
    float snr_;
    ::uint32_t last_heard_;
    ::uint32_t channel_;
    ::uint32_t hops_away_;
    bool via_mqtt_;
    bool is_favorite_;
    bool is_ignored_;
    ::uint32_t next_hop_;
    ::uint32_t bitfield_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fdeviceonly_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull NodeInfoLite_class_data_;
// -------------------------------------------------------------------

class NodeDatabase final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.NodeDatabase) */ {
 public:
  inline NodeDatabase() : NodeDatabase(nullptr) {}
  ~NodeDatabase() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(NodeDatabase* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(NodeDatabase));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NodeDatabase(::google::protobuf::internal::ConstantInitialized);

  inline NodeDatabase(const NodeDatabase& from) : NodeDatabase(nullptr, from) {}
  inline NodeDatabase(NodeDatabase&& from) noexcept
      : NodeDatabase(nullptr, ::std::move(from)) {}
  inline NodeDatabase& operator=(const NodeDatabase& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeDatabase& operator=(NodeDatabase&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeDatabase& default_instance() {
    return *reinterpret_cast<const NodeDatabase*>(
        &_NodeDatabase_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(NodeDatabase& a, NodeDatabase& b) { a.Swap(&b); }
  inline void Swap(NodeDatabase* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeDatabase* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeDatabase* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<NodeDatabase>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NodeDatabase& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NodeDatabase& from) { NodeDatabase::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(NodeDatabase* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.NodeDatabase"; }

 protected:
  explicit NodeDatabase(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  NodeDatabase(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const NodeDatabase& from);
  NodeDatabase(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, NodeDatabase&& from) noexcept
      : NodeDatabase(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNodesFieldNumber = 2,
    kVersionFieldNumber = 1,
  };
  // repeated .meshtastic.NodeInfoLite nodes = 2 [(.nanopb) = {
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;

  public:
  void clear_nodes() ;
  ::meshtastic::NodeInfoLite* PROTOBUF_NONNULL mutable_nodes(int index);
  ::google::protobuf::RepeatedPtrField<::meshtastic::NodeInfoLite>* PROTOBUF_NONNULL mutable_nodes();

  private:
  const ::google::protobuf::RepeatedPtrField<::meshtastic::NodeInfoLite>& _internal_nodes() const;
  ::google::protobuf::RepeatedPtrField<::meshtastic::NodeInfoLite>* PROTOBUF_NONNULL _internal_mutable_nodes();
  public:
  const ::meshtastic::NodeInfoLite& nodes(int index) const;
  ::meshtastic::NodeInfoLite* PROTOBUF_NONNULL add_nodes();
  const ::google::protobuf::RepeatedPtrField<::meshtastic::NodeInfoLite>& nodes() const;
  // uint32 version = 1;
  void clear_version() ;
  ::uint32_t version() const;
  void set_version(::uint32_t value);

  private:
  ::uint32_t _internal_version() const;
  void _internal_set_version(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:meshtastic.NodeDatabase)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const NodeDatabase& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::meshtastic::NodeInfoLite > nodes_;
    ::uint32_t version_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fdeviceonly_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull NodeDatabase_class_data_;
// -------------------------------------------------------------------

class DeviceState final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.DeviceState) */ {
 public:
  inline DeviceState() : DeviceState(nullptr) {}
  ~DeviceState() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeviceState* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeviceState));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeviceState(::google::protobuf::internal::ConstantInitialized);

  inline DeviceState(const DeviceState& from) : DeviceState(nullptr, from) {}
  inline DeviceState(DeviceState&& from) noexcept
      : DeviceState(nullptr, ::std::move(from)) {}
  inline DeviceState& operator=(const DeviceState& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceState& operator=(DeviceState&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceState& default_instance() {
    return *reinterpret_cast<const DeviceState*>(
        &_DeviceState_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(DeviceState& a, DeviceState& b) { a.Swap(&b); }
  inline void Swap(DeviceState* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceState* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceState* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DeviceState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeviceState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeviceState& from) { DeviceState::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DeviceState* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.DeviceState"; }

 protected:
  explicit DeviceState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DeviceState(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DeviceState& from);
  DeviceState(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DeviceState&& from) noexcept
      : DeviceState(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kReceiveQueueFieldNumber = 5,
    kNodeRemoteHardwarePinsFieldNumber = 13,
    kMyNodeFieldNumber = 2,
    kOwnerFieldNumber = 3,
    kRxTextMessageFieldNumber = 7,
    kRxWaypointFieldNumber = 12,
    kVersionFieldNumber = 8,
    kNoSaveFieldNumber = 9,
    kDidGpsResetFieldNumber = 11,
  };
  // repeated .meshtastic.MeshPacket receive_queue = 5;
  int receive_queue_size() const;
  private:
  int _internal_receive_queue_size() const;

  public:
  void clear_receive_queue() ;
  ::meshtastic::MeshPacket* PROTOBUF_NONNULL mutable_receive_queue(int index);
  ::google::protobuf::RepeatedPtrField<::meshtastic::MeshPacket>* PROTOBUF_NONNULL mutable_receive_queue();

  private:
  const ::google::protobuf::RepeatedPtrField<::meshtastic::MeshPacket>& _internal_receive_queue() const;
  ::google::protobuf::RepeatedPtrField<::meshtastic::MeshPacket>* PROTOBUF_NONNULL _internal_mutable_receive_queue();
  public:
  const ::meshtastic::MeshPacket& receive_queue(int index) const;
  ::meshtastic::MeshPacket* PROTOBUF_NONNULL add_receive_queue();
  const ::google::protobuf::RepeatedPtrField<::meshtastic::MeshPacket>& receive_queue() const;
  // repeated .meshtastic.NodeRemoteHardwarePin node_remote_hardware_pins = 13;
  int node_remote_hardware_pins_size() const;
  private:
  int _internal_node_remote_hardware_pins_size() const;

  public:
  void clear_node_remote_hardware_pins() ;
  ::meshtastic::NodeRemoteHardwarePin* PROTOBUF_NONNULL mutable_node_remote_hardware_pins(int index);
  ::google::protobuf::RepeatedPtrField<::meshtastic::NodeRemoteHardwarePin>* PROTOBUF_NONNULL mutable_node_remote_hardware_pins();

  private:
  const ::google::protobuf::RepeatedPtrField<::meshtastic::NodeRemoteHardwarePin>& _internal_node_remote_hardware_pins() const;
  ::google::protobuf::RepeatedPtrField<::meshtastic::NodeRemoteHardwarePin>* PROTOBUF_NONNULL _internal_mutable_node_remote_hardware_pins();
  public:
  const ::meshtastic::NodeRemoteHardwarePin& node_remote_hardware_pins(int index) const;
  ::meshtastic::NodeRemoteHardwarePin* PROTOBUF_NONNULL add_node_remote_hardware_pins();
  const ::google::protobuf::RepeatedPtrField<::meshtastic::NodeRemoteHardwarePin>& node_remote_hardware_pins() const;
  // .meshtastic.MyNodeInfo my_node = 2;
  bool has_my_node() const;
  void clear_my_node() ;
  const ::meshtastic::MyNodeInfo& my_node() const;
  [[nodiscard]] ::meshtastic::MyNodeInfo* PROTOBUF_NULLABLE release_my_node();
  ::meshtastic::MyNodeInfo* PROTOBUF_NONNULL mutable_my_node();
  void set_allocated_my_node(::meshtastic::MyNodeInfo* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_my_node(::meshtastic::MyNodeInfo* PROTOBUF_NULLABLE value);
  ::meshtastic::MyNodeInfo* PROTOBUF_NULLABLE unsafe_arena_release_my_node();

  private:
  const ::meshtastic::MyNodeInfo& _internal_my_node() const;
  ::meshtastic::MyNodeInfo* PROTOBUF_NONNULL _internal_mutable_my_node();

  public:
  // .meshtastic.User owner = 3;
  bool has_owner() const;
  void clear_owner() ;
  const ::meshtastic::User& owner() const;
  [[nodiscard]] ::meshtastic::User* PROTOBUF_NULLABLE release_owner();
  ::meshtastic::User* PROTOBUF_NONNULL mutable_owner();
  void set_allocated_owner(::meshtastic::User* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_owner(::meshtastic::User* PROTOBUF_NULLABLE value);
  ::meshtastic::User* PROTOBUF_NULLABLE unsafe_arena_release_owner();

  private:
  const ::meshtastic::User& _internal_owner() const;
  ::meshtastic::User* PROTOBUF_NONNULL _internal_mutable_owner();

  public:
  // .meshtastic.MeshPacket rx_text_message = 7;
  bool has_rx_text_message() const;
  void clear_rx_text_message() ;
  const ::meshtastic::MeshPacket& rx_text_message() const;
  [[nodiscard]] ::meshtastic::MeshPacket* PROTOBUF_NULLABLE release_rx_text_message();
  ::meshtastic::MeshPacket* PROTOBUF_NONNULL mutable_rx_text_message();
  void set_allocated_rx_text_message(::meshtastic::MeshPacket* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_rx_text_message(::meshtastic::MeshPacket* PROTOBUF_NULLABLE value);
  ::meshtastic::MeshPacket* PROTOBUF_NULLABLE unsafe_arena_release_rx_text_message();

  private:
  const ::meshtastic::MeshPacket& _internal_rx_text_message() const;
  ::meshtastic::MeshPacket* PROTOBUF_NONNULL _internal_mutable_rx_text_message();

  public:
  // .meshtastic.MeshPacket rx_waypoint = 12;
  bool has_rx_waypoint() const;
  void clear_rx_waypoint() ;
  const ::meshtastic::MeshPacket& rx_waypoint() const;
  [[nodiscard]] ::meshtastic::MeshPacket* PROTOBUF_NULLABLE release_rx_waypoint();
  ::meshtastic::MeshPacket* PROTOBUF_NONNULL mutable_rx_waypoint();
  void set_allocated_rx_waypoint(::meshtastic::MeshPacket* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_rx_waypoint(::meshtastic::MeshPacket* PROTOBUF_NULLABLE value);
  ::meshtastic::MeshPacket* PROTOBUF_NULLABLE unsafe_arena_release_rx_waypoint();

  private:
  const ::meshtastic::MeshPacket& _internal_rx_waypoint() const;
  ::meshtastic::MeshPacket* PROTOBUF_NONNULL _internal_mutable_rx_waypoint();

  public:
  // uint32 version = 8;
  void clear_version() ;
  ::uint32_t version() const;
  void set_version(::uint32_t value);

  private:
  ::uint32_t _internal_version() const;
  void _internal_set_version(::uint32_t value);

  public:
  // bool no_save = 9 [deprecated = true];
  [[deprecated]]  void clear_no_save() ;
  [[deprecated]] bool no_save() const;
  [[deprecated]] void set_no_save(bool value);

  private:
  bool _internal_no_save() const;
  void _internal_set_no_save(bool value);

  public:
  // bool did_gps_reset = 11 [deprecated = true];
  [[deprecated]]  void clear_did_gps_reset() ;
  [[deprecated]] bool did_gps_reset() const;
  [[deprecated]] void set_did_gps_reset(bool value);

  private:
  bool _internal_did_gps_reset() const;
  void _internal_set_did_gps_reset(bool value);

  public:
  // @@protoc_insertion_point(class_scope:meshtastic.DeviceState)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 9,
                                   6, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DeviceState& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::meshtastic::MeshPacket > receive_queue_;
    ::google::protobuf::RepeatedPtrField< ::meshtastic::NodeRemoteHardwarePin > node_remote_hardware_pins_;
    ::meshtastic::MyNodeInfo* PROTOBUF_NULLABLE my_node_;
    ::meshtastic::User* PROTOBUF_NULLABLE owner_;
    ::meshtastic::MeshPacket* PROTOBUF_NULLABLE rx_text_message_;
    ::meshtastic::MeshPacket* PROTOBUF_NULLABLE rx_waypoint_;
    ::uint32_t version_;
    bool no_save_;
    bool did_gps_reset_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fdeviceonly_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DeviceState_class_data_;
// -------------------------------------------------------------------

class ChannelFile final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.ChannelFile) */ {
 public:
  inline ChannelFile() : ChannelFile(nullptr) {}
  ~ChannelFile() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ChannelFile* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ChannelFile));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ChannelFile(::google::protobuf::internal::ConstantInitialized);

  inline ChannelFile(const ChannelFile& from) : ChannelFile(nullptr, from) {}
  inline ChannelFile(ChannelFile&& from) noexcept
      : ChannelFile(nullptr, ::std::move(from)) {}
  inline ChannelFile& operator=(const ChannelFile& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelFile& operator=(ChannelFile&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChannelFile& default_instance() {
    return *reinterpret_cast<const ChannelFile*>(
        &_ChannelFile_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(ChannelFile& a, ChannelFile& b) { a.Swap(&b); }
  inline void Swap(ChannelFile* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelFile* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChannelFile* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ChannelFile>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChannelFile& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ChannelFile& from) { ChannelFile::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ChannelFile* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.ChannelFile"; }

 protected:
  explicit ChannelFile(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ChannelFile(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ChannelFile& from);
  ChannelFile(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ChannelFile&& from) noexcept
      : ChannelFile(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kChannelsFieldNumber = 1,
    kVersionFieldNumber = 2,
  };
  // repeated .meshtastic.Channel channels = 1;
  int channels_size() const;
  private:
  int _internal_channels_size() const;

  public:
  void clear_channels() ;
  ::meshtastic::Channel* PROTOBUF_NONNULL mutable_channels(int index);
  ::google::protobuf::RepeatedPtrField<::meshtastic::Channel>* PROTOBUF_NONNULL mutable_channels();

  private:
  const ::google::protobuf::RepeatedPtrField<::meshtastic::Channel>& _internal_channels() const;
  ::google::protobuf::RepeatedPtrField<::meshtastic::Channel>* PROTOBUF_NONNULL _internal_mutable_channels();
  public:
  const ::meshtastic::Channel& channels(int index) const;
  ::meshtastic::Channel* PROTOBUF_NONNULL add_channels();
  const ::google::protobuf::RepeatedPtrField<::meshtastic::Channel>& channels() const;
  // uint32 version = 2;
  void clear_version() ;
  ::uint32_t version() const;
  void set_version(::uint32_t value);

  private:
  ::uint32_t _internal_version() const;
  void _internal_set_version(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:meshtastic.ChannelFile)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ChannelFile& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::meshtastic::Channel > channels_;
    ::uint32_t version_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fdeviceonly_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ChannelFile_class_data_;
// -------------------------------------------------------------------

class BackupPreferences final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:meshtastic.BackupPreferences) */ {
 public:
  inline BackupPreferences() : BackupPreferences(nullptr) {}
  ~BackupPreferences() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BackupPreferences* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BackupPreferences));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BackupPreferences(::google::protobuf::internal::ConstantInitialized);

  inline BackupPreferences(const BackupPreferences& from) : BackupPreferences(nullptr, from) {}
  inline BackupPreferences(BackupPreferences&& from) noexcept
      : BackupPreferences(nullptr, ::std::move(from)) {}
  inline BackupPreferences& operator=(const BackupPreferences& from) {
    CopyFrom(from);
    return *this;
  }
  inline BackupPreferences& operator=(BackupPreferences&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BackupPreferences& default_instance() {
    return *reinterpret_cast<const BackupPreferences*>(
        &_BackupPreferences_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(BackupPreferences& a, BackupPreferences& b) { a.Swap(&b); }
  inline void Swap(BackupPreferences* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BackupPreferences* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BackupPreferences* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BackupPreferences>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BackupPreferences& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BackupPreferences& from) { BackupPreferences::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BackupPreferences* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "meshtastic.BackupPreferences"; }

 protected:
  explicit BackupPreferences(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  BackupPreferences(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const BackupPreferences& from);
  BackupPreferences(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, BackupPreferences&& from) noexcept
      : BackupPreferences(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kConfigFieldNumber = 3,
    kModuleConfigFieldNumber = 4,
    kChannelsFieldNumber = 5,
    kOwnerFieldNumber = 6,
    kVersionFieldNumber = 1,
    kTimestampFieldNumber = 2,
  };
  // .meshtastic.LocalConfig config = 3;
  bool has_config() const;
  void clear_config() ;
  const ::meshtastic::LocalConfig& config() const;
  [[nodiscard]] ::meshtastic::LocalConfig* PROTOBUF_NULLABLE release_config();
  ::meshtastic::LocalConfig* PROTOBUF_NONNULL mutable_config();
  void set_allocated_config(::meshtastic::LocalConfig* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_config(::meshtastic::LocalConfig* PROTOBUF_NULLABLE value);
  ::meshtastic::LocalConfig* PROTOBUF_NULLABLE unsafe_arena_release_config();

  private:
  const ::meshtastic::LocalConfig& _internal_config() const;
  ::meshtastic::LocalConfig* PROTOBUF_NONNULL _internal_mutable_config();

  public:
  // .meshtastic.LocalModuleConfig module_config = 4;
  bool has_module_config() const;
  void clear_module_config() ;
  const ::meshtastic::LocalModuleConfig& module_config() const;
  [[nodiscard]] ::meshtastic::LocalModuleConfig* PROTOBUF_NULLABLE release_module_config();
  ::meshtastic::LocalModuleConfig* PROTOBUF_NONNULL mutable_module_config();
  void set_allocated_module_config(::meshtastic::LocalModuleConfig* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_module_config(::meshtastic::LocalModuleConfig* PROTOBUF_NULLABLE value);
  ::meshtastic::LocalModuleConfig* PROTOBUF_NULLABLE unsafe_arena_release_module_config();

  private:
  const ::meshtastic::LocalModuleConfig& _internal_module_config() const;
  ::meshtastic::LocalModuleConfig* PROTOBUF_NONNULL _internal_mutable_module_config();

  public:
  // .meshtastic.ChannelFile channels = 5;
  bool has_channels() const;
  void clear_channels() ;
  const ::meshtastic::ChannelFile& channels() const;
  [[nodiscard]] ::meshtastic::ChannelFile* PROTOBUF_NULLABLE release_channels();
  ::meshtastic::ChannelFile* PROTOBUF_NONNULL mutable_channels();
  void set_allocated_channels(::meshtastic::ChannelFile* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_channels(::meshtastic::ChannelFile* PROTOBUF_NULLABLE value);
  ::meshtastic::ChannelFile* PROTOBUF_NULLABLE unsafe_arena_release_channels();

  private:
  const ::meshtastic::ChannelFile& _internal_channels() const;
  ::meshtastic::ChannelFile* PROTOBUF_NONNULL _internal_mutable_channels();

  public:
  // .meshtastic.User owner = 6;
  bool has_owner() const;
  void clear_owner() ;
  const ::meshtastic::User& owner() const;
  [[nodiscard]] ::meshtastic::User* PROTOBUF_NULLABLE release_owner();
  ::meshtastic::User* PROTOBUF_NONNULL mutable_owner();
  void set_allocated_owner(::meshtastic::User* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_owner(::meshtastic::User* PROTOBUF_NULLABLE value);
  ::meshtastic::User* PROTOBUF_NULLABLE unsafe_arena_release_owner();

  private:
  const ::meshtastic::User& _internal_owner() const;
  ::meshtastic::User* PROTOBUF_NONNULL _internal_mutable_owner();

  public:
  // uint32 version = 1;
  void clear_version() ;
  ::uint32_t version() const;
  void set_version(::uint32_t value);

  private:
  ::uint32_t _internal_version() const;
  void _internal_set_version(::uint32_t value);

  public:
  // fixed32 timestamp = 2;
  void clear_timestamp() ;
  ::uint32_t timestamp() const;
  void set_timestamp(::uint32_t value);

  private:
  ::uint32_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:meshtastic.BackupPreferences)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6,
                                   4, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const BackupPreferences& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::meshtastic::LocalConfig* PROTOBUF_NULLABLE config_;
    ::meshtastic::LocalModuleConfig* PROTOBUF_NULLABLE module_config_;
    ::meshtastic::ChannelFile* PROTOBUF_NULLABLE channels_;
    ::meshtastic::User* PROTOBUF_NULLABLE owner_;
    ::uint32_t version_;
    ::uint32_t timestamp_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meshtastic_2fdeviceonly_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull BackupPreferences_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// PositionLite

// sfixed32 latitude_i = 1;
inline void PositionLite::clear_latitude_i() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.latitude_i_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline ::int32_t PositionLite::latitude_i() const {
  // @@protoc_insertion_point(field_get:meshtastic.PositionLite.latitude_i)
  return _internal_latitude_i();
}
inline void PositionLite::set_latitude_i(::int32_t value) {
  _internal_set_latitude_i(value);
  _impl_._has_bits_[0] |= 0x00000001U;
  // @@protoc_insertion_point(field_set:meshtastic.PositionLite.latitude_i)
}
inline ::int32_t PositionLite::_internal_latitude_i() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.latitude_i_;
}
inline void PositionLite::_internal_set_latitude_i(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.latitude_i_ = value;
}

// sfixed32 longitude_i = 2;
inline void PositionLite::clear_longitude_i() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.longitude_i_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline ::int32_t PositionLite::longitude_i() const {
  // @@protoc_insertion_point(field_get:meshtastic.PositionLite.longitude_i)
  return _internal_longitude_i();
}
inline void PositionLite::set_longitude_i(::int32_t value) {
  _internal_set_longitude_i(value);
  _impl_._has_bits_[0] |= 0x00000002U;
  // @@protoc_insertion_point(field_set:meshtastic.PositionLite.longitude_i)
}
inline ::int32_t PositionLite::_internal_longitude_i() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.longitude_i_;
}
inline void PositionLite::_internal_set_longitude_i(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.longitude_i_ = value;
}

// int32 altitude = 3;
inline void PositionLite::clear_altitude() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.altitude_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004U;
}
inline ::int32_t PositionLite::altitude() const {
  // @@protoc_insertion_point(field_get:meshtastic.PositionLite.altitude)
  return _internal_altitude();
}
inline void PositionLite::set_altitude(::int32_t value) {
  _internal_set_altitude(value);
  _impl_._has_bits_[0] |= 0x00000004U;
  // @@protoc_insertion_point(field_set:meshtastic.PositionLite.altitude)
}
inline ::int32_t PositionLite::_internal_altitude() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.altitude_;
}
inline void PositionLite::_internal_set_altitude(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.altitude_ = value;
}

// fixed32 time = 4;
inline void PositionLite::clear_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008U;
}
inline ::uint32_t PositionLite::time() const {
  // @@protoc_insertion_point(field_get:meshtastic.PositionLite.time)
  return _internal_time();
}
inline void PositionLite::set_time(::uint32_t value) {
  _internal_set_time(value);
  _impl_._has_bits_[0] |= 0x00000008U;
  // @@protoc_insertion_point(field_set:meshtastic.PositionLite.time)
}
inline ::uint32_t PositionLite::_internal_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_;
}
inline void PositionLite::_internal_set_time(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = value;
}

// .meshtastic.Position.LocSource location_source = 5;
inline void PositionLite::clear_location_source() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.location_source_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010U;
}
inline ::meshtastic::Position_LocSource PositionLite::location_source() const {
  // @@protoc_insertion_point(field_get:meshtastic.PositionLite.location_source)
  return _internal_location_source();
}
inline void PositionLite::set_location_source(::meshtastic::Position_LocSource value) {
  _internal_set_location_source(value);
  _impl_._has_bits_[0] |= 0x00000010U;
  // @@protoc_insertion_point(field_set:meshtastic.PositionLite.location_source)
}
inline ::meshtastic::Position_LocSource PositionLite::_internal_location_source() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::meshtastic::Position_LocSource>(_impl_.location_source_);
}
inline void PositionLite::_internal_set_location_source(::meshtastic::Position_LocSource value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.location_source_ = value;
}

// -------------------------------------------------------------------

// UserLite

// bytes macaddr = 1 [deprecated = true];
inline void UserLite::clear_macaddr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.macaddr_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline const ::std::string& UserLite::macaddr() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.UserLite.macaddr)
  return _internal_macaddr();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UserLite::set_macaddr(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  _impl_.macaddr_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:meshtastic.UserLite.macaddr)
}
inline ::std::string* PROTOBUF_NONNULL UserLite::mutable_macaddr()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_macaddr();
  // @@protoc_insertion_point(field_mutable:meshtastic.UserLite.macaddr)
  return _s;
}
inline const ::std::string& UserLite::_internal_macaddr() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.macaddr_.Get();
}
inline void UserLite::_internal_set_macaddr(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  _impl_.macaddr_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL UserLite::_internal_mutable_macaddr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  return _impl_.macaddr_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE UserLite::release_macaddr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.UserLite.macaddr)
  if ((_impl_._has_bits_[0] & 0x00000001U) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001U;
  auto* released = _impl_.macaddr_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.macaddr_.Set("", GetArena());
  }
  return released;
}
inline void UserLite::set_allocated_macaddr(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }
  _impl_.macaddr_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.macaddr_.IsDefault()) {
    _impl_.macaddr_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.UserLite.macaddr)
}

// string long_name = 2;
inline void UserLite::clear_long_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.long_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline const ::std::string& UserLite::long_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.UserLite.long_name)
  return _internal_long_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UserLite::set_long_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002U;
  _impl_.long_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:meshtastic.UserLite.long_name)
}
inline ::std::string* PROTOBUF_NONNULL UserLite::mutable_long_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_long_name();
  // @@protoc_insertion_point(field_mutable:meshtastic.UserLite.long_name)
  return _s;
}
inline const ::std::string& UserLite::_internal_long_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.long_name_.Get();
}
inline void UserLite::_internal_set_long_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002U;
  _impl_.long_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL UserLite::_internal_mutable_long_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002U;
  return _impl_.long_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE UserLite::release_long_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.UserLite.long_name)
  if ((_impl_._has_bits_[0] & 0x00000002U) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002U;
  auto* released = _impl_.long_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.long_name_.Set("", GetArena());
  }
  return released;
}
inline void UserLite::set_allocated_long_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002U;
  }
  _impl_.long_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.long_name_.IsDefault()) {
    _impl_.long_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.UserLite.long_name)
}

// string short_name = 3;
inline void UserLite::clear_short_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.short_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004U;
}
inline const ::std::string& UserLite::short_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.UserLite.short_name)
  return _internal_short_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UserLite::set_short_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004U;
  _impl_.short_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:meshtastic.UserLite.short_name)
}
inline ::std::string* PROTOBUF_NONNULL UserLite::mutable_short_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_short_name();
  // @@protoc_insertion_point(field_mutable:meshtastic.UserLite.short_name)
  return _s;
}
inline const ::std::string& UserLite::_internal_short_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.short_name_.Get();
}
inline void UserLite::_internal_set_short_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004U;
  _impl_.short_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL UserLite::_internal_mutable_short_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004U;
  return _impl_.short_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE UserLite::release_short_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.UserLite.short_name)
  if ((_impl_._has_bits_[0] & 0x00000004U) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004U;
  auto* released = _impl_.short_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.short_name_.Set("", GetArena());
  }
  return released;
}
inline void UserLite::set_allocated_short_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004U;
  }
  _impl_.short_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.short_name_.IsDefault()) {
    _impl_.short_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.UserLite.short_name)
}

// .meshtastic.HardwareModel hw_model = 4;
inline void UserLite::clear_hw_model() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hw_model_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010U;
}
inline ::meshtastic::HardwareModel UserLite::hw_model() const {
  // @@protoc_insertion_point(field_get:meshtastic.UserLite.hw_model)
  return _internal_hw_model();
}
inline void UserLite::set_hw_model(::meshtastic::HardwareModel value) {
  _internal_set_hw_model(value);
  _impl_._has_bits_[0] |= 0x00000010U;
  // @@protoc_insertion_point(field_set:meshtastic.UserLite.hw_model)
}
inline ::meshtastic::HardwareModel UserLite::_internal_hw_model() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::meshtastic::HardwareModel>(_impl_.hw_model_);
}
inline void UserLite::_internal_set_hw_model(::meshtastic::HardwareModel value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hw_model_ = value;
}

// bool is_licensed = 5;
inline void UserLite::clear_is_licensed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_licensed_ = false;
  _impl_._has_bits_[0] &= ~0x00000040U;
}
inline bool UserLite::is_licensed() const {
  // @@protoc_insertion_point(field_get:meshtastic.UserLite.is_licensed)
  return _internal_is_licensed();
}
inline void UserLite::set_is_licensed(bool value) {
  _internal_set_is_licensed(value);
  _impl_._has_bits_[0] |= 0x00000040U;
  // @@protoc_insertion_point(field_set:meshtastic.UserLite.is_licensed)
}
inline bool UserLite::_internal_is_licensed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_licensed_;
}
inline void UserLite::_internal_set_is_licensed(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_licensed_ = value;
}

// .meshtastic.Config.DeviceConfig.Role role = 6;
inline void UserLite::clear_role() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.role_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020U;
}
inline ::meshtastic::Config_DeviceConfig_Role UserLite::role() const {
  // @@protoc_insertion_point(field_get:meshtastic.UserLite.role)
  return _internal_role();
}
inline void UserLite::set_role(::meshtastic::Config_DeviceConfig_Role value) {
  _internal_set_role(value);
  _impl_._has_bits_[0] |= 0x00000020U;
  // @@protoc_insertion_point(field_set:meshtastic.UserLite.role)
}
inline ::meshtastic::Config_DeviceConfig_Role UserLite::_internal_role() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::meshtastic::Config_DeviceConfig_Role>(_impl_.role_);
}
inline void UserLite::_internal_set_role(::meshtastic::Config_DeviceConfig_Role value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.role_ = value;
}

// bytes public_key = 7;
inline void UserLite::clear_public_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.public_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008U;
}
inline const ::std::string& UserLite::public_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.UserLite.public_key)
  return _internal_public_key();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void UserLite::set_public_key(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008U;
  _impl_.public_key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:meshtastic.UserLite.public_key)
}
inline ::std::string* PROTOBUF_NONNULL UserLite::mutable_public_key()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_public_key();
  // @@protoc_insertion_point(field_mutable:meshtastic.UserLite.public_key)
  return _s;
}
inline const ::std::string& UserLite::_internal_public_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.public_key_.Get();
}
inline void UserLite::_internal_set_public_key(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008U;
  _impl_.public_key_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL UserLite::_internal_mutable_public_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008U;
  return _impl_.public_key_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE UserLite::release_public_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.UserLite.public_key)
  if ((_impl_._has_bits_[0] & 0x00000008U) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008U;
  auto* released = _impl_.public_key_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.public_key_.Set("", GetArena());
  }
  return released;
}
inline void UserLite::set_allocated_public_key(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008U;
  }
  _impl_.public_key_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.public_key_.IsDefault()) {
    _impl_.public_key_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.UserLite.public_key)
}

// optional bool is_unmessagable = 9;
inline bool UserLite::has_is_unmessagable() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080U) != 0;
  return value;
}
inline void UserLite::clear_is_unmessagable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_unmessagable_ = false;
  _impl_._has_bits_[0] &= ~0x00000080U;
}
inline bool UserLite::is_unmessagable() const {
  // @@protoc_insertion_point(field_get:meshtastic.UserLite.is_unmessagable)
  return _internal_is_unmessagable();
}
inline void UserLite::set_is_unmessagable(bool value) {
  _internal_set_is_unmessagable(value);
  _impl_._has_bits_[0] |= 0x00000080U;
  // @@protoc_insertion_point(field_set:meshtastic.UserLite.is_unmessagable)
}
inline bool UserLite::_internal_is_unmessagable() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_unmessagable_;
}
inline void UserLite::_internal_set_is_unmessagable(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_unmessagable_ = value;
}

// -------------------------------------------------------------------

// NodeInfoLite

// uint32 num = 1;
inline void NodeInfoLite::clear_num() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008U;
}
inline ::uint32_t NodeInfoLite::num() const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfoLite.num)
  return _internal_num();
}
inline void NodeInfoLite::set_num(::uint32_t value) {
  _internal_set_num(value);
  _impl_._has_bits_[0] |= 0x00000008U;
  // @@protoc_insertion_point(field_set:meshtastic.NodeInfoLite.num)
}
inline ::uint32_t NodeInfoLite::_internal_num() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.num_;
}
inline void NodeInfoLite::_internal_set_num(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_ = value;
}

// .meshtastic.UserLite user = 2;
inline bool NodeInfoLite::has_user() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001U) != 0;
  PROTOBUF_ASSUME(!value || _impl_.user_ != nullptr);
  return value;
}
inline void NodeInfoLite::clear_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.user_ != nullptr) _impl_.user_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline const ::meshtastic::UserLite& NodeInfoLite::_internal_user() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::meshtastic::UserLite* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::UserLite&>(::meshtastic::_UserLite_default_instance_);
}
inline const ::meshtastic::UserLite& NodeInfoLite::user() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfoLite.user)
  return _internal_user();
}
inline void NodeInfoLite::unsafe_arena_set_allocated_user(
    ::meshtastic::UserLite* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = reinterpret_cast<::meshtastic::UserLite*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.NodeInfoLite.user)
}
inline ::meshtastic::UserLite* PROTOBUF_NULLABLE NodeInfoLite::release_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001U;
  ::meshtastic::UserLite* released = _impl_.user_;
  _impl_.user_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::meshtastic::UserLite* PROTOBUF_NULLABLE NodeInfoLite::unsafe_arena_release_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.NodeInfoLite.user)

  _impl_._has_bits_[0] &= ~0x00000001U;
  ::meshtastic::UserLite* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::meshtastic::UserLite* PROTOBUF_NONNULL NodeInfoLite::_internal_mutable_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.user_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::meshtastic::UserLite>(GetArena());
    _impl_.user_ = reinterpret_cast<::meshtastic::UserLite*>(p);
  }
  return _impl_.user_;
}
inline ::meshtastic::UserLite* PROTOBUF_NONNULL NodeInfoLite::mutable_user()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001U;
  ::meshtastic::UserLite* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:meshtastic.NodeInfoLite.user)
  return _msg;
}
inline void NodeInfoLite::set_allocated_user(::meshtastic::UserLite* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.user_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }

  _impl_.user_ = reinterpret_cast<::meshtastic::UserLite*>(value);
  // @@protoc_insertion_point(field_set_allocated:meshtastic.NodeInfoLite.user)
}

// .meshtastic.PositionLite position = 3;
inline bool NodeInfoLite::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002U) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void NodeInfoLite::clear_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline const ::meshtastic::PositionLite& NodeInfoLite::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::meshtastic::PositionLite* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::PositionLite&>(::meshtastic::_PositionLite_default_instance_);
}
inline const ::meshtastic::PositionLite& NodeInfoLite::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfoLite.position)
  return _internal_position();
}
inline void NodeInfoLite::unsafe_arena_set_allocated_position(
    ::meshtastic::PositionLite* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::meshtastic::PositionLite*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002U;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.NodeInfoLite.position)
}
inline ::meshtastic::PositionLite* PROTOBUF_NULLABLE NodeInfoLite::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002U;
  ::meshtastic::PositionLite* released = _impl_.position_;
  _impl_.position_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::meshtastic::PositionLite* PROTOBUF_NULLABLE NodeInfoLite::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.NodeInfoLite.position)

  _impl_._has_bits_[0] &= ~0x00000002U;
  ::meshtastic::PositionLite* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::meshtastic::PositionLite* PROTOBUF_NONNULL NodeInfoLite::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::meshtastic::PositionLite>(GetArena());
    _impl_.position_ = reinterpret_cast<::meshtastic::PositionLite*>(p);
  }
  return _impl_.position_;
}
inline ::meshtastic::PositionLite* PROTOBUF_NONNULL NodeInfoLite::mutable_position()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002U;
  ::meshtastic::PositionLite* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:meshtastic.NodeInfoLite.position)
  return _msg;
}
inline void NodeInfoLite::set_allocated_position(::meshtastic::PositionLite* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002U;
  }

  _impl_.position_ = reinterpret_cast<::meshtastic::PositionLite*>(value);
  // @@protoc_insertion_point(field_set_allocated:meshtastic.NodeInfoLite.position)
}

// float snr = 4;
inline void NodeInfoLite::clear_snr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.snr_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010U;
}
inline float NodeInfoLite::snr() const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfoLite.snr)
  return _internal_snr();
}
inline void NodeInfoLite::set_snr(float value) {
  _internal_set_snr(value);
  _impl_._has_bits_[0] |= 0x00000010U;
  // @@protoc_insertion_point(field_set:meshtastic.NodeInfoLite.snr)
}
inline float NodeInfoLite::_internal_snr() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.snr_;
}
inline void NodeInfoLite::_internal_set_snr(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.snr_ = value;
}

// fixed32 last_heard = 5;
inline void NodeInfoLite::clear_last_heard() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_heard_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020U;
}
inline ::uint32_t NodeInfoLite::last_heard() const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfoLite.last_heard)
  return _internal_last_heard();
}
inline void NodeInfoLite::set_last_heard(::uint32_t value) {
  _internal_set_last_heard(value);
  _impl_._has_bits_[0] |= 0x00000020U;
  // @@protoc_insertion_point(field_set:meshtastic.NodeInfoLite.last_heard)
}
inline ::uint32_t NodeInfoLite::_internal_last_heard() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.last_heard_;
}
inline void NodeInfoLite::_internal_set_last_heard(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_heard_ = value;
}

// .meshtastic.DeviceMetrics device_metrics = 6;
inline bool NodeInfoLite::has_device_metrics() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004U) != 0;
  PROTOBUF_ASSUME(!value || _impl_.device_metrics_ != nullptr);
  return value;
}
inline const ::meshtastic::DeviceMetrics& NodeInfoLite::_internal_device_metrics() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::meshtastic::DeviceMetrics* p = _impl_.device_metrics_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::DeviceMetrics&>(::meshtastic::_DeviceMetrics_default_instance_);
}
inline const ::meshtastic::DeviceMetrics& NodeInfoLite::device_metrics() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfoLite.device_metrics)
  return _internal_device_metrics();
}
inline void NodeInfoLite::unsafe_arena_set_allocated_device_metrics(
    ::meshtastic::DeviceMetrics* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.device_metrics_);
  }
  _impl_.device_metrics_ = reinterpret_cast<::meshtastic::DeviceMetrics*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004U;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.NodeInfoLite.device_metrics)
}
inline ::meshtastic::DeviceMetrics* PROTOBUF_NULLABLE NodeInfoLite::release_device_metrics() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004U;
  ::meshtastic::DeviceMetrics* released = _impl_.device_metrics_;
  _impl_.device_metrics_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::meshtastic::DeviceMetrics* PROTOBUF_NULLABLE NodeInfoLite::unsafe_arena_release_device_metrics() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.NodeInfoLite.device_metrics)

  _impl_._has_bits_[0] &= ~0x00000004U;
  ::meshtastic::DeviceMetrics* temp = _impl_.device_metrics_;
  _impl_.device_metrics_ = nullptr;
  return temp;
}
inline ::meshtastic::DeviceMetrics* PROTOBUF_NONNULL NodeInfoLite::_internal_mutable_device_metrics() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.device_metrics_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::meshtastic::DeviceMetrics>(GetArena());
    _impl_.device_metrics_ = reinterpret_cast<::meshtastic::DeviceMetrics*>(p);
  }
  return _impl_.device_metrics_;
}
inline ::meshtastic::DeviceMetrics* PROTOBUF_NONNULL NodeInfoLite::mutable_device_metrics()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004U;
  ::meshtastic::DeviceMetrics* _msg = _internal_mutable_device_metrics();
  // @@protoc_insertion_point(field_mutable:meshtastic.NodeInfoLite.device_metrics)
  return _msg;
}
inline void NodeInfoLite::set_allocated_device_metrics(::meshtastic::DeviceMetrics* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.device_metrics_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004U;
  }

  _impl_.device_metrics_ = reinterpret_cast<::meshtastic::DeviceMetrics*>(value);
  // @@protoc_insertion_point(field_set_allocated:meshtastic.NodeInfoLite.device_metrics)
}

// uint32 channel = 7;
inline void NodeInfoLite::clear_channel() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channel_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040U;
}
inline ::uint32_t NodeInfoLite::channel() const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfoLite.channel)
  return _internal_channel();
}
inline void NodeInfoLite::set_channel(::uint32_t value) {
  _internal_set_channel(value);
  _impl_._has_bits_[0] |= 0x00000040U;
  // @@protoc_insertion_point(field_set:meshtastic.NodeInfoLite.channel)
}
inline ::uint32_t NodeInfoLite::_internal_channel() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.channel_;
}
inline void NodeInfoLite::_internal_set_channel(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channel_ = value;
}

// bool via_mqtt = 8;
inline void NodeInfoLite::clear_via_mqtt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.via_mqtt_ = false;
  _impl_._has_bits_[0] &= ~0x00000100U;
}
inline bool NodeInfoLite::via_mqtt() const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfoLite.via_mqtt)
  return _internal_via_mqtt();
}
inline void NodeInfoLite::set_via_mqtt(bool value) {
  _internal_set_via_mqtt(value);
  _impl_._has_bits_[0] |= 0x00000100U;
  // @@protoc_insertion_point(field_set:meshtastic.NodeInfoLite.via_mqtt)
}
inline bool NodeInfoLite::_internal_via_mqtt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.via_mqtt_;
}
inline void NodeInfoLite::_internal_set_via_mqtt(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.via_mqtt_ = value;
}

// optional uint32 hops_away = 9;
inline bool NodeInfoLite::has_hops_away() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080U) != 0;
  return value;
}
inline void NodeInfoLite::clear_hops_away() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hops_away_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080U;
}
inline ::uint32_t NodeInfoLite::hops_away() const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfoLite.hops_away)
  return _internal_hops_away();
}
inline void NodeInfoLite::set_hops_away(::uint32_t value) {
  _internal_set_hops_away(value);
  _impl_._has_bits_[0] |= 0x00000080U;
  // @@protoc_insertion_point(field_set:meshtastic.NodeInfoLite.hops_away)
}
inline ::uint32_t NodeInfoLite::_internal_hops_away() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hops_away_;
}
inline void NodeInfoLite::_internal_set_hops_away(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hops_away_ = value;
}

// bool is_favorite = 10;
inline void NodeInfoLite::clear_is_favorite() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_favorite_ = false;
  _impl_._has_bits_[0] &= ~0x00000200U;
}
inline bool NodeInfoLite::is_favorite() const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfoLite.is_favorite)
  return _internal_is_favorite();
}
inline void NodeInfoLite::set_is_favorite(bool value) {
  _internal_set_is_favorite(value);
  _impl_._has_bits_[0] |= 0x00000200U;
  // @@protoc_insertion_point(field_set:meshtastic.NodeInfoLite.is_favorite)
}
inline bool NodeInfoLite::_internal_is_favorite() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_favorite_;
}
inline void NodeInfoLite::_internal_set_is_favorite(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_favorite_ = value;
}

// bool is_ignored = 11;
inline void NodeInfoLite::clear_is_ignored() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_ignored_ = false;
  _impl_._has_bits_[0] &= ~0x00000400U;
}
inline bool NodeInfoLite::is_ignored() const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfoLite.is_ignored)
  return _internal_is_ignored();
}
inline void NodeInfoLite::set_is_ignored(bool value) {
  _internal_set_is_ignored(value);
  _impl_._has_bits_[0] |= 0x00000400U;
  // @@protoc_insertion_point(field_set:meshtastic.NodeInfoLite.is_ignored)
}
inline bool NodeInfoLite::_internal_is_ignored() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_ignored_;
}
inline void NodeInfoLite::_internal_set_is_ignored(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_ignored_ = value;
}

// uint32 next_hop = 12;
inline void NodeInfoLite::clear_next_hop() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_hop_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000800U;
}
inline ::uint32_t NodeInfoLite::next_hop() const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfoLite.next_hop)
  return _internal_next_hop();
}
inline void NodeInfoLite::set_next_hop(::uint32_t value) {
  _internal_set_next_hop(value);
  _impl_._has_bits_[0] |= 0x00000800U;
  // @@protoc_insertion_point(field_set:meshtastic.NodeInfoLite.next_hop)
}
inline ::uint32_t NodeInfoLite::_internal_next_hop() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.next_hop_;
}
inline void NodeInfoLite::_internal_set_next_hop(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_hop_ = value;
}

// uint32 bitfield = 13;
inline void NodeInfoLite::clear_bitfield() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bitfield_ = 0u;
  _impl_._has_bits_[0] &= ~0x00001000U;
}
inline ::uint32_t NodeInfoLite::bitfield() const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeInfoLite.bitfield)
  return _internal_bitfield();
}
inline void NodeInfoLite::set_bitfield(::uint32_t value) {
  _internal_set_bitfield(value);
  _impl_._has_bits_[0] |= 0x00001000U;
  // @@protoc_insertion_point(field_set:meshtastic.NodeInfoLite.bitfield)
}
inline ::uint32_t NodeInfoLite::_internal_bitfield() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.bitfield_;
}
inline void NodeInfoLite::_internal_set_bitfield(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bitfield_ = value;
}

// -------------------------------------------------------------------

// DeviceState

// .meshtastic.MyNodeInfo my_node = 2;
inline bool DeviceState::has_my_node() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001U) != 0;
  PROTOBUF_ASSUME(!value || _impl_.my_node_ != nullptr);
  return value;
}
inline const ::meshtastic::MyNodeInfo& DeviceState::_internal_my_node() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::meshtastic::MyNodeInfo* p = _impl_.my_node_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::MyNodeInfo&>(::meshtastic::_MyNodeInfo_default_instance_);
}
inline const ::meshtastic::MyNodeInfo& DeviceState::my_node() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.DeviceState.my_node)
  return _internal_my_node();
}
inline void DeviceState::unsafe_arena_set_allocated_my_node(
    ::meshtastic::MyNodeInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.my_node_);
  }
  _impl_.my_node_ = reinterpret_cast<::meshtastic::MyNodeInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.DeviceState.my_node)
}
inline ::meshtastic::MyNodeInfo* PROTOBUF_NULLABLE DeviceState::release_my_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001U;
  ::meshtastic::MyNodeInfo* released = _impl_.my_node_;
  _impl_.my_node_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::meshtastic::MyNodeInfo* PROTOBUF_NULLABLE DeviceState::unsafe_arena_release_my_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.DeviceState.my_node)

  _impl_._has_bits_[0] &= ~0x00000001U;
  ::meshtastic::MyNodeInfo* temp = _impl_.my_node_;
  _impl_.my_node_ = nullptr;
  return temp;
}
inline ::meshtastic::MyNodeInfo* PROTOBUF_NONNULL DeviceState::_internal_mutable_my_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.my_node_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::meshtastic::MyNodeInfo>(GetArena());
    _impl_.my_node_ = reinterpret_cast<::meshtastic::MyNodeInfo*>(p);
  }
  return _impl_.my_node_;
}
inline ::meshtastic::MyNodeInfo* PROTOBUF_NONNULL DeviceState::mutable_my_node()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001U;
  ::meshtastic::MyNodeInfo* _msg = _internal_mutable_my_node();
  // @@protoc_insertion_point(field_mutable:meshtastic.DeviceState.my_node)
  return _msg;
}
inline void DeviceState::set_allocated_my_node(::meshtastic::MyNodeInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.my_node_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }

  _impl_.my_node_ = reinterpret_cast<::meshtastic::MyNodeInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:meshtastic.DeviceState.my_node)
}

// .meshtastic.User owner = 3;
inline bool DeviceState::has_owner() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002U) != 0;
  PROTOBUF_ASSUME(!value || _impl_.owner_ != nullptr);
  return value;
}
inline const ::meshtastic::User& DeviceState::_internal_owner() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::meshtastic::User* p = _impl_.owner_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::User&>(::meshtastic::_User_default_instance_);
}
inline const ::meshtastic::User& DeviceState::owner() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.DeviceState.owner)
  return _internal_owner();
}
inline void DeviceState::unsafe_arena_set_allocated_owner(
    ::meshtastic::User* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.owner_);
  }
  _impl_.owner_ = reinterpret_cast<::meshtastic::User*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002U;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.DeviceState.owner)
}
inline ::meshtastic::User* PROTOBUF_NULLABLE DeviceState::release_owner() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002U;
  ::meshtastic::User* released = _impl_.owner_;
  _impl_.owner_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::meshtastic::User* PROTOBUF_NULLABLE DeviceState::unsafe_arena_release_owner() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.DeviceState.owner)

  _impl_._has_bits_[0] &= ~0x00000002U;
  ::meshtastic::User* temp = _impl_.owner_;
  _impl_.owner_ = nullptr;
  return temp;
}
inline ::meshtastic::User* PROTOBUF_NONNULL DeviceState::_internal_mutable_owner() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.owner_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::meshtastic::User>(GetArena());
    _impl_.owner_ = reinterpret_cast<::meshtastic::User*>(p);
  }
  return _impl_.owner_;
}
inline ::meshtastic::User* PROTOBUF_NONNULL DeviceState::mutable_owner()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002U;
  ::meshtastic::User* _msg = _internal_mutable_owner();
  // @@protoc_insertion_point(field_mutable:meshtastic.DeviceState.owner)
  return _msg;
}
inline void DeviceState::set_allocated_owner(::meshtastic::User* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.owner_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002U;
  }

  _impl_.owner_ = reinterpret_cast<::meshtastic::User*>(value);
  // @@protoc_insertion_point(field_set_allocated:meshtastic.DeviceState.owner)
}

// repeated .meshtastic.MeshPacket receive_queue = 5;
inline int DeviceState::_internal_receive_queue_size() const {
  return _internal_receive_queue().size();
}
inline int DeviceState::receive_queue_size() const {
  return _internal_receive_queue_size();
}
inline ::meshtastic::MeshPacket* PROTOBUF_NONNULL DeviceState::mutable_receive_queue(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:meshtastic.DeviceState.receive_queue)
  return _internal_mutable_receive_queue()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::meshtastic::MeshPacket>* PROTOBUF_NONNULL DeviceState::mutable_receive_queue()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:meshtastic.DeviceState.receive_queue)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_receive_queue();
}
inline const ::meshtastic::MeshPacket& DeviceState::receive_queue(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.DeviceState.receive_queue)
  return _internal_receive_queue().Get(index);
}
inline ::meshtastic::MeshPacket* PROTOBUF_NONNULL DeviceState::add_receive_queue()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::meshtastic::MeshPacket* _add = _internal_mutable_receive_queue()->Add();
  // @@protoc_insertion_point(field_add:meshtastic.DeviceState.receive_queue)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::meshtastic::MeshPacket>& DeviceState::receive_queue() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:meshtastic.DeviceState.receive_queue)
  return _internal_receive_queue();
}
inline const ::google::protobuf::RepeatedPtrField<::meshtastic::MeshPacket>&
DeviceState::_internal_receive_queue() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.receive_queue_;
}
inline ::google::protobuf::RepeatedPtrField<::meshtastic::MeshPacket>* PROTOBUF_NONNULL
DeviceState::_internal_mutable_receive_queue() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.receive_queue_;
}

// uint32 version = 8;
inline void DeviceState::clear_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010U;
}
inline ::uint32_t DeviceState::version() const {
  // @@protoc_insertion_point(field_get:meshtastic.DeviceState.version)
  return _internal_version();
}
inline void DeviceState::set_version(::uint32_t value) {
  _internal_set_version(value);
  _impl_._has_bits_[0] |= 0x00000010U;
  // @@protoc_insertion_point(field_set:meshtastic.DeviceState.version)
}
inline ::uint32_t DeviceState::_internal_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.version_;
}
inline void DeviceState::_internal_set_version(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_ = value;
}

// .meshtastic.MeshPacket rx_text_message = 7;
inline bool DeviceState::has_rx_text_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004U) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rx_text_message_ != nullptr);
  return value;
}
inline const ::meshtastic::MeshPacket& DeviceState::_internal_rx_text_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::meshtastic::MeshPacket* p = _impl_.rx_text_message_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::MeshPacket&>(::meshtastic::_MeshPacket_default_instance_);
}
inline const ::meshtastic::MeshPacket& DeviceState::rx_text_message() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.DeviceState.rx_text_message)
  return _internal_rx_text_message();
}
inline void DeviceState::unsafe_arena_set_allocated_rx_text_message(
    ::meshtastic::MeshPacket* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rx_text_message_);
  }
  _impl_.rx_text_message_ = reinterpret_cast<::meshtastic::MeshPacket*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004U;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.DeviceState.rx_text_message)
}
inline ::meshtastic::MeshPacket* PROTOBUF_NULLABLE DeviceState::release_rx_text_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004U;
  ::meshtastic::MeshPacket* released = _impl_.rx_text_message_;
  _impl_.rx_text_message_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::meshtastic::MeshPacket* PROTOBUF_NULLABLE DeviceState::unsafe_arena_release_rx_text_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.DeviceState.rx_text_message)

  _impl_._has_bits_[0] &= ~0x00000004U;
  ::meshtastic::MeshPacket* temp = _impl_.rx_text_message_;
  _impl_.rx_text_message_ = nullptr;
  return temp;
}
inline ::meshtastic::MeshPacket* PROTOBUF_NONNULL DeviceState::_internal_mutable_rx_text_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rx_text_message_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::meshtastic::MeshPacket>(GetArena());
    _impl_.rx_text_message_ = reinterpret_cast<::meshtastic::MeshPacket*>(p);
  }
  return _impl_.rx_text_message_;
}
inline ::meshtastic::MeshPacket* PROTOBUF_NONNULL DeviceState::mutable_rx_text_message()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004U;
  ::meshtastic::MeshPacket* _msg = _internal_mutable_rx_text_message();
  // @@protoc_insertion_point(field_mutable:meshtastic.DeviceState.rx_text_message)
  return _msg;
}
inline void DeviceState::set_allocated_rx_text_message(::meshtastic::MeshPacket* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rx_text_message_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004U;
  }

  _impl_.rx_text_message_ = reinterpret_cast<::meshtastic::MeshPacket*>(value);
  // @@protoc_insertion_point(field_set_allocated:meshtastic.DeviceState.rx_text_message)
}

// bool no_save = 9 [deprecated = true];
inline void DeviceState::clear_no_save() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.no_save_ = false;
  _impl_._has_bits_[0] &= ~0x00000020U;
}
inline bool DeviceState::no_save() const {
  // @@protoc_insertion_point(field_get:meshtastic.DeviceState.no_save)
  return _internal_no_save();
}
inline void DeviceState::set_no_save(bool value) {
  _internal_set_no_save(value);
  _impl_._has_bits_[0] |= 0x00000020U;
  // @@protoc_insertion_point(field_set:meshtastic.DeviceState.no_save)
}
inline bool DeviceState::_internal_no_save() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.no_save_;
}
inline void DeviceState::_internal_set_no_save(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.no_save_ = value;
}

// bool did_gps_reset = 11 [deprecated = true];
inline void DeviceState::clear_did_gps_reset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.did_gps_reset_ = false;
  _impl_._has_bits_[0] &= ~0x00000040U;
}
inline bool DeviceState::did_gps_reset() const {
  // @@protoc_insertion_point(field_get:meshtastic.DeviceState.did_gps_reset)
  return _internal_did_gps_reset();
}
inline void DeviceState::set_did_gps_reset(bool value) {
  _internal_set_did_gps_reset(value);
  _impl_._has_bits_[0] |= 0x00000040U;
  // @@protoc_insertion_point(field_set:meshtastic.DeviceState.did_gps_reset)
}
inline bool DeviceState::_internal_did_gps_reset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.did_gps_reset_;
}
inline void DeviceState::_internal_set_did_gps_reset(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.did_gps_reset_ = value;
}

// .meshtastic.MeshPacket rx_waypoint = 12;
inline bool DeviceState::has_rx_waypoint() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008U) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rx_waypoint_ != nullptr);
  return value;
}
inline const ::meshtastic::MeshPacket& DeviceState::_internal_rx_waypoint() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::meshtastic::MeshPacket* p = _impl_.rx_waypoint_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::MeshPacket&>(::meshtastic::_MeshPacket_default_instance_);
}
inline const ::meshtastic::MeshPacket& DeviceState::rx_waypoint() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.DeviceState.rx_waypoint)
  return _internal_rx_waypoint();
}
inline void DeviceState::unsafe_arena_set_allocated_rx_waypoint(
    ::meshtastic::MeshPacket* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rx_waypoint_);
  }
  _impl_.rx_waypoint_ = reinterpret_cast<::meshtastic::MeshPacket*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008U;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.DeviceState.rx_waypoint)
}
inline ::meshtastic::MeshPacket* PROTOBUF_NULLABLE DeviceState::release_rx_waypoint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008U;
  ::meshtastic::MeshPacket* released = _impl_.rx_waypoint_;
  _impl_.rx_waypoint_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::meshtastic::MeshPacket* PROTOBUF_NULLABLE DeviceState::unsafe_arena_release_rx_waypoint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.DeviceState.rx_waypoint)

  _impl_._has_bits_[0] &= ~0x00000008U;
  ::meshtastic::MeshPacket* temp = _impl_.rx_waypoint_;
  _impl_.rx_waypoint_ = nullptr;
  return temp;
}
inline ::meshtastic::MeshPacket* PROTOBUF_NONNULL DeviceState::_internal_mutable_rx_waypoint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.rx_waypoint_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::meshtastic::MeshPacket>(GetArena());
    _impl_.rx_waypoint_ = reinterpret_cast<::meshtastic::MeshPacket*>(p);
  }
  return _impl_.rx_waypoint_;
}
inline ::meshtastic::MeshPacket* PROTOBUF_NONNULL DeviceState::mutable_rx_waypoint()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008U;
  ::meshtastic::MeshPacket* _msg = _internal_mutable_rx_waypoint();
  // @@protoc_insertion_point(field_mutable:meshtastic.DeviceState.rx_waypoint)
  return _msg;
}
inline void DeviceState::set_allocated_rx_waypoint(::meshtastic::MeshPacket* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rx_waypoint_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008U;
  }

  _impl_.rx_waypoint_ = reinterpret_cast<::meshtastic::MeshPacket*>(value);
  // @@protoc_insertion_point(field_set_allocated:meshtastic.DeviceState.rx_waypoint)
}

// repeated .meshtastic.NodeRemoteHardwarePin node_remote_hardware_pins = 13;
inline int DeviceState::_internal_node_remote_hardware_pins_size() const {
  return _internal_node_remote_hardware_pins().size();
}
inline int DeviceState::node_remote_hardware_pins_size() const {
  return _internal_node_remote_hardware_pins_size();
}
inline ::meshtastic::NodeRemoteHardwarePin* PROTOBUF_NONNULL DeviceState::mutable_node_remote_hardware_pins(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:meshtastic.DeviceState.node_remote_hardware_pins)
  return _internal_mutable_node_remote_hardware_pins()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::meshtastic::NodeRemoteHardwarePin>* PROTOBUF_NONNULL DeviceState::mutable_node_remote_hardware_pins()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:meshtastic.DeviceState.node_remote_hardware_pins)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_node_remote_hardware_pins();
}
inline const ::meshtastic::NodeRemoteHardwarePin& DeviceState::node_remote_hardware_pins(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.DeviceState.node_remote_hardware_pins)
  return _internal_node_remote_hardware_pins().Get(index);
}
inline ::meshtastic::NodeRemoteHardwarePin* PROTOBUF_NONNULL DeviceState::add_node_remote_hardware_pins()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::meshtastic::NodeRemoteHardwarePin* _add = _internal_mutable_node_remote_hardware_pins()->Add();
  // @@protoc_insertion_point(field_add:meshtastic.DeviceState.node_remote_hardware_pins)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::meshtastic::NodeRemoteHardwarePin>& DeviceState::node_remote_hardware_pins() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:meshtastic.DeviceState.node_remote_hardware_pins)
  return _internal_node_remote_hardware_pins();
}
inline const ::google::protobuf::RepeatedPtrField<::meshtastic::NodeRemoteHardwarePin>&
DeviceState::_internal_node_remote_hardware_pins() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.node_remote_hardware_pins_;
}
inline ::google::protobuf::RepeatedPtrField<::meshtastic::NodeRemoteHardwarePin>* PROTOBUF_NONNULL
DeviceState::_internal_mutable_node_remote_hardware_pins() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.node_remote_hardware_pins_;
}

// -------------------------------------------------------------------

// NodeDatabase

// uint32 version = 1;
inline void NodeDatabase::clear_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline ::uint32_t NodeDatabase::version() const {
  // @@protoc_insertion_point(field_get:meshtastic.NodeDatabase.version)
  return _internal_version();
}
inline void NodeDatabase::set_version(::uint32_t value) {
  _internal_set_version(value);
  _impl_._has_bits_[0] |= 0x00000001U;
  // @@protoc_insertion_point(field_set:meshtastic.NodeDatabase.version)
}
inline ::uint32_t NodeDatabase::_internal_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.version_;
}
inline void NodeDatabase::_internal_set_version(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_ = value;
}

// repeated .meshtastic.NodeInfoLite nodes = 2 [(.nanopb) = {
inline int NodeDatabase::_internal_nodes_size() const {
  return _internal_nodes().size();
}
inline int NodeDatabase::nodes_size() const {
  return _internal_nodes_size();
}
inline void NodeDatabase::clear_nodes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nodes_.Clear();
}
inline ::meshtastic::NodeInfoLite* PROTOBUF_NONNULL NodeDatabase::mutable_nodes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:meshtastic.NodeDatabase.nodes)
  return _internal_mutable_nodes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::meshtastic::NodeInfoLite>* PROTOBUF_NONNULL NodeDatabase::mutable_nodes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:meshtastic.NodeDatabase.nodes)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_nodes();
}
inline const ::meshtastic::NodeInfoLite& NodeDatabase::nodes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.NodeDatabase.nodes)
  return _internal_nodes().Get(index);
}
inline ::meshtastic::NodeInfoLite* PROTOBUF_NONNULL NodeDatabase::add_nodes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::meshtastic::NodeInfoLite* _add = _internal_mutable_nodes()->Add();
  // @@protoc_insertion_point(field_add:meshtastic.NodeDatabase.nodes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::meshtastic::NodeInfoLite>& NodeDatabase::nodes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:meshtastic.NodeDatabase.nodes)
  return _internal_nodes();
}
inline const ::google::protobuf::RepeatedPtrField<::meshtastic::NodeInfoLite>&
NodeDatabase::_internal_nodes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.nodes_;
}
inline ::google::protobuf::RepeatedPtrField<::meshtastic::NodeInfoLite>* PROTOBUF_NONNULL
NodeDatabase::_internal_mutable_nodes() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.nodes_;
}

// -------------------------------------------------------------------

// ChannelFile

// repeated .meshtastic.Channel channels = 1;
inline int ChannelFile::_internal_channels_size() const {
  return _internal_channels().size();
}
inline int ChannelFile::channels_size() const {
  return _internal_channels_size();
}
inline ::meshtastic::Channel* PROTOBUF_NONNULL ChannelFile::mutable_channels(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:meshtastic.ChannelFile.channels)
  return _internal_mutable_channels()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::meshtastic::Channel>* PROTOBUF_NONNULL ChannelFile::mutable_channels()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:meshtastic.ChannelFile.channels)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_channels();
}
inline const ::meshtastic::Channel& ChannelFile::channels(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.ChannelFile.channels)
  return _internal_channels().Get(index);
}
inline ::meshtastic::Channel* PROTOBUF_NONNULL ChannelFile::add_channels()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::meshtastic::Channel* _add = _internal_mutable_channels()->Add();
  // @@protoc_insertion_point(field_add:meshtastic.ChannelFile.channels)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::meshtastic::Channel>& ChannelFile::channels() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:meshtastic.ChannelFile.channels)
  return _internal_channels();
}
inline const ::google::protobuf::RepeatedPtrField<::meshtastic::Channel>&
ChannelFile::_internal_channels() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.channels_;
}
inline ::google::protobuf::RepeatedPtrField<::meshtastic::Channel>* PROTOBUF_NONNULL
ChannelFile::_internal_mutable_channels() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.channels_;
}

// uint32 version = 2;
inline void ChannelFile::clear_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline ::uint32_t ChannelFile::version() const {
  // @@protoc_insertion_point(field_get:meshtastic.ChannelFile.version)
  return _internal_version();
}
inline void ChannelFile::set_version(::uint32_t value) {
  _internal_set_version(value);
  _impl_._has_bits_[0] |= 0x00000001U;
  // @@protoc_insertion_point(field_set:meshtastic.ChannelFile.version)
}
inline ::uint32_t ChannelFile::_internal_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.version_;
}
inline void ChannelFile::_internal_set_version(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_ = value;
}

// -------------------------------------------------------------------

// BackupPreferences

// uint32 version = 1;
inline void BackupPreferences::clear_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010U;
}
inline ::uint32_t BackupPreferences::version() const {
  // @@protoc_insertion_point(field_get:meshtastic.BackupPreferences.version)
  return _internal_version();
}
inline void BackupPreferences::set_version(::uint32_t value) {
  _internal_set_version(value);
  _impl_._has_bits_[0] |= 0x00000010U;
  // @@protoc_insertion_point(field_set:meshtastic.BackupPreferences.version)
}
inline ::uint32_t BackupPreferences::_internal_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.version_;
}
inline void BackupPreferences::_internal_set_version(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_ = value;
}

// fixed32 timestamp = 2;
inline void BackupPreferences::clear_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020U;
}
inline ::uint32_t BackupPreferences::timestamp() const {
  // @@protoc_insertion_point(field_get:meshtastic.BackupPreferences.timestamp)
  return _internal_timestamp();
}
inline void BackupPreferences::set_timestamp(::uint32_t value) {
  _internal_set_timestamp(value);
  _impl_._has_bits_[0] |= 0x00000020U;
  // @@protoc_insertion_point(field_set:meshtastic.BackupPreferences.timestamp)
}
inline ::uint32_t BackupPreferences::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timestamp_;
}
inline void BackupPreferences::_internal_set_timestamp(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = value;
}

// .meshtastic.LocalConfig config = 3;
inline bool BackupPreferences::has_config() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001U) != 0;
  PROTOBUF_ASSUME(!value || _impl_.config_ != nullptr);
  return value;
}
inline const ::meshtastic::LocalConfig& BackupPreferences::_internal_config() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::meshtastic::LocalConfig* p = _impl_.config_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::LocalConfig&>(::meshtastic::_LocalConfig_default_instance_);
}
inline const ::meshtastic::LocalConfig& BackupPreferences::config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.BackupPreferences.config)
  return _internal_config();
}
inline void BackupPreferences::unsafe_arena_set_allocated_config(
    ::meshtastic::LocalConfig* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.config_);
  }
  _impl_.config_ = reinterpret_cast<::meshtastic::LocalConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.BackupPreferences.config)
}
inline ::meshtastic::LocalConfig* PROTOBUF_NULLABLE BackupPreferences::release_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001U;
  ::meshtastic::LocalConfig* released = _impl_.config_;
  _impl_.config_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::meshtastic::LocalConfig* PROTOBUF_NULLABLE BackupPreferences::unsafe_arena_release_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.BackupPreferences.config)

  _impl_._has_bits_[0] &= ~0x00000001U;
  ::meshtastic::LocalConfig* temp = _impl_.config_;
  _impl_.config_ = nullptr;
  return temp;
}
inline ::meshtastic::LocalConfig* PROTOBUF_NONNULL BackupPreferences::_internal_mutable_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.config_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::meshtastic::LocalConfig>(GetArena());
    _impl_.config_ = reinterpret_cast<::meshtastic::LocalConfig*>(p);
  }
  return _impl_.config_;
}
inline ::meshtastic::LocalConfig* PROTOBUF_NONNULL BackupPreferences::mutable_config()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001U;
  ::meshtastic::LocalConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:meshtastic.BackupPreferences.config)
  return _msg;
}
inline void BackupPreferences::set_allocated_config(::meshtastic::LocalConfig* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }

  _impl_.config_ = reinterpret_cast<::meshtastic::LocalConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:meshtastic.BackupPreferences.config)
}

// .meshtastic.LocalModuleConfig module_config = 4;
inline bool BackupPreferences::has_module_config() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002U) != 0;
  PROTOBUF_ASSUME(!value || _impl_.module_config_ != nullptr);
  return value;
}
inline const ::meshtastic::LocalModuleConfig& BackupPreferences::_internal_module_config() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::meshtastic::LocalModuleConfig* p = _impl_.module_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::LocalModuleConfig&>(::meshtastic::_LocalModuleConfig_default_instance_);
}
inline const ::meshtastic::LocalModuleConfig& BackupPreferences::module_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.BackupPreferences.module_config)
  return _internal_module_config();
}
inline void BackupPreferences::unsafe_arena_set_allocated_module_config(
    ::meshtastic::LocalModuleConfig* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.module_config_);
  }
  _impl_.module_config_ = reinterpret_cast<::meshtastic::LocalModuleConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002U;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.BackupPreferences.module_config)
}
inline ::meshtastic::LocalModuleConfig* PROTOBUF_NULLABLE BackupPreferences::release_module_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002U;
  ::meshtastic::LocalModuleConfig* released = _impl_.module_config_;
  _impl_.module_config_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::meshtastic::LocalModuleConfig* PROTOBUF_NULLABLE BackupPreferences::unsafe_arena_release_module_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.BackupPreferences.module_config)

  _impl_._has_bits_[0] &= ~0x00000002U;
  ::meshtastic::LocalModuleConfig* temp = _impl_.module_config_;
  _impl_.module_config_ = nullptr;
  return temp;
}
inline ::meshtastic::LocalModuleConfig* PROTOBUF_NONNULL BackupPreferences::_internal_mutable_module_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.module_config_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::meshtastic::LocalModuleConfig>(GetArena());
    _impl_.module_config_ = reinterpret_cast<::meshtastic::LocalModuleConfig*>(p);
  }
  return _impl_.module_config_;
}
inline ::meshtastic::LocalModuleConfig* PROTOBUF_NONNULL BackupPreferences::mutable_module_config()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002U;
  ::meshtastic::LocalModuleConfig* _msg = _internal_mutable_module_config();
  // @@protoc_insertion_point(field_mutable:meshtastic.BackupPreferences.module_config)
  return _msg;
}
inline void BackupPreferences::set_allocated_module_config(::meshtastic::LocalModuleConfig* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.module_config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002U;
  }

  _impl_.module_config_ = reinterpret_cast<::meshtastic::LocalModuleConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:meshtastic.BackupPreferences.module_config)
}

// .meshtastic.ChannelFile channels = 5;
inline bool BackupPreferences::has_channels() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004U) != 0;
  PROTOBUF_ASSUME(!value || _impl_.channels_ != nullptr);
  return value;
}
inline void BackupPreferences::clear_channels() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.channels_ != nullptr) _impl_.channels_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004U;
}
inline const ::meshtastic::ChannelFile& BackupPreferences::_internal_channels() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::meshtastic::ChannelFile* p = _impl_.channels_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::ChannelFile&>(::meshtastic::_ChannelFile_default_instance_);
}
inline const ::meshtastic::ChannelFile& BackupPreferences::channels() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.BackupPreferences.channels)
  return _internal_channels();
}
inline void BackupPreferences::unsafe_arena_set_allocated_channels(
    ::meshtastic::ChannelFile* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.channels_);
  }
  _impl_.channels_ = reinterpret_cast<::meshtastic::ChannelFile*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004U;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.BackupPreferences.channels)
}
inline ::meshtastic::ChannelFile* PROTOBUF_NULLABLE BackupPreferences::release_channels() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004U;
  ::meshtastic::ChannelFile* released = _impl_.channels_;
  _impl_.channels_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::meshtastic::ChannelFile* PROTOBUF_NULLABLE BackupPreferences::unsafe_arena_release_channels() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.BackupPreferences.channels)

  _impl_._has_bits_[0] &= ~0x00000004U;
  ::meshtastic::ChannelFile* temp = _impl_.channels_;
  _impl_.channels_ = nullptr;
  return temp;
}
inline ::meshtastic::ChannelFile* PROTOBUF_NONNULL BackupPreferences::_internal_mutable_channels() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.channels_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::meshtastic::ChannelFile>(GetArena());
    _impl_.channels_ = reinterpret_cast<::meshtastic::ChannelFile*>(p);
  }
  return _impl_.channels_;
}
inline ::meshtastic::ChannelFile* PROTOBUF_NONNULL BackupPreferences::mutable_channels()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004U;
  ::meshtastic::ChannelFile* _msg = _internal_mutable_channels();
  // @@protoc_insertion_point(field_mutable:meshtastic.BackupPreferences.channels)
  return _msg;
}
inline void BackupPreferences::set_allocated_channels(::meshtastic::ChannelFile* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.channels_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004U;
  }

  _impl_.channels_ = reinterpret_cast<::meshtastic::ChannelFile*>(value);
  // @@protoc_insertion_point(field_set_allocated:meshtastic.BackupPreferences.channels)
}

// .meshtastic.User owner = 6;
inline bool BackupPreferences::has_owner() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008U) != 0;
  PROTOBUF_ASSUME(!value || _impl_.owner_ != nullptr);
  return value;
}
inline const ::meshtastic::User& BackupPreferences::_internal_owner() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::meshtastic::User* p = _impl_.owner_;
  return p != nullptr ? *p : reinterpret_cast<const ::meshtastic::User&>(::meshtastic::_User_default_instance_);
}
inline const ::meshtastic::User& BackupPreferences::owner() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:meshtastic.BackupPreferences.owner)
  return _internal_owner();
}
inline void BackupPreferences::unsafe_arena_set_allocated_owner(
    ::meshtastic::User* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.owner_);
  }
  _impl_.owner_ = reinterpret_cast<::meshtastic::User*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008U;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:meshtastic.BackupPreferences.owner)
}
inline ::meshtastic::User* PROTOBUF_NULLABLE BackupPreferences::release_owner() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008U;
  ::meshtastic::User* released = _impl_.owner_;
  _impl_.owner_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::meshtastic::User* PROTOBUF_NULLABLE BackupPreferences::unsafe_arena_release_owner() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:meshtastic.BackupPreferences.owner)

  _impl_._has_bits_[0] &= ~0x00000008U;
  ::meshtastic::User* temp = _impl_.owner_;
  _impl_.owner_ = nullptr;
  return temp;
}
inline ::meshtastic::User* PROTOBUF_NONNULL BackupPreferences::_internal_mutable_owner() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.owner_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::meshtastic::User>(GetArena());
    _impl_.owner_ = reinterpret_cast<::meshtastic::User*>(p);
  }
  return _impl_.owner_;
}
inline ::meshtastic::User* PROTOBUF_NONNULL BackupPreferences::mutable_owner()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008U;
  ::meshtastic::User* _msg = _internal_mutable_owner();
  // @@protoc_insertion_point(field_mutable:meshtastic.BackupPreferences.owner)
  return _msg;
}
inline void BackupPreferences::set_allocated_owner(::meshtastic::User* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.owner_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008U;
  }

  _impl_.owner_ = reinterpret_cast<::meshtastic::User*>(value);
  // @@protoc_insertion_point(field_set_allocated:meshtastic.BackupPreferences.owner)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace meshtastic


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // meshtastic_2fdeviceonly_2eproto_2epb_2eh
