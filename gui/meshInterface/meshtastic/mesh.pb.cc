// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: meshtastic/mesh.proto
// Protobuf C++ Version: 6.31.1

#include "meshtastic/mesh.pb.h"

#include <algorithm>
#include <type_traits>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/generated_message_tctable_impl.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::google::protobuf;
namespace _pbi = ::google::protobuf::internal;
namespace _fl = ::google::protobuf::internal::field_layout;
namespace meshtastic {

inline constexpr resend_chunks::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : chunks_{},
        _chunks_cached_byte_size_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR resend_chunks::resend_chunks(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(resend_chunks_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct resend_chunksDefaultTypeInternal {
  PROTOBUF_CONSTEXPR resend_chunksDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~resend_chunksDefaultTypeInternal() {}
  union {
    resend_chunks _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 resend_chunksDefaultTypeInternal _resend_chunks_default_instance_;

inline constexpr Waypoint::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        description_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        id_{0u},
        latitude_i_{0},
        longitude_i_{0},
        expire_{0u},
        locked_to_{0u},
        icon_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR Waypoint::Waypoint(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(Waypoint_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct WaypointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WaypointDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~WaypointDefaultTypeInternal() {}
  union {
    Waypoint _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WaypointDefaultTypeInternal _Waypoint_default_instance_;

inline constexpr User::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        long_name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        short_name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        macaddr_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        public_key_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        hw_model_{static_cast< ::meshtastic::HardwareModel >(0)},
        role_{static_cast< ::meshtastic::Config_DeviceConfig_Role >(0)},
        is_licensed_{false},
        is_unmessagable_{false} {}

template <typename>
PROTOBUF_CONSTEXPR User::User(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(User_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct UserDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserDefaultTypeInternal() {}
  union {
    User _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserDefaultTypeInternal _User_default_instance_;

inline constexpr RouteDiscovery::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : route_{},
        snr_towards_{},
        _snr_towards_cached_byte_size_{0},
        route_back_{},
        snr_back_{},
        _snr_back_cached_byte_size_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR RouteDiscovery::RouteDiscovery(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(RouteDiscovery_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct RouteDiscoveryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RouteDiscoveryDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RouteDiscoveryDefaultTypeInternal() {}
  union {
    RouteDiscovery _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RouteDiscoveryDefaultTypeInternal _RouteDiscovery_default_instance_;

inline constexpr QueueStatus::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        res_{0},
        free_{0u},
        maxlen_{0u},
        mesh_packet_id_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR QueueStatus::QueueStatus(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(QueueStatus_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct QueueStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR QueueStatusDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~QueueStatusDefaultTypeInternal() {}
  union {
    QueueStatus _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 QueueStatusDefaultTypeInternal _QueueStatus_default_instance_;

inline constexpr Position::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        latitude_i_{0},
        longitude_i_{0},
        altitude_{0},
        time_{0u},
        location_source_{static_cast< ::meshtastic::Position_LocSource >(0)},
        altitude_source_{static_cast< ::meshtastic::Position_AltSource >(0)},
        timestamp_{0u},
        timestamp_millis_adjust_{0},
        altitude_hae_{0},
        altitude_geoidal_separation_{0},
        pdop_{0u},
        hdop_{0u},
        vdop_{0u},
        gps_accuracy_{0u},
        ground_speed_{0u},
        ground_track_{0u},
        fix_quality_{0u},
        fix_type_{0u},
        sats_in_view_{0u},
        sensor_id_{0u},
        next_update_{0u},
        seq_number_{0u},
        precision_bits_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR Position::Position(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(Position_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct PositionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PositionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PositionDefaultTypeInternal() {}
  union {
    Position _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PositionDefaultTypeInternal _Position_default_instance_;

inline constexpr Neighbor::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        node_id_{0u},
        snr_{0},
        last_rx_time_{0u},
        node_broadcast_interval_secs_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR Neighbor::Neighbor(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(Neighbor_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct NeighborDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NeighborDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~NeighborDefaultTypeInternal() {}
  union {
    Neighbor _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NeighborDefaultTypeInternal _Neighbor_default_instance_;

inline constexpr MyNodeInfo::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        device_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        pio_env_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        my_node_num_{0u},
        reboot_count_{0u},
        min_app_version_{0u},
        firmware_edition_{static_cast< ::meshtastic::FirmwareEdition >(0)},
        nodedb_count_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR MyNodeInfo::MyNodeInfo(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(MyNodeInfo_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct MyNodeInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MyNodeInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MyNodeInfoDefaultTypeInternal() {}
  union {
    MyNodeInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MyNodeInfoDefaultTypeInternal _MyNodeInfo_default_instance_;

inline constexpr MqttClientProxyMessage::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        topic_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        retained_{false},
        payload_variant_{},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR MqttClientProxyMessage::MqttClientProxyMessage(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(MqttClientProxyMessage_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct MqttClientProxyMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MqttClientProxyMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MqttClientProxyMessageDefaultTypeInternal() {}
  union {
    MqttClientProxyMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MqttClientProxyMessageDefaultTypeInternal _MqttClientProxyMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR LowEntropyKey::LowEntropyKey(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::internal::ZeroFieldsBase(LowEntropyKey_class_data_.base()){}
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::internal::ZeroFieldsBase() {
}
#endif  // PROTOBUF_CUSTOM_VTABLE
struct LowEntropyKeyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LowEntropyKeyDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LowEntropyKeyDefaultTypeInternal() {}
  union {
    LowEntropyKey _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LowEntropyKeyDefaultTypeInternal _LowEntropyKey_default_instance_;

inline constexpr LogRecord::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        message_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        source_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        time_{0u},
        level_{static_cast< ::meshtastic::LogRecord_Level >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR LogRecord::LogRecord(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(LogRecord_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct LogRecordDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LogRecordDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LogRecordDefaultTypeInternal() {}
  union {
    LogRecord _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LogRecordDefaultTypeInternal _LogRecord_default_instance_;

inline constexpr KeyVerificationNumberRequest::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        remote_longname_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        nonce_{::uint64_t{0u}} {}

template <typename>
PROTOBUF_CONSTEXPR KeyVerificationNumberRequest::KeyVerificationNumberRequest(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(KeyVerificationNumberRequest_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct KeyVerificationNumberRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KeyVerificationNumberRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KeyVerificationNumberRequestDefaultTypeInternal() {}
  union {
    KeyVerificationNumberRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KeyVerificationNumberRequestDefaultTypeInternal _KeyVerificationNumberRequest_default_instance_;

inline constexpr KeyVerificationNumberInform::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        remote_longname_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        nonce_{::uint64_t{0u}},
        security_number_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR KeyVerificationNumberInform::KeyVerificationNumberInform(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(KeyVerificationNumberInform_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct KeyVerificationNumberInformDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KeyVerificationNumberInformDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KeyVerificationNumberInformDefaultTypeInternal() {}
  union {
    KeyVerificationNumberInform _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KeyVerificationNumberInformDefaultTypeInternal _KeyVerificationNumberInform_default_instance_;

inline constexpr KeyVerificationFinal::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        remote_longname_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        verification_characters_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        nonce_{::uint64_t{0u}},
        issender_{false} {}

template <typename>
PROTOBUF_CONSTEXPR KeyVerificationFinal::KeyVerificationFinal(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(KeyVerificationFinal_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct KeyVerificationFinalDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KeyVerificationFinalDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KeyVerificationFinalDefaultTypeInternal() {}
  union {
    KeyVerificationFinal _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KeyVerificationFinalDefaultTypeInternal _KeyVerificationFinal_default_instance_;

inline constexpr KeyVerification::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        hash1_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        hash2_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        nonce_{::uint64_t{0u}} {}

template <typename>
PROTOBUF_CONSTEXPR KeyVerification::KeyVerification(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(KeyVerification_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct KeyVerificationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KeyVerificationDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KeyVerificationDefaultTypeInternal() {}
  union {
    KeyVerification _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KeyVerificationDefaultTypeInternal _KeyVerification_default_instance_;

inline constexpr Heartbeat::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        nonce_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR Heartbeat::Heartbeat(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(Heartbeat_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct HeartbeatDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HeartbeatDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~HeartbeatDefaultTypeInternal() {}
  union {
    Heartbeat _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HeartbeatDefaultTypeInternal _Heartbeat_default_instance_;

inline constexpr FileInfo::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        file_name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        size_bytes_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR FileInfo::FileInfo(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(FileInfo_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct FileInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FileInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~FileInfoDefaultTypeInternal() {}
  union {
    FileInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FileInfoDefaultTypeInternal _FileInfo_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR DuplicatedPublicKey::DuplicatedPublicKey(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::internal::ZeroFieldsBase(DuplicatedPublicKey_class_data_.base()){}
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::internal::ZeroFieldsBase() {
}
#endif  // PROTOBUF_CUSTOM_VTABLE
struct DuplicatedPublicKeyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DuplicatedPublicKeyDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DuplicatedPublicKeyDefaultTypeInternal() {}
  union {
    DuplicatedPublicKey _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DuplicatedPublicKeyDefaultTypeInternal _DuplicatedPublicKey_default_instance_;

inline constexpr DeviceMetadata::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        firmware_version_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        device_state_version_{0u},
        canshutdown_{false},
        haswifi_{false},
        hasbluetooth_{false},
        hasethernet_{false},
        role_{static_cast< ::meshtastic::Config_DeviceConfig_Role >(0)},
        position_flags_{0u},
        hw_model_{static_cast< ::meshtastic::HardwareModel >(0)},
        hasremotehardware_{false},
        haspkc_{false},
        excluded_modules_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR DeviceMetadata::DeviceMetadata(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(DeviceMetadata_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct DeviceMetadataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceMetadataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceMetadataDefaultTypeInternal() {}
  union {
    DeviceMetadata _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceMetadataDefaultTypeInternal _DeviceMetadata_default_instance_;

inline constexpr Data::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        payload_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        portnum_{static_cast< ::meshtastic::PortNum >(0)},
        want_response_{false},
        dest_{0u},
        source_{0u},
        request_id_{0u},
        reply_id_{0u},
        emoji_{0u},
        bitfield_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR Data::Data(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(Data_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct DataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DataDefaultTypeInternal() {}
  union {
    Data _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DataDefaultTypeInternal _Data_default_instance_;

inline constexpr Compressed::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        data_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        portnum_{static_cast< ::meshtastic::PortNum >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR Compressed::Compressed(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(Compressed_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct CompressedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CompressedDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CompressedDefaultTypeInternal() {}
  union {
    Compressed _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CompressedDefaultTypeInternal _Compressed_default_instance_;

inline constexpr ChunkedPayload::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        payload_chunk_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        payload_id_{0u},
        chunk_count_{0u},
        chunk_index_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR ChunkedPayload::ChunkedPayload(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(ChunkedPayload_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct ChunkedPayloadDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChunkedPayloadDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChunkedPayloadDefaultTypeInternal() {}
  union {
    ChunkedPayload _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChunkedPayloadDefaultTypeInternal _ChunkedPayload_default_instance_;

inline constexpr Routing::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : variant_{},
        _cached_size_{0},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR Routing::Routing(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(Routing_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct RoutingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RoutingDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RoutingDefaultTypeInternal() {}
  union {
    Routing _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RoutingDefaultTypeInternal _Routing_default_instance_;

inline constexpr NodeRemoteHardwarePin::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        pin_{nullptr},
        node_num_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR NodeRemoteHardwarePin::NodeRemoteHardwarePin(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(NodeRemoteHardwarePin_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct NodeRemoteHardwarePinDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NodeRemoteHardwarePinDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~NodeRemoteHardwarePinDefaultTypeInternal() {}
  union {
    NodeRemoteHardwarePin _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NodeRemoteHardwarePinDefaultTypeInternal _NodeRemoteHardwarePin_default_instance_;

inline constexpr NodeInfo::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        user_{nullptr},
        position_{nullptr},
        device_metrics_{nullptr},
        num_{0u},
        snr_{0},
        last_heard_{0u},
        channel_{0u},
        hops_away_{0u},
        via_mqtt_{false},
        is_favorite_{false},
        is_ignored_{false},
        is_key_manually_verified_{false} {}

template <typename>
PROTOBUF_CONSTEXPR NodeInfo::NodeInfo(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(NodeInfo_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct NodeInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NodeInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~NodeInfoDefaultTypeInternal() {}
  union {
    NodeInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NodeInfoDefaultTypeInternal _NodeInfo_default_instance_;

inline constexpr NeighborInfo::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        neighbors_{},
        node_id_{0u},
        last_sent_by_id_{0u},
        node_broadcast_interval_secs_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR NeighborInfo::NeighborInfo(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(NeighborInfo_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct NeighborInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NeighborInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~NeighborInfoDefaultTypeInternal() {}
  union {
    NeighborInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NeighborInfoDefaultTypeInternal _NeighborInfo_default_instance_;

inline constexpr MeshPacket::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        public_key_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        from_{0u},
        to_{0u},
        channel_{0u},
        id_{0u},
        rx_time_{0u},
        rx_snr_{0},
        hop_limit_{0u},
        priority_{static_cast< ::meshtastic::MeshPacket_Priority >(0)},
        rx_rssi_{0},
        delayed_{static_cast< ::meshtastic::MeshPacket_Delayed >(0)},
        want_ack_{false},
        via_mqtt_{false},
        pki_encrypted_{false},
        hop_start_{0u},
        next_hop_{0u},
        relay_node_{0u},
        tx_after_{0u},
        transport_mechanism_{static_cast< ::meshtastic::MeshPacket_TransportMechanism >(0)},
        payload_variant_{},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR MeshPacket::MeshPacket(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(MeshPacket_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct MeshPacketDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MeshPacketDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MeshPacketDefaultTypeInternal() {}
  union {
    MeshPacket _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MeshPacketDefaultTypeInternal _MeshPacket_default_instance_;

inline constexpr ClientNotification::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        message_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        reply_id_{0u},
        time_{0u},
        level_{static_cast< ::meshtastic::LogRecord_Level >(0)},
        payload_variant_{},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR ClientNotification::ClientNotification(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(ClientNotification_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct ClientNotificationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientNotificationDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientNotificationDefaultTypeInternal() {}
  union {
    ClientNotification _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientNotificationDefaultTypeInternal _ClientNotification_default_instance_;

inline constexpr ChunkedPayloadResponse::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        payload_id_{0u},
        payload_variant_{},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR ChunkedPayloadResponse::ChunkedPayloadResponse(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(ChunkedPayloadResponse_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct ChunkedPayloadResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChunkedPayloadResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChunkedPayloadResponseDefaultTypeInternal() {}
  union {
    ChunkedPayloadResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChunkedPayloadResponseDefaultTypeInternal _ChunkedPayloadResponse_default_instance_;

inline constexpr ToRadio::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : payload_variant_{},
        _cached_size_{0},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR ToRadio::ToRadio(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(ToRadio_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct ToRadioDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ToRadioDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ToRadioDefaultTypeInternal() {}
  union {
    ToRadio _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ToRadioDefaultTypeInternal _ToRadio_default_instance_;

inline constexpr FromRadio::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        id_{0u},
        payload_variant_{},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR FromRadio::FromRadio(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(FromRadio_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct FromRadioDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FromRadioDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~FromRadioDefaultTypeInternal() {}
  union {
    FromRadio _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FromRadioDefaultTypeInternal _FromRadio_default_instance_;
}  // namespace meshtastic
static const ::_pb::EnumDescriptor* PROTOBUF_NONNULL
    file_level_enum_descriptors_meshtastic_2fmesh_2eproto[12];
static constexpr const ::_pb::ServiceDescriptor *PROTOBUF_NONNULL *PROTOBUF_NULLABLE
    file_level_service_descriptors_meshtastic_2fmesh_2eproto = nullptr;
const ::uint32_t
    TableStruct_meshtastic_2fmesh_2eproto::offsets[] ABSL_ATTRIBUTE_SECTION_VARIABLE(
        protodesc_cold) = {
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::meshtastic::Position, _impl_._has_bits_),
        26, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::meshtastic::Position, _impl_.latitude_i_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::Position, _impl_.longitude_i_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::Position, _impl_.altitude_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::Position, _impl_.time_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::Position, _impl_.location_source_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::Position, _impl_.altitude_source_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::Position, _impl_.timestamp_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::Position, _impl_.timestamp_millis_adjust_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::Position, _impl_.altitude_hae_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::Position, _impl_.altitude_geoidal_separation_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::Position, _impl_.pdop_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::Position, _impl_.hdop_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::Position, _impl_.vdop_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::Position, _impl_.gps_accuracy_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::Position, _impl_.ground_speed_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::Position, _impl_.ground_track_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::Position, _impl_.fix_quality_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::Position, _impl_.fix_type_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::Position, _impl_.sats_in_view_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::Position, _impl_.sensor_id_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::Position, _impl_.next_update_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::Position, _impl_.seq_number_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::Position, _impl_.precision_bits_),
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::meshtastic::User, _impl_._has_bits_),
        12, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::meshtastic::User, _impl_.id_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::User, _impl_.long_name_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::User, _impl_.short_name_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::User, _impl_.macaddr_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::User, _impl_.hw_model_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::User, _impl_.is_licensed_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::User, _impl_.role_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::User, _impl_.public_key_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::User, _impl_.is_unmessagable_),
        0,
        1,
        2,
        3,
        5,
        7,
        6,
        4,
        8,
        0x000, // bitmap
        PROTOBUF_FIELD_OFFSET(::meshtastic::RouteDiscovery, _impl_.route_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::RouteDiscovery, _impl_.snr_towards_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::RouteDiscovery, _impl_.route_back_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::RouteDiscovery, _impl_.snr_back_),
        0x004, // bitmap
        PROTOBUF_FIELD_OFFSET(::meshtastic::Routing, _impl_._oneof_case_[0]),
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        PROTOBUF_FIELD_OFFSET(::meshtastic::Routing, _impl_.variant_),
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::meshtastic::Data, _impl_._has_bits_),
        12, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::meshtastic::Data, _impl_.portnum_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::Data, _impl_.payload_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::Data, _impl_.want_response_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::Data, _impl_.dest_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::Data, _impl_.source_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::Data, _impl_.request_id_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::Data, _impl_.reply_id_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::Data, _impl_.emoji_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::Data, _impl_.bitfield_),
        1,
        0,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::meshtastic::KeyVerification, _impl_._has_bits_),
        6, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::meshtastic::KeyVerification, _impl_.nonce_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::KeyVerification, _impl_.hash1_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::KeyVerification, _impl_.hash2_),
        2,
        0,
        1,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::meshtastic::Waypoint, _impl_._has_bits_),
        11, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::meshtastic::Waypoint, _impl_.id_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::Waypoint, _impl_.latitude_i_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::Waypoint, _impl_.longitude_i_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::Waypoint, _impl_.expire_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::Waypoint, _impl_.locked_to_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::Waypoint, _impl_.name_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::Waypoint, _impl_.description_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::Waypoint, _impl_.icon_),
        2,
        3,
        4,
        5,
        6,
        0,
        1,
        7,
        0x085, // bitmap
        PROTOBUF_FIELD_OFFSET(::meshtastic::MqttClientProxyMessage, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::MqttClientProxyMessage, _impl_._oneof_case_[0]),
        9, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::meshtastic::MqttClientProxyMessage, _impl_.topic_),
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        PROTOBUF_FIELD_OFFSET(::meshtastic::MqttClientProxyMessage, _impl_.retained_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::MqttClientProxyMessage, _impl_.payload_variant_),
        0,
        ~0u,
        ~0u,
        1,
        0x085, // bitmap
        PROTOBUF_FIELD_OFFSET(::meshtastic::MeshPacket, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::MeshPacket, _impl_._oneof_case_[0]),
        26, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::meshtastic::MeshPacket, _impl_.from_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::MeshPacket, _impl_.to_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::MeshPacket, _impl_.channel_),
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        PROTOBUF_FIELD_OFFSET(::meshtastic::MeshPacket, _impl_.id_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::MeshPacket, _impl_.rx_time_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::MeshPacket, _impl_.rx_snr_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::MeshPacket, _impl_.hop_limit_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::MeshPacket, _impl_.want_ack_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::MeshPacket, _impl_.priority_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::MeshPacket, _impl_.rx_rssi_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::MeshPacket, _impl_.delayed_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::MeshPacket, _impl_.via_mqtt_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::MeshPacket, _impl_.hop_start_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::MeshPacket, _impl_.public_key_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::MeshPacket, _impl_.pki_encrypted_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::MeshPacket, _impl_.next_hop_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::MeshPacket, _impl_.relay_node_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::MeshPacket, _impl_.tx_after_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::MeshPacket, _impl_.transport_mechanism_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::MeshPacket, _impl_.payload_variant_),
        1,
        2,
        3,
        ~0u,
        ~0u,
        4,
        5,
        6,
        7,
        11,
        8,
        9,
        10,
        12,
        14,
        0,
        13,
        15,
        16,
        17,
        18,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::meshtastic::NodeInfo, _impl_._has_bits_),
        15, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::meshtastic::NodeInfo, _impl_.num_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::NodeInfo, _impl_.user_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::NodeInfo, _impl_.position_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::NodeInfo, _impl_.snr_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::NodeInfo, _impl_.last_heard_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::NodeInfo, _impl_.device_metrics_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::NodeInfo, _impl_.channel_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::NodeInfo, _impl_.via_mqtt_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::NodeInfo, _impl_.hops_away_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::NodeInfo, _impl_.is_favorite_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::NodeInfo, _impl_.is_ignored_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::NodeInfo, _impl_.is_key_manually_verified_),
        3,
        0,
        1,
        4,
        5,
        2,
        6,
        8,
        7,
        9,
        10,
        11,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::meshtastic::MyNodeInfo, _impl_._has_bits_),
        10, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::meshtastic::MyNodeInfo, _impl_.my_node_num_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::MyNodeInfo, _impl_.reboot_count_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::MyNodeInfo, _impl_.min_app_version_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::MyNodeInfo, _impl_.device_id_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::MyNodeInfo, _impl_.pio_env_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::MyNodeInfo, _impl_.firmware_edition_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::MyNodeInfo, _impl_.nodedb_count_),
        2,
        3,
        4,
        0,
        1,
        5,
        6,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::meshtastic::LogRecord, _impl_._has_bits_),
        7, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::meshtastic::LogRecord, _impl_.message_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::LogRecord, _impl_.time_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::LogRecord, _impl_.source_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::LogRecord, _impl_.level_),
        0,
        2,
        1,
        3,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::meshtastic::QueueStatus, _impl_._has_bits_),
        7, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::meshtastic::QueueStatus, _impl_.res_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::QueueStatus, _impl_.free_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::QueueStatus, _impl_.maxlen_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::QueueStatus, _impl_.mesh_packet_id_),
        0,
        1,
        2,
        3,
        0x085, // bitmap
        PROTOBUF_FIELD_OFFSET(::meshtastic::FromRadio, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::FromRadio, _impl_._oneof_case_[0]),
        22, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::meshtastic::FromRadio, _impl_.id_),
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        PROTOBUF_FIELD_OFFSET(::meshtastic::FromRadio, _impl_.payload_variant_),
        0,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        0x085, // bitmap
        PROTOBUF_FIELD_OFFSET(::meshtastic::ClientNotification, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::ClientNotification, _impl_._oneof_case_[0]),
        14, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::meshtastic::ClientNotification, _impl_.reply_id_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::ClientNotification, _impl_.time_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::ClientNotification, _impl_.level_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::ClientNotification, _impl_.message_),
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        PROTOBUF_FIELD_OFFSET(::meshtastic::ClientNotification, _impl_.payload_variant_),
        1,
        2,
        3,
        0,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::meshtastic::KeyVerificationNumberInform, _impl_._has_bits_),
        6, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::meshtastic::KeyVerificationNumberInform, _impl_.nonce_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::KeyVerificationNumberInform, _impl_.remote_longname_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::KeyVerificationNumberInform, _impl_.security_number_),
        1,
        0,
        2,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::meshtastic::KeyVerificationNumberRequest, _impl_._has_bits_),
        5, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::meshtastic::KeyVerificationNumberRequest, _impl_.nonce_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::KeyVerificationNumberRequest, _impl_.remote_longname_),
        1,
        0,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::meshtastic::KeyVerificationFinal, _impl_._has_bits_),
        7, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::meshtastic::KeyVerificationFinal, _impl_.nonce_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::KeyVerificationFinal, _impl_.remote_longname_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::KeyVerificationFinal, _impl_.issender_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::KeyVerificationFinal, _impl_.verification_characters_),
        2,
        0,
        3,
        1,
        0x000, // bitmap
        0x000, // bitmap
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::meshtastic::FileInfo, _impl_._has_bits_),
        5, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::meshtastic::FileInfo, _impl_.file_name_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::FileInfo, _impl_.size_bytes_),
        0,
        1,
        0x004, // bitmap
        PROTOBUF_FIELD_OFFSET(::meshtastic::ToRadio, _impl_._oneof_case_[0]),
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        PROTOBUF_FIELD_OFFSET(::meshtastic::ToRadio, _impl_.payload_variant_),
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::meshtastic::Compressed, _impl_._has_bits_),
        5, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::meshtastic::Compressed, _impl_.portnum_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::Compressed, _impl_.data_),
        1,
        0,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::meshtastic::NeighborInfo, _impl_._has_bits_),
        7, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::meshtastic::NeighborInfo, _impl_.node_id_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::NeighborInfo, _impl_.last_sent_by_id_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::NeighborInfo, _impl_.node_broadcast_interval_secs_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::NeighborInfo, _impl_.neighbors_),
        0,
        1,
        2,
        ~0u,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::meshtastic::Neighbor, _impl_._has_bits_),
        7, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::meshtastic::Neighbor, _impl_.node_id_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::Neighbor, _impl_.snr_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::Neighbor, _impl_.last_rx_time_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::Neighbor, _impl_.node_broadcast_interval_secs_),
        0,
        1,
        2,
        3,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::meshtastic::DeviceMetadata, _impl_._has_bits_),
        15, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::meshtastic::DeviceMetadata, _impl_.firmware_version_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::DeviceMetadata, _impl_.device_state_version_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::DeviceMetadata, _impl_.canshutdown_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::DeviceMetadata, _impl_.haswifi_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::DeviceMetadata, _impl_.hasbluetooth_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::DeviceMetadata, _impl_.hasethernet_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::DeviceMetadata, _impl_.role_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::DeviceMetadata, _impl_.position_flags_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::DeviceMetadata, _impl_.hw_model_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::DeviceMetadata, _impl_.hasremotehardware_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::DeviceMetadata, _impl_.haspkc_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::DeviceMetadata, _impl_.excluded_modules_),
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::meshtastic::Heartbeat, _impl_._has_bits_),
        4, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::meshtastic::Heartbeat, _impl_.nonce_),
        0,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::meshtastic::NodeRemoteHardwarePin, _impl_._has_bits_),
        5, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::meshtastic::NodeRemoteHardwarePin, _impl_.node_num_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::NodeRemoteHardwarePin, _impl_.pin_),
        1,
        0,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::meshtastic::ChunkedPayload, _impl_._has_bits_),
        7, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::meshtastic::ChunkedPayload, _impl_.payload_id_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::ChunkedPayload, _impl_.chunk_count_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::ChunkedPayload, _impl_.chunk_index_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::ChunkedPayload, _impl_.payload_chunk_),
        1,
        2,
        3,
        0,
        0x000, // bitmap
        PROTOBUF_FIELD_OFFSET(::meshtastic::resend_chunks, _impl_.chunks_),
        0x085, // bitmap
        PROTOBUF_FIELD_OFFSET(::meshtastic::ChunkedPayloadResponse, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::meshtastic::ChunkedPayloadResponse, _impl_._oneof_case_[0]),
        9, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::meshtastic::ChunkedPayloadResponse, _impl_.payload_id_),
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        PROTOBUF_FIELD_OFFSET(::meshtastic::ChunkedPayloadResponse, _impl_.payload_variant_),
        0,
        ~0u,
        ~0u,
        ~0u,
};

static const ::_pbi::MigrationSchema
    schemas[] ABSL_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
        {0, sizeof(::meshtastic::Position)},
        {49, sizeof(::meshtastic::User)},
        {70, sizeof(::meshtastic::RouteDiscovery)},
        {75, sizeof(::meshtastic::Routing)},
        {81, sizeof(::meshtastic::Data)},
        {102, sizeof(::meshtastic::KeyVerification)},
        {111, sizeof(::meshtastic::Waypoint)},
        {130, sizeof(::meshtastic::MqttClientProxyMessage)},
        {143, sizeof(::meshtastic::MeshPacket)},
        {190, sizeof(::meshtastic::NodeInfo)},
        {217, sizeof(::meshtastic::MyNodeInfo)},
        {234, sizeof(::meshtastic::LogRecord)},
        {245, sizeof(::meshtastic::QueueStatus)},
        {256, sizeof(::meshtastic::FromRadio)},
        {295, sizeof(::meshtastic::ClientNotification)},
        {318, sizeof(::meshtastic::KeyVerificationNumberInform)},
        {327, sizeof(::meshtastic::KeyVerificationNumberRequest)},
        {334, sizeof(::meshtastic::KeyVerificationFinal)},
        {345, sizeof(::meshtastic::DuplicatedPublicKey)},
        {346, sizeof(::meshtastic::LowEntropyKey)},
        {347, sizeof(::meshtastic::FileInfo)},
        {354, sizeof(::meshtastic::ToRadio)},
        {363, sizeof(::meshtastic::Compressed)},
        {370, sizeof(::meshtastic::NeighborInfo)},
        {381, sizeof(::meshtastic::Neighbor)},
        {392, sizeof(::meshtastic::DeviceMetadata)},
        {419, sizeof(::meshtastic::Heartbeat)},
        {424, sizeof(::meshtastic::NodeRemoteHardwarePin)},
        {431, sizeof(::meshtastic::ChunkedPayload)},
        {442, sizeof(::meshtastic::resend_chunks)},
        {444, sizeof(::meshtastic::ChunkedPayloadResponse)},
};
static const ::_pb::Message* PROTOBUF_NONNULL const file_default_instances[] = {
    &::meshtastic::_Position_default_instance_._instance,
    &::meshtastic::_User_default_instance_._instance,
    &::meshtastic::_RouteDiscovery_default_instance_._instance,
    &::meshtastic::_Routing_default_instance_._instance,
    &::meshtastic::_Data_default_instance_._instance,
    &::meshtastic::_KeyVerification_default_instance_._instance,
    &::meshtastic::_Waypoint_default_instance_._instance,
    &::meshtastic::_MqttClientProxyMessage_default_instance_._instance,
    &::meshtastic::_MeshPacket_default_instance_._instance,
    &::meshtastic::_NodeInfo_default_instance_._instance,
    &::meshtastic::_MyNodeInfo_default_instance_._instance,
    &::meshtastic::_LogRecord_default_instance_._instance,
    &::meshtastic::_QueueStatus_default_instance_._instance,
    &::meshtastic::_FromRadio_default_instance_._instance,
    &::meshtastic::_ClientNotification_default_instance_._instance,
    &::meshtastic::_KeyVerificationNumberInform_default_instance_._instance,
    &::meshtastic::_KeyVerificationNumberRequest_default_instance_._instance,
    &::meshtastic::_KeyVerificationFinal_default_instance_._instance,
    &::meshtastic::_DuplicatedPublicKey_default_instance_._instance,
    &::meshtastic::_LowEntropyKey_default_instance_._instance,
    &::meshtastic::_FileInfo_default_instance_._instance,
    &::meshtastic::_ToRadio_default_instance_._instance,
    &::meshtastic::_Compressed_default_instance_._instance,
    &::meshtastic::_NeighborInfo_default_instance_._instance,
    &::meshtastic::_Neighbor_default_instance_._instance,
    &::meshtastic::_DeviceMetadata_default_instance_._instance,
    &::meshtastic::_Heartbeat_default_instance_._instance,
    &::meshtastic::_NodeRemoteHardwarePin_default_instance_._instance,
    &::meshtastic::_ChunkedPayload_default_instance_._instance,
    &::meshtastic::_resend_chunks_default_instance_._instance,
    &::meshtastic::_ChunkedPayloadResponse_default_instance_._instance,
};
const char descriptor_table_protodef_meshtastic_2fmesh_2eproto[] ABSL_ATTRIBUTE_SECTION_VARIABLE(
    protodesc_cold) = {
    "\n\025meshtastic/mesh.proto\022\nmeshtastic\032\030mes"
    "htastic/channel.proto\032\027meshtastic/config"
    ".proto\032\032meshtastic/device_ui.proto\032\036mesh"
    "tastic/module_config.proto\032\031meshtastic/p"
    "ortnums.proto\032\032meshtastic/telemetry.prot"
    "o\032\027meshtastic/xmodem.proto\"\207\007\n\010Position\022"
    "\027\n\nlatitude_i\030\001 \001(\017H\000\210\001\001\022\030\n\013longitude_i\030"
    "\002 \001(\017H\001\210\001\001\022\025\n\010altitude\030\003 \001(\005H\002\210\001\001\022\014\n\004tim"
    "e\030\004 \001(\007\0227\n\017location_source\030\005 \001(\0162\036.mesht"
    "astic.Position.LocSource\0227\n\017altitude_sou"
    "rce\030\006 \001(\0162\036.meshtastic.Position.AltSourc"
    "e\022\021\n\ttimestamp\030\007 \001(\007\022\037\n\027timestamp_millis"
    "_adjust\030\010 \001(\005\022\031\n\014altitude_hae\030\t \001(\021H\003\210\001\001"
    "\022(\n\033altitude_geoidal_separation\030\n \001(\021H\004\210"
    "\001\001\022\014\n\004PDOP\030\013 \001(\r\022\014\n\004HDOP\030\014 \001(\r\022\014\n\004VDOP\030\r"
    " \001(\r\022\024\n\014gps_accuracy\030\016 \001(\r\022\031\n\014ground_spe"
    "ed\030\017 \001(\rH\005\210\001\001\022\031\n\014ground_track\030\020 \001(\rH\006\210\001\001"
    "\022\023\n\013fix_quality\030\021 \001(\r\022\020\n\010fix_type\030\022 \001(\r\022"
    "\024\n\014sats_in_view\030\023 \001(\r\022\021\n\tsensor_id\030\024 \001(\r"
    "\022\023\n\013next_update\030\025 \001(\r\022\022\n\nseq_number\030\026 \001("
    "\r\022\026\n\016precision_bits\030\027 \001(\r\"N\n\tLocSource\022\r"
    "\n\tLOC_UNSET\020\000\022\016\n\nLOC_MANUAL\020\001\022\020\n\014LOC_INT"
    "ERNAL\020\002\022\020\n\014LOC_EXTERNAL\020\003\"b\n\tAltSource\022\r"
    "\n\tALT_UNSET\020\000\022\016\n\nALT_MANUAL\020\001\022\020\n\014ALT_INT"
    "ERNAL\020\002\022\020\n\014ALT_EXTERNAL\020\003\022\022\n\016ALT_BAROMET"
    "RIC\020\004B\r\n\013_latitude_iB\016\n\014_longitude_iB\013\n\t"
    "_altitudeB\017\n\r_altitude_haeB\036\n\034_altitude_"
    "geoidal_separationB\017\n\r_ground_speedB\017\n\r_"
    "ground_track\"\212\002\n\004User\022\n\n\002id\030\001 \001(\t\022\021\n\tlon"
    "g_name\030\002 \001(\t\022\022\n\nshort_name\030\003 \001(\t\022\023\n\007maca"
    "ddr\030\004 \001(\014B\002\030\001\022+\n\010hw_model\030\005 \001(\0162\031.meshta"
    "stic.HardwareModel\022\023\n\013is_licensed\030\006 \001(\010\022"
    "2\n\004role\030\007 \001(\0162$.meshtastic.Config.Device"
    "Config.Role\022\022\n\npublic_key\030\010 \001(\014\022\034\n\017is_un"
    "messagable\030\t \001(\010H\000\210\001\001B\022\n\020_is_unmessagabl"
    "e\"Z\n\016RouteDiscovery\022\r\n\005route\030\001 \003(\007\022\023\n\013sn"
    "r_towards\030\002 \003(\005\022\022\n\nroute_back\030\003 \003(\007\022\020\n\010s"
    "nr_back\030\004 \003(\005\"\373\003\n\007Routing\0223\n\rroute_reque"
    "st\030\001 \001(\0132\032.meshtastic.RouteDiscoveryH\000\0221"
    "\n\013route_reply\030\002 \001(\0132\032.meshtastic.RouteDi"
    "scoveryH\000\0221\n\014error_reason\030\003 \001(\0162\031.meshta"
    "stic.Routing.ErrorH\000\"\311\002\n\005Error\022\010\n\004NONE\020\000"
    "\022\014\n\010NO_ROUTE\020\001\022\013\n\007GOT_NAK\020\002\022\013\n\007TIMEOUT\020\003"
    "\022\020\n\014NO_INTERFACE\020\004\022\022\n\016MAX_RETRANSMIT\020\005\022\016"
    "\n\nNO_CHANNEL\020\006\022\r\n\tTOO_LARGE\020\007\022\017\n\013NO_RESP"
    "ONSE\020\010\022\024\n\020DUTY_CYCLE_LIMIT\020\t\022\017\n\013BAD_REQU"
    "EST\020 \022\022\n\016NOT_AUTHORIZED\020!\022\016\n\nPKI_FAILED\020"
    "\"\022\026\n\022PKI_UNKNOWN_PUBKEY\020#\022\031\n\025ADMIN_BAD_S"
    "ESSION_KEY\020$\022!\n\035ADMIN_PUBLIC_KEY_UNAUTHO"
    "RIZED\020%\022\027\n\023RATE_LIMIT_EXCEEDED\020&B\t\n\007vari"
    "ant\"\313\001\n\004Data\022$\n\007portnum\030\001 \001(\0162\023.meshtast"
    "ic.PortNum\022\017\n\007payload\030\002 \001(\014\022\025\n\rwant_resp"
    "onse\030\003 \001(\010\022\014\n\004dest\030\004 \001(\007\022\016\n\006source\030\005 \001(\007"
    "\022\022\n\nrequest_id\030\006 \001(\007\022\020\n\010reply_id\030\007 \001(\007\022\r"
    "\n\005emoji\030\010 \001(\007\022\025\n\010bitfield\030\t \001(\rH\000\210\001\001B\013\n\t"
    "_bitfield\">\n\017KeyVerification\022\r\n\005nonce\030\001 "
    "\001(\004\022\r\n\005hash1\030\002 \001(\014\022\r\n\005hash2\030\003 \001(\014\"\274\001\n\010Wa"
    "ypoint\022\n\n\002id\030\001 \001(\r\022\027\n\nlatitude_i\030\002 \001(\017H\000"
    "\210\001\001\022\030\n\013longitude_i\030\003 \001(\017H\001\210\001\001\022\016\n\006expire\030"
    "\004 \001(\r\022\021\n\tlocked_to\030\005 \001(\r\022\014\n\004name\030\006 \001(\t\022\023"
    "\n\013description\030\007 \001(\t\022\014\n\004icon\030\010 \001(\007B\r\n\013_la"
    "titude_iB\016\n\014_longitude_i\"l\n\026MqttClientPr"
    "oxyMessage\022\r\n\005topic\030\001 \001(\t\022\016\n\004data\030\002 \001(\014H"
    "\000\022\016\n\004text\030\003 \001(\tH\000\022\020\n\010retained\030\004 \001(\010B\021\n\017p"
    "ayload_variant\"\265\007\n\nMeshPacket\022\014\n\004from\030\001 "
    "\001(\007\022\n\n\002to\030\002 \001(\007\022\017\n\007channel\030\003 \001(\r\022#\n\007deco"
    "ded\030\004 \001(\0132\020.meshtastic.DataH\000\022\023\n\tencrypt"
    "ed\030\005 \001(\014H\000\022\n\n\002id\030\006 \001(\007\022\017\n\007rx_time\030\007 \001(\007\022"
    "\016\n\006rx_snr\030\010 \001(\002\022\021\n\thop_limit\030\t \001(\r\022\020\n\010wa"
    "nt_ack\030\n \001(\010\0221\n\010priority\030\013 \001(\0162\037.meshtas"
    "tic.MeshPacket.Priority\022\017\n\007rx_rssi\030\014 \001(\005"
    "\0223\n\007delayed\030\r \001(\0162\036.meshtastic.MeshPacke"
    "t.DelayedB\002\030\001\022\020\n\010via_mqtt\030\016 \001(\010\022\021\n\thop_s"
    "tart\030\017 \001(\r\022\022\n\npublic_key\030\020 \001(\014\022\025\n\rpki_en"
    "crypted\030\021 \001(\010\022\020\n\010next_hop\030\022 \001(\r\022\022\n\nrelay"
    "_node\030\023 \001(\r\022\020\n\010tx_after\030\024 \001(\r\022F\n\023transpo"
    "rt_mechanism\030\025 \001(\0162).meshtastic.MeshPack"
    "et.TransportMechanism\"~\n\010Priority\022\t\n\005UNS"
    "ET\020\000\022\007\n\003MIN\020\001\022\016\n\nBACKGROUND\020\n\022\013\n\007DEFAULT"
    "\020@\022\014\n\010RELIABLE\020F\022\014\n\010RESPONSE\020P\022\010\n\004HIGH\020d"
    "\022\t\n\005ALERT\020n\022\007\n\003ACK\020x\022\007\n\003MAX\020\177\"B\n\007Delayed"
    "\022\014\n\010NO_DELAY\020\000\022\025\n\021DELAYED_BROADCAST\020\001\022\022\n"
    "\016DELAYED_DIRECT\020\002\"\317\001\n\022TransportMechanism"
    "\022\026\n\022TRANSPORT_INTERNAL\020\000\022\022\n\016TRANSPORT_LO"
    "RA\020\001\022\027\n\023TRANSPORT_LORA_ALT1\020\002\022\027\n\023TRANSPO"
    "RT_LORA_ALT2\020\003\022\027\n\023TRANSPORT_LORA_ALT3\020\004\022"
    "\022\n\016TRANSPORT_MQTT\020\005\022\033\n\027TRANSPORT_MULTICA"
    "ST_UDP\020\006\022\021\n\rTRANSPORT_API\020\007B\021\n\017payload_v"
    "ariant\"\307\002\n\010NodeInfo\022\013\n\003num\030\001 \001(\r\022\036\n\004user"
    "\030\002 \001(\0132\020.meshtastic.User\022&\n\010position\030\003 \001"
    "(\0132\024.meshtastic.Position\022\013\n\003snr\030\004 \001(\002\022\022\n"
    "\nlast_heard\030\005 \001(\007\0221\n\016device_metrics\030\006 \001("
    "\0132\031.meshtastic.DeviceMetrics\022\017\n\007channel\030"
    "\007 \001(\r\022\020\n\010via_mqtt\030\010 \001(\010\022\026\n\thops_away\030\t \001"
    "(\rH\000\210\001\001\022\023\n\013is_favorite\030\n \001(\010\022\022\n\nis_ignor"
    "ed\030\013 \001(\010\022 \n\030is_key_manually_verified\030\014 \001"
    "(\010B\014\n\n_hops_away\"\301\001\n\nMyNodeInfo\022\023\n\013my_no"
    "de_num\030\001 \001(\r\022\024\n\014reboot_count\030\010 \001(\r\022\027\n\017mi"
    "n_app_version\030\013 \001(\r\022\021\n\tdevice_id\030\014 \001(\014\022\017"
    "\n\007pio_env\030\r \001(\t\0225\n\020firmware_edition\030\016 \001("
    "\0162\033.meshtastic.FirmwareEdition\022\024\n\014nodedb"
    "_count\030\017 \001(\r\"\300\001\n\tLogRecord\022\017\n\007message\030\001 "
    "\001(\t\022\014\n\004time\030\002 \001(\007\022\016\n\006source\030\003 \001(\t\022*\n\005lev"
    "el\030\004 \001(\0162\033.meshtastic.LogRecord.Level\"X\n"
    "\005Level\022\t\n\005UNSET\020\000\022\014\n\010CRITICAL\0202\022\t\n\005ERROR"
    "\020(\022\013\n\007WARNING\020\036\022\010\n\004INFO\020\024\022\t\n\005DEBUG\020\n\022\t\n\005"
    "TRACE\020\005\"P\n\013QueueStatus\022\013\n\003res\030\001 \001(\005\022\014\n\004f"
    "ree\030\002 \001(\r\022\016\n\006maxlen\030\003 \001(\r\022\026\n\016mesh_packet"
    "_id\030\004 \001(\r\"\371\005\n\tFromRadio\022\n\n\002id\030\001 \001(\r\022(\n\006p"
    "acket\030\002 \001(\0132\026.meshtastic.MeshPacketH\000\022)\n"
    "\007my_info\030\003 \001(\0132\026.meshtastic.MyNodeInfoH\000"
    "\022)\n\tnode_info\030\004 \001(\0132\024.meshtastic.NodeInf"
    "oH\000\022$\n\006config\030\005 \001(\0132\022.meshtastic.ConfigH"
    "\000\022+\n\nlog_record\030\006 \001(\0132\025.meshtastic.LogRe"
    "cordH\000\022\034\n\022config_complete_id\030\007 \001(\rH\000\022\022\n\010"
    "rebooted\030\010 \001(\010H\000\0220\n\014moduleConfig\030\t \001(\0132\030"
    ".meshtastic.ModuleConfigH\000\022&\n\007channel\030\n "
    "\001(\0132\023.meshtastic.ChannelH\000\022.\n\013queueStatu"
    "s\030\013 \001(\0132\027.meshtastic.QueueStatusH\000\022*\n\014xm"
    "odemPacket\030\014 \001(\0132\022.meshtastic.XModemH\000\022."
    "\n\010metadata\030\r \001(\0132\032.meshtastic.DeviceMeta"
    "dataH\000\022D\n\026mqttClientProxyMessage\030\016 \001(\0132\""
    ".meshtastic.MqttClientProxyMessageH\000\022(\n\010"
    "fileInfo\030\017 \001(\0132\024.meshtastic.FileInfoH\000\022<"
    "\n\022clientNotification\030\020 \001(\0132\036.meshtastic."
    "ClientNotificationH\000\0224\n\016deviceuiConfig\030\021"
    " \001(\0132\032.meshtastic.DeviceUIConfigH\000B\021\n\017pa"
    "yload_variant\"\372\003\n\022ClientNotification\022\025\n\010"
    "reply_id\030\001 \001(\rH\001\210\001\001\022\014\n\004time\030\002 \001(\007\022*\n\005lev"
    "el\030\003 \001(\0162\033.meshtastic.LogRecord.Level\022\017\n"
    "\007message\030\004 \001(\t\022Q\n\036key_verification_numbe"
    "r_inform\030\013 \001(\0132\'.meshtastic.KeyVerificat"
    "ionNumberInformH\000\022S\n\037key_verification_nu"
    "mber_request\030\014 \001(\0132(.meshtastic.KeyVerif"
    "icationNumberRequestH\000\022B\n\026key_verificati"
    "on_final\030\r \001(\0132 .meshtastic.KeyVerificat"
    "ionFinalH\000\022@\n\025duplicated_public_key\030\016 \001("
    "\0132\037.meshtastic.DuplicatedPublicKeyH\000\0224\n\017"
    "low_entropy_key\030\017 \001(\0132\031.meshtastic.LowEn"
    "tropyKeyH\000B\021\n\017payload_variantB\013\n\t_reply_"
    "id\"^\n\033KeyVerificationNumberInform\022\r\n\005non"
    "ce\030\001 \001(\004\022\027\n\017remote_longname\030\002 \001(\t\022\027\n\017sec"
    "urity_number\030\003 \001(\r\"F\n\034KeyVerificationNum"
    "berRequest\022\r\n\005nonce\030\001 \001(\004\022\027\n\017remote_long"
    "name\030\002 \001(\t\"q\n\024KeyVerificationFinal\022\r\n\005no"
    "nce\030\001 \001(\004\022\027\n\017remote_longname\030\002 \001(\t\022\020\n\010is"
    "Sender\030\003 \001(\010\022\037\n\027verification_characters\030"
    "\004 \001(\t\"\025\n\023DuplicatedPublicKey\"\017\n\rLowEntro"
    "pyKey\"1\n\010FileInfo\022\021\n\tfile_name\030\001 \001(\t\022\022\n\n"
    "size_bytes\030\002 \001(\r\"\224\002\n\007ToRadio\022(\n\006packet\030\001"
    " \001(\0132\026.meshtastic.MeshPacketH\000\022\030\n\016want_c"
    "onfig_id\030\003 \001(\rH\000\022\024\n\ndisconnect\030\004 \001(\010H\000\022*"
    "\n\014xmodemPacket\030\005 \001(\0132\022.meshtastic.XModem"
    "H\000\022D\n\026mqttClientProxyMessage\030\006 \001(\0132\".mes"
    "htastic.MqttClientProxyMessageH\000\022*\n\thear"
    "tbeat\030\007 \001(\0132\025.meshtastic.HeartbeatH\000B\021\n\017"
    "payload_variant\"@\n\nCompressed\022$\n\007portnum"
    "\030\001 \001(\0162\023.meshtastic.PortNum\022\014\n\004data\030\002 \001("
    "\014\"\207\001\n\014NeighborInfo\022\017\n\007node_id\030\001 \001(\r\022\027\n\017l"
    "ast_sent_by_id\030\002 \001(\r\022$\n\034node_broadcast_i"
    "nterval_secs\030\003 \001(\r\022\'\n\tneighbors\030\004 \003(\0132\024."
    "meshtastic.Neighbor\"d\n\010Neighbor\022\017\n\007node_"
    "id\030\001 \001(\r\022\013\n\003snr\030\002 \001(\002\022\024\n\014last_rx_time\030\003 "
    "\001(\007\022$\n\034node_broadcast_interval_secs\030\004 \001("
    "\r\"\327\002\n\016DeviceMetadata\022\030\n\020firmware_version"
    "\030\001 \001(\t\022\034\n\024device_state_version\030\002 \001(\r\022\023\n\013"
    "canShutdown\030\003 \001(\010\022\017\n\007hasWifi\030\004 \001(\010\022\024\n\014ha"
    "sBluetooth\030\005 \001(\010\022\023\n\013hasEthernet\030\006 \001(\010\0222\n"
    "\004role\030\007 \001(\0162$.meshtastic.Config.DeviceCo"
    "nfig.Role\022\026\n\016position_flags\030\010 \001(\r\022+\n\010hw_"
    "model\030\t \001(\0162\031.meshtastic.HardwareModel\022\031"
    "\n\021hasRemoteHardware\030\n \001(\010\022\016\n\006hasPKC\030\013 \001("
    "\010\022\030\n\020excluded_modules\030\014 \001(\r\"\032\n\tHeartbeat"
    "\022\r\n\005nonce\030\001 \001(\r\"U\n\025NodeRemoteHardwarePin"
    "\022\020\n\010node_num\030\001 \001(\r\022*\n\003pin\030\002 \001(\0132\035.meshta"
    "stic.RemoteHardwarePin\"e\n\016ChunkedPayload"
    "\022\022\n\npayload_id\030\001 \001(\r\022\023\n\013chunk_count\030\002 \001("
    "\r\022\023\n\013chunk_index\030\003 \001(\r\022\025\n\rpayload_chunk\030"
    "\004 \001(\014\"\037\n\rresend_chunks\022\016\n\006chunks\030\001 \003(\r\"\252"
    "\001\n\026ChunkedPayloadResponse\022\022\n\npayload_id\030"
    "\001 \001(\r\022\032\n\020request_transfer\030\002 \001(\010H\000\022\031\n\017acc"
    "ept_transfer\030\003 \001(\010H\000\0222\n\rresend_chunks\030\004 "
    "\001(\0132\031.meshtastic.resend_chunksH\000B\021\n\017payl"
    "oad_variant*\317\020\n\rHardwareModel\022\t\n\005UNSET\020\000"
    "\022\014\n\010TLORA_V2\020\001\022\014\n\010TLORA_V1\020\002\022\022\n\016TLORA_V2"
    "_1_1P6\020\003\022\t\n\005TBEAM\020\004\022\017\n\013HELTEC_V2_0\020\005\022\016\n\n"
    "TBEAM_V0P7\020\006\022\n\n\006T_ECHO\020\007\022\020\n\014TLORA_V1_1P3"
    "\020\010\022\013\n\007RAK4631\020\t\022\017\n\013HELTEC_V2_1\020\n\022\r\n\tHELT"
    "EC_V1\020\013\022\030\n\024LILYGO_TBEAM_S3_CORE\020\014\022\014\n\010RAK"
    "11200\020\r\022\013\n\007NANO_G1\020\016\022\022\n\016TLORA_V2_1_1P8\020\017"
    "\022\017\n\013TLORA_T3_S3\020\020\022\024\n\020NANO_G1_EXPLORER\020\021\022"
    "\021\n\rNANO_G2_ULTRA\020\022\022\r\n\tLORA_TYPE\020\023\022\013\n\007WIP"
    "HONE\020\024\022\016\n\nWIO_WM1110\020\025\022\013\n\007RAK2560\020\026\022\023\n\017H"
    "ELTEC_HRU_3601\020\027\022\032\n\026HELTEC_WIRELESS_BRID"
    "GE\020\030\022\016\n\nSTATION_G1\020\031\022\014\n\010RAK11310\020\032\022\024\n\020SE"
    "NSELORA_RP2040\020\033\022\020\n\014SENSELORA_S3\020\034\022\r\n\tCA"
    "NARYONE\020\035\022\017\n\013RP2040_LORA\020\036\022\016\n\nSTATION_G2"
    "\020\037\022\021\n\rLORA_RELAY_V1\020 \022\016\n\nNRF52840DK\020!\022\007\n"
    "\003PPR\020\"\022\017\n\013GENIEBLOCKS\020#\022\021\n\rNRF52_UNKNOWN"
    "\020$\022\r\n\tPORTDUINO\020%\022\017\n\013ANDROID_SIM\020&\022\n\n\006DI"
    "Y_V1\020\'\022\025\n\021NRF52840_PCA10059\020(\022\n\n\006DR_DEV\020"
    ")\022\013\n\007M5STACK\020*\022\r\n\tHELTEC_V3\020+\022\021\n\rHELTEC_"
    "WSL_V3\020,\022\023\n\017BETAFPV_2400_TX\020-\022\027\n\023BETAFPV"
    "_900_NANO_TX\020.\022\014\n\010RPI_PICO\020/\022\033\n\027HELTEC_W"
    "IRELESS_TRACKER\0200\022\031\n\025HELTEC_WIRELESS_PAP"
    "ER\0201\022\n\n\006T_DECK\0202\022\016\n\nT_WATCH_S3\0203\022\021\n\rPICO"
    "MPUTER_S3\0204\022\017\n\013HELTEC_HT62\0205\022\022\n\016EBYTE_ES"
    "P32_S3\0206\022\021\n\rESP32_S3_PICO\0207\022\r\n\tCHATTER_2"
    "\0208\022\036\n\032HELTEC_WIRELESS_PAPER_V1_0\0209\022 \n\034HE"
    "LTEC_WIRELESS_TRACKER_V1_0\020:\022\013\n\007UNPHONE\020"
    ";\022\014\n\010TD_LORAC\020<\022\023\n\017CDEBYTE_EORA_S3\020=\022\017\n\013"
    "TWC_MESH_V4\020>\022\026\n\022NRF52_PROMICRO_DIY\020\?\022\037\n"
    "\033RADIOMASTER_900_BANDIT_NANO\020@\022\034\n\030HELTEC"
    "_CAPSULE_SENSOR_V3\020A\022\035\n\031HELTEC_VISION_MA"
    "STER_T190\020B\022\035\n\031HELTEC_VISION_MASTER_E213"
    "\020C\022\035\n\031HELTEC_VISION_MASTER_E290\020D\022\031\n\025HEL"
    "TEC_MESH_NODE_T114\020E\022\026\n\022SENSECAP_INDICAT"
    "OR\020F\022\023\n\017TRACKER_T1000_E\020G\022\013\n\007RAK3172\020H\022\n"
    "\n\006WIO_E5\020I\022\032\n\026RADIOMASTER_900_BANDIT\020J\022\023"
    "\n\017ME25LS01_4Y10TD\020K\022\030\n\024RP2040_FEATHER_RF"
    "M95\020L\022\025\n\021M5STACK_COREBASIC\020M\022\021\n\rM5STACK_"
    "CORE2\020N\022\r\n\tRPI_PICO2\020O\022\022\n\016M5STACK_CORES3"
    "\020P\022\021\n\rSEEED_XIAO_S3\020Q\022\013\n\007MS24SF1\020R\022\014\n\010TL"
    "ORA_C6\020S\022\017\n\013WISMESH_TAP\020T\022\r\n\tROUTASTIC\020U"
    "\022\014\n\010MESH_TAB\020V\022\014\n\010MESHLINK\020W\022\022\n\016XIAO_NRF"
    "52_KIT\020X\022\020\n\014THINKNODE_M1\020Y\022\020\n\014THINKNODE_"
    "M2\020Z\022\017\n\013T_ETH_ELITE\020[\022\025\n\021HELTEC_SENSOR_H"
    "UB\020\\\022\032\n\026RESERVED_FRIED_CHICKEN\020]\022\026\n\022HELT"
    "EC_MESH_POCKET\020^\022\024\n\020SEEED_SOLAR_NODE\020_\022\030"
    "\n\024NOMADSTAR_METEOR_PRO\020`\022\r\n\tCROWPANEL\020a\022"
    "\013\n\007LINK_32\020b\022\030\n\024SEEED_WIO_TRACKER_L1\020c\022\035"
    "\n\031SEEED_WIO_TRACKER_L1_EINK\020d\022\024\n\020QWANTZ_"
    "TINY_ARMS\020e\022\016\n\nT_DECK_PRO\020f\022\020\n\014T_LORA_PA"
    "GER\020g\022\035\n\031GAT562_MESH_TRIAL_TRACKER\020h\022\017\n\013"
    "WISMESH_TAG\020i\022\013\n\007RAK3312\020j\022\020\n\014THINKNODE_"
    "M5\020k\022\025\n\021HELTEC_MESH_SOLAR\020l\022\017\n\013T_ECHO_LI"
    "TE\020m\022\017\n\nPRIVATE_HW\020\377\001*,\n\tConstants\022\010\n\004ZE"
    "RO\020\000\022\025\n\020DATA_PAYLOAD_LEN\020\351\001*\264\002\n\021Critical"
    "ErrorCode\022\010\n\004NONE\020\000\022\017\n\013TX_WATCHDOG\020\001\022\024\n\020"
    "SLEEP_ENTER_WAIT\020\002\022\014\n\010NO_RADIO\020\003\022\017\n\013UNSP"
    "ECIFIED\020\004\022\025\n\021UBLOX_UNIT_FAILED\020\005\022\r\n\tNO_A"
    "XP192\020\006\022\031\n\025INVALID_RADIO_SETTING\020\007\022\023\n\017TR"
    "ANSMIT_FAILED\020\010\022\014\n\010BROWNOUT\020\t\022\022\n\016SX1262_"
    "FAILURE\020\n\022\021\n\rRADIO_SPI_BUG\020\013\022 \n\034FLASH_CO"
    "RRUPTION_RECOVERABLE\020\014\022\"\n\036FLASH_CORRUPTI"
    "ON_UNRECOVERABLE\020\r*\177\n\017FirmwareEdition\022\013\n"
    "\007VANILLA\020\000\022\021\n\rSMART_CITIZEN\020\001\022\016\n\nOPEN_SA"
    "UCE\020\020\022\n\n\006DEFCON\020\021\022\017\n\013BURNING_MAN\020\022\022\016\n\nHA"
    "MVENTION\020\023\022\017\n\013DIY_EDITION\020\177*\200\003\n\017Excluded"
    "Modules\022\021\n\rEXCLUDED_NONE\020\000\022\017\n\013MQTT_CONFI"
    "G\020\001\022\021\n\rSERIAL_CONFIG\020\002\022\023\n\017EXTNOTIF_CONFI"
    "G\020\004\022\027\n\023STOREFORWARD_CONFIG\020\010\022\024\n\020RANGETES"
    "T_CONFIG\020\020\022\024\n\020TELEMETRY_CONFIG\020 \022\024\n\020CANN"
    "EDMSG_CONFIG\020@\022\021\n\014AUDIO_CONFIG\020\200\001\022\032\n\025REM"
    "OTEHARDWARE_CONFIG\020\200\002\022\030\n\023NEIGHBORINFO_CO"
    "NFIG\020\200\004\022\033\n\026AMBIENTLIGHTING_CONFIG\020\200\010\022\033\n\026"
    "DETECTIONSENSOR_CONFIG\020\200\020\022\026\n\021PAXCOUNTER_"
    "CONFIG\020\200 \022\025\n\020BLUETOOTH_CONFIG\020\200@\022\024\n\016NETW"
    "ORK_CONFIG\020\200\200\001B_\n\023com.geeksville.meshB\nM"
    "eshProtosZ\"github.com/meshtastic/go/gene"
    "rated\252\002\024Meshtastic.Protobufs\272\002\000b\006proto3"
};
static const ::_pbi::DescriptorTable* PROTOBUF_NONNULL const
    descriptor_table_meshtastic_2fmesh_2eproto_deps[7] = {
        &::descriptor_table_meshtastic_2fchannel_2eproto,
        &::descriptor_table_meshtastic_2fconfig_2eproto,
        &::descriptor_table_meshtastic_2fdevice_5fui_2eproto,
        &::descriptor_table_meshtastic_2fmodule_5fconfig_2eproto,
        &::descriptor_table_meshtastic_2fportnums_2eproto,
        &::descriptor_table_meshtastic_2ftelemetry_2eproto,
        &::descriptor_table_meshtastic_2fxmodem_2eproto,
};
static ::absl::once_flag descriptor_table_meshtastic_2fmesh_2eproto_once;
PROTOBUF_CONSTINIT const ::_pbi::DescriptorTable descriptor_table_meshtastic_2fmesh_2eproto = {
    false,
    false,
    10439,
    descriptor_table_protodef_meshtastic_2fmesh_2eproto,
    "meshtastic/mesh.proto",
    &descriptor_table_meshtastic_2fmesh_2eproto_once,
    descriptor_table_meshtastic_2fmesh_2eproto_deps,
    7,
    31,
    schemas,
    file_default_instances,
    TableStruct_meshtastic_2fmesh_2eproto::offsets,
    file_level_enum_descriptors_meshtastic_2fmesh_2eproto,
    file_level_service_descriptors_meshtastic_2fmesh_2eproto,
};
namespace meshtastic {
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Position_LocSource_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_meshtastic_2fmesh_2eproto);
  return file_level_enum_descriptors_meshtastic_2fmesh_2eproto[0];
}
PROTOBUF_CONSTINIT const uint32_t Position_LocSource_internal_data_[] = {
    262144u, 0u, };
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Position_AltSource_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_meshtastic_2fmesh_2eproto);
  return file_level_enum_descriptors_meshtastic_2fmesh_2eproto[1];
}
PROTOBUF_CONSTINIT const uint32_t Position_AltSource_internal_data_[] = {
    327680u, 0u, };
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Routing_Error_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_meshtastic_2fmesh_2eproto);
  return file_level_enum_descriptors_meshtastic_2fmesh_2eproto[2];
}
PROTOBUF_CONSTINIT const uint32_t Routing_Error_internal_data_[] = {
    655360u, 32u, 532676608u, };
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL MeshPacket_Priority_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_meshtastic_2fmesh_2eproto);
  return file_level_enum_descriptors_meshtastic_2fmesh_2eproto[3];
}
PROTOBUF_CONSTINIT const uint32_t MeshPacket_Priority_internal_data_[] = {
    131072u, 128u, 256u, 1073741824u, 16400u, 541069316u, };
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL MeshPacket_Delayed_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_meshtastic_2fmesh_2eproto);
  return file_level_enum_descriptors_meshtastic_2fmesh_2eproto[4];
}
PROTOBUF_CONSTINIT const uint32_t MeshPacket_Delayed_internal_data_[] = {
    196608u, 0u, };
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL MeshPacket_TransportMechanism_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_meshtastic_2fmesh_2eproto);
  return file_level_enum_descriptors_meshtastic_2fmesh_2eproto[5];
}
PROTOBUF_CONSTINIT const uint32_t MeshPacket_TransportMechanism_internal_data_[] = {
    524288u, 0u, };
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL LogRecord_Level_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_meshtastic_2fmesh_2eproto);
  return file_level_enum_descriptors_meshtastic_2fmesh_2eproto[6];
}
PROTOBUF_CONSTINIT const uint32_t LogRecord_Level_internal_data_[] = {
    65536u, 64u, 537395728u, 131200u, };
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL HardwareModel_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_meshtastic_2fmesh_2eproto);
  return file_level_enum_descriptors_meshtastic_2fmesh_2eproto[7];
}
PROTOBUF_CONSTINIT const uint32_t HardwareModel_internal_data_[] = {
    7208960u, 65536u, 255u, };
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Constants_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_meshtastic_2fmesh_2eproto);
  return file_level_enum_descriptors_meshtastic_2fmesh_2eproto[8];
}
PROTOBUF_CONSTINIT const uint32_t Constants_internal_data_[] = {
    65536u, 65536u, 233u, };
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL CriticalErrorCode_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_meshtastic_2fmesh_2eproto);
  return file_level_enum_descriptors_meshtastic_2fmesh_2eproto[9];
}
PROTOBUF_CONSTINIT const uint32_t CriticalErrorCode_internal_data_[] = {
    917504u, 0u, };
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL FirmwareEdition_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_meshtastic_2fmesh_2eproto);
  return file_level_enum_descriptors_meshtastic_2fmesh_2eproto[10];
}
PROTOBUF_CONSTINIT const uint32_t FirmwareEdition_internal_data_[] = {
    131072u, 65568u, 245760u, 127u, };
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ExcludedModules_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_meshtastic_2fmesh_2eproto);
  return file_level_enum_descriptors_meshtastic_2fmesh_2eproto[11];
}
PROTOBUF_CONSTINIT const uint32_t ExcludedModules_internal_data_[] = {
    196608u, 524352u, 536879138u, 536870912u, 2048u, 512u, 8192u, 256u, 1024u, 4096u, 16384u, 128u, };
// ===================================================================

class Position::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<Position>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(Position, _impl_._has_bits_);
};

Position::Position(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, Position_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:meshtastic.Position)
}
Position::Position(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Position& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, Position_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}
PROTOBUF_NDEBUG_INLINE Position::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void Position::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, latitude_i_),
           0,
           offsetof(Impl_, precision_bits_) -
               offsetof(Impl_, latitude_i_) +
               sizeof(Impl_::precision_bits_));
}
Position::~Position() {
  // @@protoc_insertion_point(destructor:meshtastic.Position)
  SharedDtor(*this);
}
inline void Position::SharedDtor(MessageLite& self) {
  Position& this_ = static_cast<Position&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL Position::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) Position(arena);
}
constexpr auto Position::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(Position),
                                            alignof(Position));
}
constexpr auto Position::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_Position_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &Position::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<Position>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &Position::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<Position>(), &Position::ByteSizeLong,
              &Position::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(Position, _impl_._cached_size_),
          false,
      },
      &Position::kDescriptorMethods,
      &descriptor_table_meshtastic_2fmesh_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull Position_class_data_ =
        Position::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
Position::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&Position_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(Position_class_data_.tc_table);
  return Position_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<5, 23, 0, 0, 2>
Position::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Position, _impl_._has_bits_),
    0, // no _extensions_
    23, 248,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4286578688,  // skipmap
    offsetof(decltype(_table_), field_entries),
    23,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    Position_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::meshtastic::Position>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional sfixed32 latitude_i = 1;
    {::_pbi::TcParser::FastF32S1,
     {13, 0, 0, PROTOBUF_FIELD_OFFSET(Position, _impl_.latitude_i_)}},
    // optional sfixed32 longitude_i = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 1, 0, PROTOBUF_FIELD_OFFSET(Position, _impl_.longitude_i_)}},
    // optional int32 altitude = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Position, _impl_.altitude_), 2>(),
     {24, 2, 0, PROTOBUF_FIELD_OFFSET(Position, _impl_.altitude_)}},
    // fixed32 time = 4;
    {::_pbi::TcParser::FastF32S1,
     {37, 3, 0, PROTOBUF_FIELD_OFFSET(Position, _impl_.time_)}},
    // .meshtastic.Position.LocSource location_source = 5;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Position, _impl_.location_source_), 4>(),
     {40, 4, 0, PROTOBUF_FIELD_OFFSET(Position, _impl_.location_source_)}},
    // .meshtastic.Position.AltSource altitude_source = 6;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Position, _impl_.altitude_source_), 5>(),
     {48, 5, 0, PROTOBUF_FIELD_OFFSET(Position, _impl_.altitude_source_)}},
    // fixed32 timestamp = 7;
    {::_pbi::TcParser::FastF32S1,
     {61, 6, 0, PROTOBUF_FIELD_OFFSET(Position, _impl_.timestamp_)}},
    // int32 timestamp_millis_adjust = 8;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Position, _impl_.timestamp_millis_adjust_), 7>(),
     {64, 7, 0, PROTOBUF_FIELD_OFFSET(Position, _impl_.timestamp_millis_adjust_)}},
    // optional sint32 altitude_hae = 9;
    {::_pbi::TcParser::FastZ32S1,
     {72, 8, 0, PROTOBUF_FIELD_OFFSET(Position, _impl_.altitude_hae_)}},
    // optional sint32 altitude_geoidal_separation = 10;
    {::_pbi::TcParser::FastZ32S1,
     {80, 9, 0, PROTOBUF_FIELD_OFFSET(Position, _impl_.altitude_geoidal_separation_)}},
    // uint32 PDOP = 11;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Position, _impl_.pdop_), 10>(),
     {88, 10, 0, PROTOBUF_FIELD_OFFSET(Position, _impl_.pdop_)}},
    // uint32 HDOP = 12;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Position, _impl_.hdop_), 11>(),
     {96, 11, 0, PROTOBUF_FIELD_OFFSET(Position, _impl_.hdop_)}},
    // uint32 VDOP = 13;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Position, _impl_.vdop_), 12>(),
     {104, 12, 0, PROTOBUF_FIELD_OFFSET(Position, _impl_.vdop_)}},
    // uint32 gps_accuracy = 14;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Position, _impl_.gps_accuracy_), 13>(),
     {112, 13, 0, PROTOBUF_FIELD_OFFSET(Position, _impl_.gps_accuracy_)}},
    // optional uint32 ground_speed = 15;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Position, _impl_.ground_speed_), 14>(),
     {120, 14, 0, PROTOBUF_FIELD_OFFSET(Position, _impl_.ground_speed_)}},
    // optional uint32 ground_track = 16;
    {::_pbi::TcParser::FastV32S2,
     {384, 15, 0, PROTOBUF_FIELD_OFFSET(Position, _impl_.ground_track_)}},
    // uint32 fix_quality = 17;
    {::_pbi::TcParser::FastV32S2,
     {392, 16, 0, PROTOBUF_FIELD_OFFSET(Position, _impl_.fix_quality_)}},
    // uint32 fix_type = 18;
    {::_pbi::TcParser::FastV32S2,
     {400, 17, 0, PROTOBUF_FIELD_OFFSET(Position, _impl_.fix_type_)}},
    // uint32 sats_in_view = 19;
    {::_pbi::TcParser::FastV32S2,
     {408, 18, 0, PROTOBUF_FIELD_OFFSET(Position, _impl_.sats_in_view_)}},
    // uint32 sensor_id = 20;
    {::_pbi::TcParser::FastV32S2,
     {416, 19, 0, PROTOBUF_FIELD_OFFSET(Position, _impl_.sensor_id_)}},
    // uint32 next_update = 21;
    {::_pbi::TcParser::FastV32S2,
     {424, 20, 0, PROTOBUF_FIELD_OFFSET(Position, _impl_.next_update_)}},
    // uint32 seq_number = 22;
    {::_pbi::TcParser::FastV32S2,
     {432, 21, 0, PROTOBUF_FIELD_OFFSET(Position, _impl_.seq_number_)}},
    // uint32 precision_bits = 23;
    {::_pbi::TcParser::FastV32S2,
     {440, 22, 0, PROTOBUF_FIELD_OFFSET(Position, _impl_.precision_bits_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional sfixed32 latitude_i = 1;
    {PROTOBUF_FIELD_OFFSET(Position, _impl_.latitude_i_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kSFixed32)},
    // optional sfixed32 longitude_i = 2;
    {PROTOBUF_FIELD_OFFSET(Position, _impl_.longitude_i_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kSFixed32)},
    // optional int32 altitude = 3;
    {PROTOBUF_FIELD_OFFSET(Position, _impl_.altitude_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // fixed32 time = 4;
    {PROTOBUF_FIELD_OFFSET(Position, _impl_.time_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFixed32)},
    // .meshtastic.Position.LocSource location_source = 5;
    {PROTOBUF_FIELD_OFFSET(Position, _impl_.location_source_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kOpenEnum)},
    // .meshtastic.Position.AltSource altitude_source = 6;
    {PROTOBUF_FIELD_OFFSET(Position, _impl_.altitude_source_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kOpenEnum)},
    // fixed32 timestamp = 7;
    {PROTOBUF_FIELD_OFFSET(Position, _impl_.timestamp_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFixed32)},
    // int32 timestamp_millis_adjust = 8;
    {PROTOBUF_FIELD_OFFSET(Position, _impl_.timestamp_millis_adjust_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional sint32 altitude_hae = 9;
    {PROTOBUF_FIELD_OFFSET(Position, _impl_.altitude_hae_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kSInt32)},
    // optional sint32 altitude_geoidal_separation = 10;
    {PROTOBUF_FIELD_OFFSET(Position, _impl_.altitude_geoidal_separation_), _Internal::kHasBitsOffset + 9, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kSInt32)},
    // uint32 PDOP = 11;
    {PROTOBUF_FIELD_OFFSET(Position, _impl_.pdop_), _Internal::kHasBitsOffset + 10, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // uint32 HDOP = 12;
    {PROTOBUF_FIELD_OFFSET(Position, _impl_.hdop_), _Internal::kHasBitsOffset + 11, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // uint32 VDOP = 13;
    {PROTOBUF_FIELD_OFFSET(Position, _impl_.vdop_), _Internal::kHasBitsOffset + 12, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // uint32 gps_accuracy = 14;
    {PROTOBUF_FIELD_OFFSET(Position, _impl_.gps_accuracy_), _Internal::kHasBitsOffset + 13, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 ground_speed = 15;
    {PROTOBUF_FIELD_OFFSET(Position, _impl_.ground_speed_), _Internal::kHasBitsOffset + 14, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 ground_track = 16;
    {PROTOBUF_FIELD_OFFSET(Position, _impl_.ground_track_), _Internal::kHasBitsOffset + 15, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // uint32 fix_quality = 17;
    {PROTOBUF_FIELD_OFFSET(Position, _impl_.fix_quality_), _Internal::kHasBitsOffset + 16, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // uint32 fix_type = 18;
    {PROTOBUF_FIELD_OFFSET(Position, _impl_.fix_type_), _Internal::kHasBitsOffset + 17, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // uint32 sats_in_view = 19;
    {PROTOBUF_FIELD_OFFSET(Position, _impl_.sats_in_view_), _Internal::kHasBitsOffset + 18, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // uint32 sensor_id = 20;
    {PROTOBUF_FIELD_OFFSET(Position, _impl_.sensor_id_), _Internal::kHasBitsOffset + 19, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // uint32 next_update = 21;
    {PROTOBUF_FIELD_OFFSET(Position, _impl_.next_update_), _Internal::kHasBitsOffset + 20, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // uint32 seq_number = 22;
    {PROTOBUF_FIELD_OFFSET(Position, _impl_.seq_number_), _Internal::kHasBitsOffset + 21, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // uint32 precision_bits = 23;
    {PROTOBUF_FIELD_OFFSET(Position, _impl_.precision_bits_), _Internal::kHasBitsOffset + 22, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void Position::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.Position)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x000000ffu) != 0) {
    ::memset(&_impl_.latitude_i_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.timestamp_millis_adjust_) -
        reinterpret_cast<char*>(&_impl_.latitude_i_)) + sizeof(_impl_.timestamp_millis_adjust_));
  }
  if ((cached_has_bits & 0x0000ff00u) != 0) {
    ::memset(&_impl_.altitude_hae_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.ground_track_) -
        reinterpret_cast<char*>(&_impl_.altitude_hae_)) + sizeof(_impl_.ground_track_));
  }
  if ((cached_has_bits & 0x007f0000u) != 0) {
    ::memset(&_impl_.fix_quality_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.precision_bits_) -
        reinterpret_cast<char*>(&_impl_.fix_quality_)) + sizeof(_impl_.precision_bits_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL Position::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const Position& this_ = static_cast<const Position&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL Position::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const Position& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.Position)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional sfixed32 latitude_i = 1;
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSFixed32ToArray(
        1, this_._internal_latitude_i(), target);
  }

  // optional sfixed32 longitude_i = 2;
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSFixed32ToArray(
        2, this_._internal_longitude_i(), target);
  }

  // optional int32 altitude = 3;
  if ((cached_has_bits & 0x00000004u) != 0) {
    target =
        ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<3>(
            stream, this_._internal_altitude(), target);
  }

  // fixed32 time = 4;
  if ((cached_has_bits & 0x00000008u) != 0) {
    if (this_._internal_time() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
          4, this_._internal_time(), target);
    }
  }

  // .meshtastic.Position.LocSource location_source = 5;
  if ((cached_has_bits & 0x00000010u) != 0) {
    if (this_._internal_location_source() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          5, this_._internal_location_source(), target);
    }
  }

  // .meshtastic.Position.AltSource altitude_source = 6;
  if ((cached_has_bits & 0x00000020u) != 0) {
    if (this_._internal_altitude_source() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          6, this_._internal_altitude_source(), target);
    }
  }

  // fixed32 timestamp = 7;
  if ((cached_has_bits & 0x00000040u) != 0) {
    if (this_._internal_timestamp() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
          7, this_._internal_timestamp(), target);
    }
  }

  // int32 timestamp_millis_adjust = 8;
  if ((cached_has_bits & 0x00000080u) != 0) {
    if (this_._internal_timestamp_millis_adjust() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<8>(
              stream, this_._internal_timestamp_millis_adjust(), target);
    }
  }

  // optional sint32 altitude_hae = 9;
  if ((cached_has_bits & 0x00000100u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(
        9, this_._internal_altitude_hae(), target);
  }

  // optional sint32 altitude_geoidal_separation = 10;
  if ((cached_has_bits & 0x00000200u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(
        10, this_._internal_altitude_geoidal_separation(), target);
  }

  // uint32 PDOP = 11;
  if ((cached_has_bits & 0x00000400u) != 0) {
    if (this_._internal_pdop() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          11, this_._internal_pdop(), target);
    }
  }

  // uint32 HDOP = 12;
  if ((cached_has_bits & 0x00000800u) != 0) {
    if (this_._internal_hdop() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          12, this_._internal_hdop(), target);
    }
  }

  // uint32 VDOP = 13;
  if ((cached_has_bits & 0x00001000u) != 0) {
    if (this_._internal_vdop() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          13, this_._internal_vdop(), target);
    }
  }

  // uint32 gps_accuracy = 14;
  if ((cached_has_bits & 0x00002000u) != 0) {
    if (this_._internal_gps_accuracy() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          14, this_._internal_gps_accuracy(), target);
    }
  }

  // optional uint32 ground_speed = 15;
  if ((cached_has_bits & 0x00004000u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        15, this_._internal_ground_speed(), target);
  }

  // optional uint32 ground_track = 16;
  if ((cached_has_bits & 0x00008000u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        16, this_._internal_ground_track(), target);
  }

  // uint32 fix_quality = 17;
  if ((cached_has_bits & 0x00010000u) != 0) {
    if (this_._internal_fix_quality() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          17, this_._internal_fix_quality(), target);
    }
  }

  // uint32 fix_type = 18;
  if ((cached_has_bits & 0x00020000u) != 0) {
    if (this_._internal_fix_type() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          18, this_._internal_fix_type(), target);
    }
  }

  // uint32 sats_in_view = 19;
  if ((cached_has_bits & 0x00040000u) != 0) {
    if (this_._internal_sats_in_view() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          19, this_._internal_sats_in_view(), target);
    }
  }

  // uint32 sensor_id = 20;
  if ((cached_has_bits & 0x00080000u) != 0) {
    if (this_._internal_sensor_id() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          20, this_._internal_sensor_id(), target);
    }
  }

  // uint32 next_update = 21;
  if ((cached_has_bits & 0x00100000u) != 0) {
    if (this_._internal_next_update() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          21, this_._internal_next_update(), target);
    }
  }

  // uint32 seq_number = 22;
  if ((cached_has_bits & 0x00200000u) != 0) {
    if (this_._internal_seq_number() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          22, this_._internal_seq_number(), target);
    }
  }

  // uint32 precision_bits = 23;
  if ((cached_has_bits & 0x00400000u) != 0) {
    if (this_._internal_precision_bits() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          23, this_._internal_precision_bits(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.Position)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t Position::ByteSizeLong(const MessageLite& base) {
  const Position& this_ = static_cast<const Position&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t Position::ByteSizeLong() const {
  const Position& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:meshtastic.Position)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += ::absl::popcount(0x00000003u & cached_has_bits) * 5;
  if ((cached_has_bits & 0x000000fcu) != 0) {
    // optional int32 altitude = 3;
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this_._internal_altitude());
    }
    // fixed32 time = 4;
    if ((cached_has_bits & 0x00000008u) != 0) {
      if (this_._internal_time() != 0) {
        total_size += 5;
      }
    }
    // .meshtastic.Position.LocSource location_source = 5;
    if ((cached_has_bits & 0x00000010u) != 0) {
      if (this_._internal_location_source() != 0) {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this_._internal_location_source());
      }
    }
    // .meshtastic.Position.AltSource altitude_source = 6;
    if ((cached_has_bits & 0x00000020u) != 0) {
      if (this_._internal_altitude_source() != 0) {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this_._internal_altitude_source());
      }
    }
    // fixed32 timestamp = 7;
    if ((cached_has_bits & 0x00000040u) != 0) {
      if (this_._internal_timestamp() != 0) {
        total_size += 5;
      }
    }
    // int32 timestamp_millis_adjust = 8;
    if ((cached_has_bits & 0x00000080u) != 0) {
      if (this_._internal_timestamp_millis_adjust() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
            this_._internal_timestamp_millis_adjust());
      }
    }
  }
  if ((cached_has_bits & 0x0000ff00u) != 0) {
    // optional sint32 altitude_hae = 9;
    if ((cached_has_bits & 0x00000100u) != 0) {
      total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(
          this_._internal_altitude_hae());
    }
    // optional sint32 altitude_geoidal_separation = 10;
    if ((cached_has_bits & 0x00000200u) != 0) {
      total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(
          this_._internal_altitude_geoidal_separation());
    }
    // uint32 PDOP = 11;
    if ((cached_has_bits & 0x00000400u) != 0) {
      if (this_._internal_pdop() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
            this_._internal_pdop());
      }
    }
    // uint32 HDOP = 12;
    if ((cached_has_bits & 0x00000800u) != 0) {
      if (this_._internal_hdop() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
            this_._internal_hdop());
      }
    }
    // uint32 VDOP = 13;
    if ((cached_has_bits & 0x00001000u) != 0) {
      if (this_._internal_vdop() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
            this_._internal_vdop());
      }
    }
    // uint32 gps_accuracy = 14;
    if ((cached_has_bits & 0x00002000u) != 0) {
      if (this_._internal_gps_accuracy() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
            this_._internal_gps_accuracy());
      }
    }
    // optional uint32 ground_speed = 15;
    if ((cached_has_bits & 0x00004000u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_ground_speed());
    }
    // optional uint32 ground_track = 16;
    if ((cached_has_bits & 0x00008000u) != 0) {
      total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                      this_._internal_ground_track());
    }
  }
  if ((cached_has_bits & 0x007f0000u) != 0) {
    // uint32 fix_quality = 17;
    if ((cached_has_bits & 0x00010000u) != 0) {
      if (this_._internal_fix_quality() != 0) {
        total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                        this_._internal_fix_quality());
      }
    }
    // uint32 fix_type = 18;
    if ((cached_has_bits & 0x00020000u) != 0) {
      if (this_._internal_fix_type() != 0) {
        total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                        this_._internal_fix_type());
      }
    }
    // uint32 sats_in_view = 19;
    if ((cached_has_bits & 0x00040000u) != 0) {
      if (this_._internal_sats_in_view() != 0) {
        total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                        this_._internal_sats_in_view());
      }
    }
    // uint32 sensor_id = 20;
    if ((cached_has_bits & 0x00080000u) != 0) {
      if (this_._internal_sensor_id() != 0) {
        total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                        this_._internal_sensor_id());
      }
    }
    // uint32 next_update = 21;
    if ((cached_has_bits & 0x00100000u) != 0) {
      if (this_._internal_next_update() != 0) {
        total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                        this_._internal_next_update());
      }
    }
    // uint32 seq_number = 22;
    if ((cached_has_bits & 0x00200000u) != 0) {
      if (this_._internal_seq_number() != 0) {
        total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                        this_._internal_seq_number());
      }
    }
    // uint32 precision_bits = 23;
    if ((cached_has_bits & 0x00400000u) != 0) {
      if (this_._internal_precision_bits() != 0) {
        total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                        this_._internal_precision_bits());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void Position::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Position*>(&to_msg);
  auto& from = static_cast<const Position&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.Position)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x000000ffu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _this->_impl_.latitude_i_ = from._impl_.latitude_i_;
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _this->_impl_.longitude_i_ = from._impl_.longitude_i_;
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _this->_impl_.altitude_ = from._impl_.altitude_;
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      if (from._internal_time() != 0) {
        _this->_impl_.time_ = from._impl_.time_;
      }
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      if (from._internal_location_source() != 0) {
        _this->_impl_.location_source_ = from._impl_.location_source_;
      }
    }
    if ((cached_has_bits & 0x00000020u) != 0) {
      if (from._internal_altitude_source() != 0) {
        _this->_impl_.altitude_source_ = from._impl_.altitude_source_;
      }
    }
    if ((cached_has_bits & 0x00000040u) != 0) {
      if (from._internal_timestamp() != 0) {
        _this->_impl_.timestamp_ = from._impl_.timestamp_;
      }
    }
    if ((cached_has_bits & 0x00000080u) != 0) {
      if (from._internal_timestamp_millis_adjust() != 0) {
        _this->_impl_.timestamp_millis_adjust_ = from._impl_.timestamp_millis_adjust_;
      }
    }
  }
  if ((cached_has_bits & 0x0000ff00u) != 0) {
    if ((cached_has_bits & 0x00000100u) != 0) {
      _this->_impl_.altitude_hae_ = from._impl_.altitude_hae_;
    }
    if ((cached_has_bits & 0x00000200u) != 0) {
      _this->_impl_.altitude_geoidal_separation_ = from._impl_.altitude_geoidal_separation_;
    }
    if ((cached_has_bits & 0x00000400u) != 0) {
      if (from._internal_pdop() != 0) {
        _this->_impl_.pdop_ = from._impl_.pdop_;
      }
    }
    if ((cached_has_bits & 0x00000800u) != 0) {
      if (from._internal_hdop() != 0) {
        _this->_impl_.hdop_ = from._impl_.hdop_;
      }
    }
    if ((cached_has_bits & 0x00001000u) != 0) {
      if (from._internal_vdop() != 0) {
        _this->_impl_.vdop_ = from._impl_.vdop_;
      }
    }
    if ((cached_has_bits & 0x00002000u) != 0) {
      if (from._internal_gps_accuracy() != 0) {
        _this->_impl_.gps_accuracy_ = from._impl_.gps_accuracy_;
      }
    }
    if ((cached_has_bits & 0x00004000u) != 0) {
      _this->_impl_.ground_speed_ = from._impl_.ground_speed_;
    }
    if ((cached_has_bits & 0x00008000u) != 0) {
      _this->_impl_.ground_track_ = from._impl_.ground_track_;
    }
  }
  if ((cached_has_bits & 0x007f0000u) != 0) {
    if ((cached_has_bits & 0x00010000u) != 0) {
      if (from._internal_fix_quality() != 0) {
        _this->_impl_.fix_quality_ = from._impl_.fix_quality_;
      }
    }
    if ((cached_has_bits & 0x00020000u) != 0) {
      if (from._internal_fix_type() != 0) {
        _this->_impl_.fix_type_ = from._impl_.fix_type_;
      }
    }
    if ((cached_has_bits & 0x00040000u) != 0) {
      if (from._internal_sats_in_view() != 0) {
        _this->_impl_.sats_in_view_ = from._impl_.sats_in_view_;
      }
    }
    if ((cached_has_bits & 0x00080000u) != 0) {
      if (from._internal_sensor_id() != 0) {
        _this->_impl_.sensor_id_ = from._impl_.sensor_id_;
      }
    }
    if ((cached_has_bits & 0x00100000u) != 0) {
      if (from._internal_next_update() != 0) {
        _this->_impl_.next_update_ = from._impl_.next_update_;
      }
    }
    if ((cached_has_bits & 0x00200000u) != 0) {
      if (from._internal_seq_number() != 0) {
        _this->_impl_.seq_number_ = from._impl_.seq_number_;
      }
    }
    if ((cached_has_bits & 0x00400000u) != 0) {
      if (from._internal_precision_bits() != 0) {
        _this->_impl_.precision_bits_ = from._impl_.precision_bits_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Position::CopyFrom(const Position& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.Position)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Position::InternalSwap(Position* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Position, _impl_.precision_bits_)
      + sizeof(Position::_impl_.precision_bits_)
      - PROTOBUF_FIELD_OFFSET(Position, _impl_.latitude_i_)>(
          reinterpret_cast<char*>(&_impl_.latitude_i_),
          reinterpret_cast<char*>(&other->_impl_.latitude_i_));
}

::google::protobuf::Metadata Position::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class User::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<User>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(User, _impl_._has_bits_);
};

User::User(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, User_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:meshtastic.User)
}
PROTOBUF_NDEBUG_INLINE User::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::meshtastic::User& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        id_(arena, from.id_),
        long_name_(arena, from.long_name_),
        short_name_(arena, from.short_name_),
        macaddr_(arena, from.macaddr_),
        public_key_(arena, from.public_key_) {}

User::User(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const User& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, User_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  User* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, hw_model_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, hw_model_),
           offsetof(Impl_, is_unmessagable_) -
               offsetof(Impl_, hw_model_) +
               sizeof(Impl_::is_unmessagable_));

  // @@protoc_insertion_point(copy_constructor:meshtastic.User)
}
PROTOBUF_NDEBUG_INLINE User::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        id_(arena),
        long_name_(arena),
        short_name_(arena),
        macaddr_(arena),
        public_key_(arena) {}

inline void User::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, hw_model_),
           0,
           offsetof(Impl_, is_unmessagable_) -
               offsetof(Impl_, hw_model_) +
               sizeof(Impl_::is_unmessagable_));
}
User::~User() {
  // @@protoc_insertion_point(destructor:meshtastic.User)
  SharedDtor(*this);
}
inline void User::SharedDtor(MessageLite& self) {
  User& this_ = static_cast<User&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.id_.Destroy();
  this_._impl_.long_name_.Destroy();
  this_._impl_.short_name_.Destroy();
  this_._impl_.macaddr_.Destroy();
  this_._impl_.public_key_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL User::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) User(arena);
}
constexpr auto User::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(User),
                                            alignof(User));
}
constexpr auto User::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_User_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &User::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<User>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &User::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<User>(), &User::ByteSizeLong,
              &User::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(User, _impl_._cached_size_),
          false,
      },
      &User::kDescriptorMethods,
      &descriptor_table_meshtastic_2fmesh_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull User_class_data_ =
        User::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
User::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&User_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(User_class_data_.tc_table);
  return User_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 9, 0, 53, 2>
User::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(User, _impl_._has_bits_),
    0, // no _extensions_
    9, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294966784,  // skipmap
    offsetof(decltype(_table_), field_entries),
    9,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    User_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::meshtastic::User>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string id = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(User, _impl_.id_)}},
    // string long_name = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 1, 0, PROTOBUF_FIELD_OFFSET(User, _impl_.long_name_)}},
    // string short_name = 3;
    {::_pbi::TcParser::FastUS1,
     {26, 2, 0, PROTOBUF_FIELD_OFFSET(User, _impl_.short_name_)}},
    // bytes macaddr = 4 [deprecated = true];
    {::_pbi::TcParser::FastBS1,
     {34, 3, 0, PROTOBUF_FIELD_OFFSET(User, _impl_.macaddr_)}},
    // .meshtastic.HardwareModel hw_model = 5;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(User, _impl_.hw_model_), 5>(),
     {40, 5, 0, PROTOBUF_FIELD_OFFSET(User, _impl_.hw_model_)}},
    // bool is_licensed = 6;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(User, _impl_.is_licensed_), 7>(),
     {48, 7, 0, PROTOBUF_FIELD_OFFSET(User, _impl_.is_licensed_)}},
    // .meshtastic.Config.DeviceConfig.Role role = 7;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(User, _impl_.role_), 6>(),
     {56, 6, 0, PROTOBUF_FIELD_OFFSET(User, _impl_.role_)}},
    // bytes public_key = 8;
    {::_pbi::TcParser::FastBS1,
     {66, 4, 0, PROTOBUF_FIELD_OFFSET(User, _impl_.public_key_)}},
    // optional bool is_unmessagable = 9;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(User, _impl_.is_unmessagable_), 8>(),
     {72, 8, 0, PROTOBUF_FIELD_OFFSET(User, _impl_.is_unmessagable_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // string id = 1;
    {PROTOBUF_FIELD_OFFSET(User, _impl_.id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string long_name = 2;
    {PROTOBUF_FIELD_OFFSET(User, _impl_.long_name_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string short_name = 3;
    {PROTOBUF_FIELD_OFFSET(User, _impl_.short_name_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // bytes macaddr = 4 [deprecated = true];
    {PROTOBUF_FIELD_OFFSET(User, _impl_.macaddr_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // .meshtastic.HardwareModel hw_model = 5;
    {PROTOBUF_FIELD_OFFSET(User, _impl_.hw_model_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kOpenEnum)},
    // bool is_licensed = 6;
    {PROTOBUF_FIELD_OFFSET(User, _impl_.is_licensed_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // .meshtastic.Config.DeviceConfig.Role role = 7;
    {PROTOBUF_FIELD_OFFSET(User, _impl_.role_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kOpenEnum)},
    // bytes public_key = 8;
    {PROTOBUF_FIELD_OFFSET(User, _impl_.public_key_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bool is_unmessagable = 9;
    {PROTOBUF_FIELD_OFFSET(User, _impl_.is_unmessagable_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
    "\17\2\11\12\0\0\0\0\0\0\0\0\0\0\0\0"
    "meshtastic.User"
    "id"
    "long_name"
    "short_name"
  }},
};
PROTOBUF_NOINLINE void User::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.User)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000001fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _impl_.id_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _impl_.long_name_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _impl_.short_name_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      _impl_.macaddr_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      _impl_.public_key_.ClearNonDefaultToEmpty();
    }
  }
  if ((cached_has_bits & 0x000000e0u) != 0) {
    ::memset(&_impl_.hw_model_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.is_licensed_) -
        reinterpret_cast<char*>(&_impl_.hw_model_)) + sizeof(_impl_.is_licensed_));
  }
  _impl_.is_unmessagable_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL User::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const User& this_ = static_cast<const User&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL User::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const User& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.User)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // string id = 1;
  if ((this_._impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (!this_._internal_id().empty()) {
      const ::std::string& _s = this_._internal_id();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "meshtastic.User.id");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // string long_name = 2;
  if ((this_._impl_._has_bits_[0] & 0x00000002u) != 0) {
    if (!this_._internal_long_name().empty()) {
      const ::std::string& _s = this_._internal_long_name();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "meshtastic.User.long_name");
      target = stream->WriteStringMaybeAliased(2, _s, target);
    }
  }

  // string short_name = 3;
  if ((this_._impl_._has_bits_[0] & 0x00000004u) != 0) {
    if (!this_._internal_short_name().empty()) {
      const ::std::string& _s = this_._internal_short_name();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "meshtastic.User.short_name");
      target = stream->WriteStringMaybeAliased(3, _s, target);
    }
  }

  // bytes macaddr = 4 [deprecated = true];
  if ((this_._impl_._has_bits_[0] & 0x00000008u) != 0) {
    if (!this_._internal_macaddr().empty()) {
      const ::std::string& _s = this_._internal_macaddr();
      target = stream->WriteBytesMaybeAliased(4, _s, target);
    }
  }

  // .meshtastic.HardwareModel hw_model = 5;
  if ((this_._impl_._has_bits_[0] & 0x00000020u) != 0) {
    if (this_._internal_hw_model() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          5, this_._internal_hw_model(), target);
    }
  }

  // bool is_licensed = 6;
  if ((this_._impl_._has_bits_[0] & 0x00000080u) != 0) {
    if (this_._internal_is_licensed() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          6, this_._internal_is_licensed(), target);
    }
  }

  // .meshtastic.Config.DeviceConfig.Role role = 7;
  if ((this_._impl_._has_bits_[0] & 0x00000040u) != 0) {
    if (this_._internal_role() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          7, this_._internal_role(), target);
    }
  }

  // bytes public_key = 8;
  if ((this_._impl_._has_bits_[0] & 0x00000010u) != 0) {
    if (!this_._internal_public_key().empty()) {
      const ::std::string& _s = this_._internal_public_key();
      target = stream->WriteBytesMaybeAliased(8, _s, target);
    }
  }

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional bool is_unmessagable = 9;
  if ((cached_has_bits & 0x00000100u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        9, this_._internal_is_unmessagable(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.User)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t User::ByteSizeLong(const MessageLite& base) {
  const User& this_ = static_cast<const User&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t User::ByteSizeLong() const {
  const User& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:meshtastic.User)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += static_cast<bool>(0x00000100u & cached_has_bits) * 2;
  if ((cached_has_bits & 0x000000ffu) != 0) {
    // string id = 1;
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (!this_._internal_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_id());
      }
    }
    // string long_name = 2;
    if ((cached_has_bits & 0x00000002u) != 0) {
      if (!this_._internal_long_name().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_long_name());
      }
    }
    // string short_name = 3;
    if ((cached_has_bits & 0x00000004u) != 0) {
      if (!this_._internal_short_name().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_short_name());
      }
    }
    // bytes macaddr = 4 [deprecated = true];
    if ((cached_has_bits & 0x00000008u) != 0) {
      if (!this_._internal_macaddr().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                        this_._internal_macaddr());
      }
    }
    // bytes public_key = 8;
    if ((cached_has_bits & 0x00000010u) != 0) {
      if (!this_._internal_public_key().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                        this_._internal_public_key());
      }
    }
    // .meshtastic.HardwareModel hw_model = 5;
    if ((cached_has_bits & 0x00000020u) != 0) {
      if (this_._internal_hw_model() != 0) {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this_._internal_hw_model());
      }
    }
    // .meshtastic.Config.DeviceConfig.Role role = 7;
    if ((cached_has_bits & 0x00000040u) != 0) {
      if (this_._internal_role() != 0) {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this_._internal_role());
      }
    }
    // bool is_licensed = 6;
    if ((cached_has_bits & 0x00000080u) != 0) {
      if (this_._internal_is_licensed() != 0) {
        total_size += 2;
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void User::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<User*>(&to_msg);
  auto& from = static_cast<const User&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.User)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x000000ffu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (!from._internal_id().empty()) {
        _this->_internal_set_id(from._internal_id());
      } else {
        if (_this->_impl_.id_.IsDefault()) {
          _this->_internal_set_id("");
        }
      }
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      if (!from._internal_long_name().empty()) {
        _this->_internal_set_long_name(from._internal_long_name());
      } else {
        if (_this->_impl_.long_name_.IsDefault()) {
          _this->_internal_set_long_name("");
        }
      }
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      if (!from._internal_short_name().empty()) {
        _this->_internal_set_short_name(from._internal_short_name());
      } else {
        if (_this->_impl_.short_name_.IsDefault()) {
          _this->_internal_set_short_name("");
        }
      }
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      if (!from._internal_macaddr().empty()) {
        _this->_internal_set_macaddr(from._internal_macaddr());
      } else {
        if (_this->_impl_.macaddr_.IsDefault()) {
          _this->_internal_set_macaddr("");
        }
      }
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      if (!from._internal_public_key().empty()) {
        _this->_internal_set_public_key(from._internal_public_key());
      } else {
        if (_this->_impl_.public_key_.IsDefault()) {
          _this->_internal_set_public_key("");
        }
      }
    }
    if ((cached_has_bits & 0x00000020u) != 0) {
      if (from._internal_hw_model() != 0) {
        _this->_impl_.hw_model_ = from._impl_.hw_model_;
      }
    }
    if ((cached_has_bits & 0x00000040u) != 0) {
      if (from._internal_role() != 0) {
        _this->_impl_.role_ = from._impl_.role_;
      }
    }
    if ((cached_has_bits & 0x00000080u) != 0) {
      if (from._internal_is_licensed() != 0) {
        _this->_impl_.is_licensed_ = from._impl_.is_licensed_;
      }
    }
  }
  if ((cached_has_bits & 0x00000100u) != 0) {
    _this->_impl_.is_unmessagable_ = from._impl_.is_unmessagable_;
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void User::CopyFrom(const User& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.User)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void User::InternalSwap(User* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.id_, &other->_impl_.id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.long_name_, &other->_impl_.long_name_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.short_name_, &other->_impl_.short_name_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.macaddr_, &other->_impl_.macaddr_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.public_key_, &other->_impl_.public_key_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(User, _impl_.is_unmessagable_)
      + sizeof(User::_impl_.is_unmessagable_)
      - PROTOBUF_FIELD_OFFSET(User, _impl_.hw_model_)>(
          reinterpret_cast<char*>(&_impl_.hw_model_),
          reinterpret_cast<char*>(&other->_impl_.hw_model_));
}

::google::protobuf::Metadata User::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class RouteDiscovery::_Internal {
 public:
};

RouteDiscovery::RouteDiscovery(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, RouteDiscovery_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:meshtastic.RouteDiscovery)
}
PROTOBUF_NDEBUG_INLINE RouteDiscovery::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::meshtastic::RouteDiscovery& from_msg)
      : route_{visibility, arena, from.route_},
        snr_towards_{visibility, arena, from.snr_towards_},
        _snr_towards_cached_byte_size_{0},
        route_back_{visibility, arena, from.route_back_},
        snr_back_{visibility, arena, from.snr_back_},
        _snr_back_cached_byte_size_{0},
        _cached_size_{0} {}

RouteDiscovery::RouteDiscovery(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const RouteDiscovery& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, RouteDiscovery_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  RouteDiscovery* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:meshtastic.RouteDiscovery)
}
PROTOBUF_NDEBUG_INLINE RouteDiscovery::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : route_{visibility, arena},
        snr_towards_{visibility, arena},
        _snr_towards_cached_byte_size_{0},
        route_back_{visibility, arena},
        snr_back_{visibility, arena},
        _snr_back_cached_byte_size_{0},
        _cached_size_{0} {}

inline void RouteDiscovery::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
RouteDiscovery::~RouteDiscovery() {
  // @@protoc_insertion_point(destructor:meshtastic.RouteDiscovery)
  SharedDtor(*this);
}
inline void RouteDiscovery::SharedDtor(MessageLite& self) {
  RouteDiscovery& this_ = static_cast<RouteDiscovery&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL RouteDiscovery::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) RouteDiscovery(arena);
}
constexpr auto RouteDiscovery::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(RouteDiscovery, _impl_.route_) +
          decltype(RouteDiscovery::_impl_.route_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(RouteDiscovery, _impl_.snr_towards_) +
          decltype(RouteDiscovery::_impl_.snr_towards_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(RouteDiscovery, _impl_.route_back_) +
          decltype(RouteDiscovery::_impl_.route_back_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(RouteDiscovery, _impl_.snr_back_) +
          decltype(RouteDiscovery::_impl_.snr_back_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(RouteDiscovery), alignof(RouteDiscovery), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&RouteDiscovery::PlacementNew_,
                                 sizeof(RouteDiscovery),
                                 alignof(RouteDiscovery));
  }
}
constexpr auto RouteDiscovery::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_RouteDiscovery_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &RouteDiscovery::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<RouteDiscovery>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &RouteDiscovery::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<RouteDiscovery>(), &RouteDiscovery::ByteSizeLong,
              &RouteDiscovery::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(RouteDiscovery, _impl_._cached_size_),
          false,
      },
      &RouteDiscovery::kDescriptorMethods,
      &descriptor_table_meshtastic_2fmesh_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull RouteDiscovery_class_data_ =
        RouteDiscovery::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
RouteDiscovery::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&RouteDiscovery_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(RouteDiscovery_class_data_.tc_table);
  return RouteDiscovery_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 0, 2>
RouteDiscovery::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    RouteDiscovery_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::meshtastic::RouteDiscovery>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated int32 snr_back = 4;
    {::_pbi::TcParser::FastV32P1,
     {34, 63, 0, PROTOBUF_FIELD_OFFSET(RouteDiscovery, _impl_.snr_back_)}},
    // repeated fixed32 route = 1;
    {::_pbi::TcParser::FastF32P1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(RouteDiscovery, _impl_.route_)}},
    // repeated int32 snr_towards = 2;
    {::_pbi::TcParser::FastV32P1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(RouteDiscovery, _impl_.snr_towards_)}},
    // repeated fixed32 route_back = 3;
    {::_pbi::TcParser::FastF32P1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(RouteDiscovery, _impl_.route_back_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated fixed32 route = 1;
    {PROTOBUF_FIELD_OFFSET(RouteDiscovery, _impl_.route_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedFixed32)},
    // repeated int32 snr_towards = 2;
    {PROTOBUF_FIELD_OFFSET(RouteDiscovery, _impl_.snr_towards_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt32)},
    // repeated fixed32 route_back = 3;
    {PROTOBUF_FIELD_OFFSET(RouteDiscovery, _impl_.route_back_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedFixed32)},
    // repeated int32 snr_back = 4;
    {PROTOBUF_FIELD_OFFSET(RouteDiscovery, _impl_.snr_back_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt32)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void RouteDiscovery::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.RouteDiscovery)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.route_.Clear();
  _impl_.snr_towards_.Clear();
  _impl_.route_back_.Clear();
  _impl_.snr_back_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL RouteDiscovery::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const RouteDiscovery& this_ = static_cast<const RouteDiscovery&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL RouteDiscovery::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const RouteDiscovery& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.RouteDiscovery)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated fixed32 route = 1;
  if (this_._internal_route_size() > 0) {
    target = stream->WriteFixedPacked(1, this_._internal_route(), target);
  }

  // repeated int32 snr_towards = 2;
  {
    int byte_size = this_._impl_._snr_towards_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          2, this_._internal_snr_towards(), byte_size, target);
    }
  }

  // repeated fixed32 route_back = 3;
  if (this_._internal_route_back_size() > 0) {
    target = stream->WriteFixedPacked(3, this_._internal_route_back(), target);
  }

  // repeated int32 snr_back = 4;
  {
    int byte_size = this_._impl_._snr_back_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          4, this_._internal_snr_back(), byte_size, target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.RouteDiscovery)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t RouteDiscovery::ByteSizeLong(const MessageLite& base) {
  const RouteDiscovery& this_ = static_cast<const RouteDiscovery&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t RouteDiscovery::ByteSizeLong() const {
  const RouteDiscovery& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:meshtastic.RouteDiscovery)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated fixed32 route = 1;
    {
      ::size_t data_size = ::size_t{4} *
          ::_pbi::FromIntSize(this_._internal_route_size());
      ::size_t tag_size = data_size == 0
          ? 0
          : 1 + ::_pbi::WireFormatLite::Int32Size(
                              static_cast<::int32_t>(data_size));
      total_size += tag_size + data_size;
    }
    // repeated int32 snr_towards = 2;
    {
      total_size +=
          ::_pbi::WireFormatLite::Int32SizeWithPackedTagSize(
              this_._internal_snr_towards(), 1,
              this_._impl_._snr_towards_cached_byte_size_);
    }
    // repeated fixed32 route_back = 3;
    {
      ::size_t data_size = ::size_t{4} *
          ::_pbi::FromIntSize(this_._internal_route_back_size());
      ::size_t tag_size = data_size == 0
          ? 0
          : 1 + ::_pbi::WireFormatLite::Int32Size(
                              static_cast<::int32_t>(data_size));
      total_size += tag_size + data_size;
    }
    // repeated int32 snr_back = 4;
    {
      total_size +=
          ::_pbi::WireFormatLite::Int32SizeWithPackedTagSize(
              this_._internal_snr_back(), 1,
              this_._impl_._snr_back_cached_byte_size_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void RouteDiscovery::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<RouteDiscovery*>(&to_msg);
  auto& from = static_cast<const RouteDiscovery&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.RouteDiscovery)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_route()->MergeFrom(from._internal_route());
  _this->_internal_mutable_snr_towards()->MergeFrom(from._internal_snr_towards());
  _this->_internal_mutable_route_back()->MergeFrom(from._internal_route_back());
  _this->_internal_mutable_snr_back()->MergeFrom(from._internal_snr_back());
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void RouteDiscovery::CopyFrom(const RouteDiscovery& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.RouteDiscovery)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void RouteDiscovery::InternalSwap(RouteDiscovery* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.route_.InternalSwap(&other->_impl_.route_);
  _impl_.snr_towards_.InternalSwap(&other->_impl_.snr_towards_);
  _impl_.route_back_.InternalSwap(&other->_impl_.route_back_);
  _impl_.snr_back_.InternalSwap(&other->_impl_.snr_back_);
}

::google::protobuf::Metadata RouteDiscovery::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class Routing::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::meshtastic::Routing, _impl_._oneof_case_);
};

void Routing::set_allocated_route_request(::meshtastic::RouteDiscovery* PROTOBUF_NULLABLE route_request) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_variant();
  if (route_request) {
    ::google::protobuf::Arena* submessage_arena = route_request->GetArena();
    if (message_arena != submessage_arena) {
      route_request = ::google::protobuf::internal::GetOwnedMessage(message_arena, route_request, submessage_arena);
    }
    set_has_route_request();
    _impl_.variant_.route_request_ = route_request;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.Routing.route_request)
}
void Routing::set_allocated_route_reply(::meshtastic::RouteDiscovery* PROTOBUF_NULLABLE route_reply) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_variant();
  if (route_reply) {
    ::google::protobuf::Arena* submessage_arena = route_reply->GetArena();
    if (message_arena != submessage_arena) {
      route_reply = ::google::protobuf::internal::GetOwnedMessage(message_arena, route_reply, submessage_arena);
    }
    set_has_route_reply();
    _impl_.variant_.route_reply_ = route_reply;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.Routing.route_reply)
}
Routing::Routing(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, Routing_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:meshtastic.Routing)
}
PROTOBUF_NDEBUG_INLINE Routing::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::meshtastic::Routing& from_msg)
      : variant_{},
        _cached_size_{0},
        _oneof_case_{from._oneof_case_[0]} {}

Routing::Routing(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const Routing& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, Routing_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  Routing* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  switch (variant_case()) {
    case VARIANT_NOT_SET:
      break;
      case kRouteRequest:
        _impl_.variant_.route_request_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.variant_.route_request_);
        break;
      case kRouteReply:
        _impl_.variant_.route_reply_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.variant_.route_reply_);
        break;
      case kErrorReason:
        _impl_.variant_.error_reason_ = from._impl_.variant_.error_reason_;
        break;
  }

  // @@protoc_insertion_point(copy_constructor:meshtastic.Routing)
}
PROTOBUF_NDEBUG_INLINE Routing::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : variant_{},
        _cached_size_{0},
        _oneof_case_{} {}

inline void Routing::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
Routing::~Routing() {
  // @@protoc_insertion_point(destructor:meshtastic.Routing)
  SharedDtor(*this);
}
inline void Routing::SharedDtor(MessageLite& self) {
  Routing& this_ = static_cast<Routing&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  if (this_.has_variant()) {
    this_.clear_variant();
  }
  this_._impl_.~Impl_();
}

void Routing::clear_variant() {
// @@protoc_insertion_point(one_of_clear_start:meshtastic.Routing)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (variant_case()) {
    case kRouteRequest: {
      if (GetArena() == nullptr) {
        delete _impl_.variant_.route_request_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.variant_.route_request_);
      }
      break;
    }
    case kRouteReply: {
      if (GetArena() == nullptr) {
        delete _impl_.variant_.route_reply_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.variant_.route_reply_);
      }
      break;
    }
    case kErrorReason: {
      // No need to clear
      break;
    }
    case VARIANT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = VARIANT_NOT_SET;
}


inline void* PROTOBUF_NONNULL Routing::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) Routing(arena);
}
constexpr auto Routing::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(Routing),
                                            alignof(Routing));
}
constexpr auto Routing::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_Routing_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &Routing::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<Routing>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &Routing::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<Routing>(), &Routing::ByteSizeLong,
              &Routing::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(Routing, _impl_._cached_size_),
          false,
      },
      &Routing::kDescriptorMethods,
      &descriptor_table_meshtastic_2fmesh_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull Routing_class_data_ =
        Routing::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
Routing::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&Routing_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(Routing_class_data_.tc_table);
  return Routing_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 3, 2, 0, 2>
Routing::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    3, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    Routing_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::meshtastic::Routing>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // .meshtastic.RouteDiscovery route_request = 1;
    {PROTOBUF_FIELD_OFFSET(Routing, _impl_.variant_.route_request_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .meshtastic.RouteDiscovery route_reply = 2;
    {PROTOBUF_FIELD_OFFSET(Routing, _impl_.variant_.route_reply_), _Internal::kOneofCaseOffset + 0, 1,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .meshtastic.Routing.Error error_reason = 3;
    {PROTOBUF_FIELD_OFFSET(Routing, _impl_.variant_.error_reason_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kOpenEnum)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::meshtastic::RouteDiscovery>()},
      {::_pbi::TcParser::GetTable<::meshtastic::RouteDiscovery>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void Routing::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.Routing)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_variant();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL Routing::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const Routing& this_ = static_cast<const Routing&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL Routing::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const Routing& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.Routing)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  switch (this_.variant_case()) {
    case kRouteRequest: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          1, *this_._impl_.variant_.route_request_, this_._impl_.variant_.route_request_->GetCachedSize(), target,
          stream);
      break;
    }
    case kRouteReply: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          2, *this_._impl_.variant_.route_reply_, this_._impl_.variant_.route_reply_->GetCachedSize(), target,
          stream);
      break;
    }
    case kErrorReason: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          3, this_._internal_error_reason(), target);
      break;
    }
    default:
      break;
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.Routing)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t Routing::ByteSizeLong(const MessageLite& base) {
  const Routing& this_ = static_cast<const Routing&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t Routing::ByteSizeLong() const {
  const Routing& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:meshtastic.Routing)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  switch (this_.variant_case()) {
    // .meshtastic.RouteDiscovery route_request = 1;
    case kRouteRequest: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.variant_.route_request_);
      break;
    }
    // .meshtastic.RouteDiscovery route_reply = 2;
    case kRouteReply: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.variant_.route_reply_);
      break;
    }
    // .meshtastic.Routing.Error error_reason = 3;
    case kErrorReason: {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this_._internal_error_reason());
      break;
    }
    case VARIANT_NOT_SET: {
      break;
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void Routing::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Routing*>(&to_msg);
  auto& from = static_cast<const Routing&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.Routing)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_variant();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kRouteRequest: {
        if (oneof_needs_init) {
          _this->_impl_.variant_.route_request_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.variant_.route_request_);
        } else {
          _this->_impl_.variant_.route_request_->MergeFrom(*from._impl_.variant_.route_request_);
        }
        break;
      }
      case kRouteReply: {
        if (oneof_needs_init) {
          _this->_impl_.variant_.route_reply_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.variant_.route_reply_);
        } else {
          _this->_impl_.variant_.route_reply_->MergeFrom(*from._impl_.variant_.route_reply_);
        }
        break;
      }
      case kErrorReason: {
        _this->_impl_.variant_.error_reason_ = from._impl_.variant_.error_reason_;
        break;
      }
      case VARIANT_NOT_SET:
        break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Routing::CopyFrom(const Routing& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.Routing)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Routing::InternalSwap(Routing* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.variant_, other->_impl_.variant_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::google::protobuf::Metadata Routing::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class Data::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<Data>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(Data, _impl_._has_bits_);
};

Data::Data(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, Data_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:meshtastic.Data)
}
PROTOBUF_NDEBUG_INLINE Data::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::meshtastic::Data& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        payload_(arena, from.payload_) {}

Data::Data(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const Data& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, Data_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  Data* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, portnum_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, portnum_),
           offsetof(Impl_, bitfield_) -
               offsetof(Impl_, portnum_) +
               sizeof(Impl_::bitfield_));

  // @@protoc_insertion_point(copy_constructor:meshtastic.Data)
}
PROTOBUF_NDEBUG_INLINE Data::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        payload_(arena) {}

inline void Data::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, portnum_),
           0,
           offsetof(Impl_, bitfield_) -
               offsetof(Impl_, portnum_) +
               sizeof(Impl_::bitfield_));
}
Data::~Data() {
  // @@protoc_insertion_point(destructor:meshtastic.Data)
  SharedDtor(*this);
}
inline void Data::SharedDtor(MessageLite& self) {
  Data& this_ = static_cast<Data&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.payload_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL Data::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) Data(arena);
}
constexpr auto Data::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(Data),
                                            alignof(Data));
}
constexpr auto Data::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_Data_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &Data::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<Data>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &Data::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<Data>(), &Data::ByteSizeLong,
              &Data::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(Data, _impl_._cached_size_),
          false,
      },
      &Data::kDescriptorMethods,
      &descriptor_table_meshtastic_2fmesh_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull Data_class_data_ =
        Data::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
Data::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&Data_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(Data_class_data_.tc_table);
  return Data_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 9, 0, 0, 2>
Data::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Data, _impl_._has_bits_),
    0, // no _extensions_
    9, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294966784,  // skipmap
    offsetof(decltype(_table_), field_entries),
    9,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    Data_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::meshtastic::Data>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .meshtastic.PortNum portnum = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Data, _impl_.portnum_), 1>(),
     {8, 1, 0, PROTOBUF_FIELD_OFFSET(Data, _impl_.portnum_)}},
    // bytes payload = 2;
    {::_pbi::TcParser::FastBS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(Data, _impl_.payload_)}},
    // bool want_response = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(Data, _impl_.want_response_), 2>(),
     {24, 2, 0, PROTOBUF_FIELD_OFFSET(Data, _impl_.want_response_)}},
    // fixed32 dest = 4;
    {::_pbi::TcParser::FastF32S1,
     {37, 3, 0, PROTOBUF_FIELD_OFFSET(Data, _impl_.dest_)}},
    // fixed32 source = 5;
    {::_pbi::TcParser::FastF32S1,
     {45, 4, 0, PROTOBUF_FIELD_OFFSET(Data, _impl_.source_)}},
    // fixed32 request_id = 6;
    {::_pbi::TcParser::FastF32S1,
     {53, 5, 0, PROTOBUF_FIELD_OFFSET(Data, _impl_.request_id_)}},
    // fixed32 reply_id = 7;
    {::_pbi::TcParser::FastF32S1,
     {61, 6, 0, PROTOBUF_FIELD_OFFSET(Data, _impl_.reply_id_)}},
    // fixed32 emoji = 8;
    {::_pbi::TcParser::FastF32S1,
     {69, 7, 0, PROTOBUF_FIELD_OFFSET(Data, _impl_.emoji_)}},
    // optional uint32 bitfield = 9;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Data, _impl_.bitfield_), 8>(),
     {72, 8, 0, PROTOBUF_FIELD_OFFSET(Data, _impl_.bitfield_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // .meshtastic.PortNum portnum = 1;
    {PROTOBUF_FIELD_OFFSET(Data, _impl_.portnum_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kOpenEnum)},
    // bytes payload = 2;
    {PROTOBUF_FIELD_OFFSET(Data, _impl_.payload_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // bool want_response = 3;
    {PROTOBUF_FIELD_OFFSET(Data, _impl_.want_response_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // fixed32 dest = 4;
    {PROTOBUF_FIELD_OFFSET(Data, _impl_.dest_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFixed32)},
    // fixed32 source = 5;
    {PROTOBUF_FIELD_OFFSET(Data, _impl_.source_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFixed32)},
    // fixed32 request_id = 6;
    {PROTOBUF_FIELD_OFFSET(Data, _impl_.request_id_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFixed32)},
    // fixed32 reply_id = 7;
    {PROTOBUF_FIELD_OFFSET(Data, _impl_.reply_id_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFixed32)},
    // fixed32 emoji = 8;
    {PROTOBUF_FIELD_OFFSET(Data, _impl_.emoji_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFixed32)},
    // optional uint32 bitfield = 9;
    {PROTOBUF_FIELD_OFFSET(Data, _impl_.bitfield_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void Data::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.Data)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    _impl_.payload_.ClearNonDefaultToEmpty();
  }
  if ((cached_has_bits & 0x000000feu) != 0) {
    ::memset(&_impl_.portnum_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.emoji_) -
        reinterpret_cast<char*>(&_impl_.portnum_)) + sizeof(_impl_.emoji_));
  }
  _impl_.bitfield_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL Data::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const Data& this_ = static_cast<const Data&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL Data::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const Data& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.Data)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // .meshtastic.PortNum portnum = 1;
  if ((this_._impl_._has_bits_[0] & 0x00000002u) != 0) {
    if (this_._internal_portnum() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          1, this_._internal_portnum(), target);
    }
  }

  // bytes payload = 2;
  if ((this_._impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (!this_._internal_payload().empty()) {
      const ::std::string& _s = this_._internal_payload();
      target = stream->WriteBytesMaybeAliased(2, _s, target);
    }
  }

  // bool want_response = 3;
  if ((this_._impl_._has_bits_[0] & 0x00000004u) != 0) {
    if (this_._internal_want_response() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          3, this_._internal_want_response(), target);
    }
  }

  // fixed32 dest = 4;
  if ((this_._impl_._has_bits_[0] & 0x00000008u) != 0) {
    if (this_._internal_dest() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
          4, this_._internal_dest(), target);
    }
  }

  // fixed32 source = 5;
  if ((this_._impl_._has_bits_[0] & 0x00000010u) != 0) {
    if (this_._internal_source() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
          5, this_._internal_source(), target);
    }
  }

  // fixed32 request_id = 6;
  if ((this_._impl_._has_bits_[0] & 0x00000020u) != 0) {
    if (this_._internal_request_id() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
          6, this_._internal_request_id(), target);
    }
  }

  // fixed32 reply_id = 7;
  if ((this_._impl_._has_bits_[0] & 0x00000040u) != 0) {
    if (this_._internal_reply_id() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
          7, this_._internal_reply_id(), target);
    }
  }

  // fixed32 emoji = 8;
  if ((this_._impl_._has_bits_[0] & 0x00000080u) != 0) {
    if (this_._internal_emoji() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
          8, this_._internal_emoji(), target);
    }
  }

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional uint32 bitfield = 9;
  if ((cached_has_bits & 0x00000100u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        9, this_._internal_bitfield(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.Data)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t Data::ByteSizeLong(const MessageLite& base) {
  const Data& this_ = static_cast<const Data&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t Data::ByteSizeLong() const {
  const Data& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:meshtastic.Data)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x000000ffu) != 0) {
    // bytes payload = 2;
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (!this_._internal_payload().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                        this_._internal_payload());
      }
    }
    // .meshtastic.PortNum portnum = 1;
    if ((cached_has_bits & 0x00000002u) != 0) {
      if (this_._internal_portnum() != 0) {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this_._internal_portnum());
      }
    }
    // bool want_response = 3;
    if ((cached_has_bits & 0x00000004u) != 0) {
      if (this_._internal_want_response() != 0) {
        total_size += 2;
      }
    }
    // fixed32 dest = 4;
    if ((cached_has_bits & 0x00000008u) != 0) {
      if (this_._internal_dest() != 0) {
        total_size += 5;
      }
    }
    // fixed32 source = 5;
    if ((cached_has_bits & 0x00000010u) != 0) {
      if (this_._internal_source() != 0) {
        total_size += 5;
      }
    }
    // fixed32 request_id = 6;
    if ((cached_has_bits & 0x00000020u) != 0) {
      if (this_._internal_request_id() != 0) {
        total_size += 5;
      }
    }
    // fixed32 reply_id = 7;
    if ((cached_has_bits & 0x00000040u) != 0) {
      if (this_._internal_reply_id() != 0) {
        total_size += 5;
      }
    }
    // fixed32 emoji = 8;
    if ((cached_has_bits & 0x00000080u) != 0) {
      if (this_._internal_emoji() != 0) {
        total_size += 5;
      }
    }
  }
   {
    // optional uint32 bitfield = 9;
    if ((cached_has_bits & 0x00000100u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_bitfield());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void Data::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Data*>(&to_msg);
  auto& from = static_cast<const Data&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.Data)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x000000ffu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (!from._internal_payload().empty()) {
        _this->_internal_set_payload(from._internal_payload());
      } else {
        if (_this->_impl_.payload_.IsDefault()) {
          _this->_internal_set_payload("");
        }
      }
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      if (from._internal_portnum() != 0) {
        _this->_impl_.portnum_ = from._impl_.portnum_;
      }
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      if (from._internal_want_response() != 0) {
        _this->_impl_.want_response_ = from._impl_.want_response_;
      }
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      if (from._internal_dest() != 0) {
        _this->_impl_.dest_ = from._impl_.dest_;
      }
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      if (from._internal_source() != 0) {
        _this->_impl_.source_ = from._impl_.source_;
      }
    }
    if ((cached_has_bits & 0x00000020u) != 0) {
      if (from._internal_request_id() != 0) {
        _this->_impl_.request_id_ = from._impl_.request_id_;
      }
    }
    if ((cached_has_bits & 0x00000040u) != 0) {
      if (from._internal_reply_id() != 0) {
        _this->_impl_.reply_id_ = from._impl_.reply_id_;
      }
    }
    if ((cached_has_bits & 0x00000080u) != 0) {
      if (from._internal_emoji() != 0) {
        _this->_impl_.emoji_ = from._impl_.emoji_;
      }
    }
  }
  if ((cached_has_bits & 0x00000100u) != 0) {
    _this->_impl_.bitfield_ = from._impl_.bitfield_;
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Data::CopyFrom(const Data& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.Data)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Data::InternalSwap(Data* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.payload_, &other->_impl_.payload_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Data, _impl_.bitfield_)
      + sizeof(Data::_impl_.bitfield_)
      - PROTOBUF_FIELD_OFFSET(Data, _impl_.portnum_)>(
          reinterpret_cast<char*>(&_impl_.portnum_),
          reinterpret_cast<char*>(&other->_impl_.portnum_));
}

::google::protobuf::Metadata Data::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class KeyVerification::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<KeyVerification>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(KeyVerification, _impl_._has_bits_);
};

KeyVerification::KeyVerification(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, KeyVerification_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:meshtastic.KeyVerification)
}
PROTOBUF_NDEBUG_INLINE KeyVerification::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::meshtastic::KeyVerification& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        hash1_(arena, from.hash1_),
        hash2_(arena, from.hash2_) {}

KeyVerification::KeyVerification(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const KeyVerification& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, KeyVerification_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  KeyVerification* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.nonce_ = from._impl_.nonce_;

  // @@protoc_insertion_point(copy_constructor:meshtastic.KeyVerification)
}
PROTOBUF_NDEBUG_INLINE KeyVerification::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        hash1_(arena),
        hash2_(arena) {}

inline void KeyVerification::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.nonce_ = {};
}
KeyVerification::~KeyVerification() {
  // @@protoc_insertion_point(destructor:meshtastic.KeyVerification)
  SharedDtor(*this);
}
inline void KeyVerification::SharedDtor(MessageLite& self) {
  KeyVerification& this_ = static_cast<KeyVerification&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.hash1_.Destroy();
  this_._impl_.hash2_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL KeyVerification::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) KeyVerification(arena);
}
constexpr auto KeyVerification::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(KeyVerification),
                                            alignof(KeyVerification));
}
constexpr auto KeyVerification::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_KeyVerification_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &KeyVerification::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<KeyVerification>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &KeyVerification::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<KeyVerification>(), &KeyVerification::ByteSizeLong,
              &KeyVerification::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(KeyVerification, _impl_._cached_size_),
          false,
      },
      &KeyVerification::kDescriptorMethods,
      &descriptor_table_meshtastic_2fmesh_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull KeyVerification_class_data_ =
        KeyVerification::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
KeyVerification::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&KeyVerification_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(KeyVerification_class_data_.tc_table);
  return KeyVerification_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 0, 2>
KeyVerification::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(KeyVerification, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    KeyVerification_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::meshtastic::KeyVerification>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // uint64 nonce = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(KeyVerification, _impl_.nonce_), 2>(),
     {8, 2, 0, PROTOBUF_FIELD_OFFSET(KeyVerification, _impl_.nonce_)}},
    // bytes hash1 = 2;
    {::_pbi::TcParser::FastBS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(KeyVerification, _impl_.hash1_)}},
    // bytes hash2 = 3;
    {::_pbi::TcParser::FastBS1,
     {26, 1, 0, PROTOBUF_FIELD_OFFSET(KeyVerification, _impl_.hash2_)}},
  }}, {{
    65535, 65535
  }}, {{
    // uint64 nonce = 1;
    {PROTOBUF_FIELD_OFFSET(KeyVerification, _impl_.nonce_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // bytes hash1 = 2;
    {PROTOBUF_FIELD_OFFSET(KeyVerification, _impl_.hash1_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // bytes hash2 = 3;
    {PROTOBUF_FIELD_OFFSET(KeyVerification, _impl_.hash2_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void KeyVerification::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.KeyVerification)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _impl_.hash1_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _impl_.hash2_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.nonce_ = ::uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL KeyVerification::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const KeyVerification& this_ = static_cast<const KeyVerification&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL KeyVerification::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const KeyVerification& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.KeyVerification)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // uint64 nonce = 1;
  if ((this_._impl_._has_bits_[0] & 0x00000004u) != 0) {
    if (this_._internal_nonce() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
          1, this_._internal_nonce(), target);
    }
  }

  // bytes hash1 = 2;
  if ((this_._impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (!this_._internal_hash1().empty()) {
      const ::std::string& _s = this_._internal_hash1();
      target = stream->WriteBytesMaybeAliased(2, _s, target);
    }
  }

  // bytes hash2 = 3;
  if ((this_._impl_._has_bits_[0] & 0x00000002u) != 0) {
    if (!this_._internal_hash2().empty()) {
      const ::std::string& _s = this_._internal_hash2();
      target = stream->WriteBytesMaybeAliased(3, _s, target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.KeyVerification)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t KeyVerification::ByteSizeLong(const MessageLite& base) {
  const KeyVerification& this_ = static_cast<const KeyVerification&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t KeyVerification::ByteSizeLong() const {
  const KeyVerification& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:meshtastic.KeyVerification)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    // bytes hash1 = 2;
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (!this_._internal_hash1().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                        this_._internal_hash1());
      }
    }
    // bytes hash2 = 3;
    if ((cached_has_bits & 0x00000002u) != 0) {
      if (!this_._internal_hash2().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                        this_._internal_hash2());
      }
    }
    // uint64 nonce = 1;
    if ((cached_has_bits & 0x00000004u) != 0) {
      if (this_._internal_nonce() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
            this_._internal_nonce());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void KeyVerification::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<KeyVerification*>(&to_msg);
  auto& from = static_cast<const KeyVerification&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.KeyVerification)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (!from._internal_hash1().empty()) {
        _this->_internal_set_hash1(from._internal_hash1());
      } else {
        if (_this->_impl_.hash1_.IsDefault()) {
          _this->_internal_set_hash1("");
        }
      }
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      if (!from._internal_hash2().empty()) {
        _this->_internal_set_hash2(from._internal_hash2());
      } else {
        if (_this->_impl_.hash2_.IsDefault()) {
          _this->_internal_set_hash2("");
        }
      }
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      if (from._internal_nonce() != 0) {
        _this->_impl_.nonce_ = from._impl_.nonce_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void KeyVerification::CopyFrom(const KeyVerification& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.KeyVerification)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void KeyVerification::InternalSwap(KeyVerification* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.hash1_, &other->_impl_.hash1_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.hash2_, &other->_impl_.hash2_, arena);
  swap(_impl_.nonce_, other->_impl_.nonce_);
}

::google::protobuf::Metadata KeyVerification::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class Waypoint::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<Waypoint>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(Waypoint, _impl_._has_bits_);
};

Waypoint::Waypoint(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, Waypoint_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:meshtastic.Waypoint)
}
PROTOBUF_NDEBUG_INLINE Waypoint::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::meshtastic::Waypoint& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        name_(arena, from.name_),
        description_(arena, from.description_) {}

Waypoint::Waypoint(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const Waypoint& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, Waypoint_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  Waypoint* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, id_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, id_),
           offsetof(Impl_, icon_) -
               offsetof(Impl_, id_) +
               sizeof(Impl_::icon_));

  // @@protoc_insertion_point(copy_constructor:meshtastic.Waypoint)
}
PROTOBUF_NDEBUG_INLINE Waypoint::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        name_(arena),
        description_(arena) {}

inline void Waypoint::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, id_),
           0,
           offsetof(Impl_, icon_) -
               offsetof(Impl_, id_) +
               sizeof(Impl_::icon_));
}
Waypoint::~Waypoint() {
  // @@protoc_insertion_point(destructor:meshtastic.Waypoint)
  SharedDtor(*this);
}
inline void Waypoint::SharedDtor(MessageLite& self) {
  Waypoint& this_ = static_cast<Waypoint&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.name_.Destroy();
  this_._impl_.description_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL Waypoint::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) Waypoint(arena);
}
constexpr auto Waypoint::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(Waypoint),
                                            alignof(Waypoint));
}
constexpr auto Waypoint::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_Waypoint_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &Waypoint::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<Waypoint>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &Waypoint::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<Waypoint>(), &Waypoint::ByteSizeLong,
              &Waypoint::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(Waypoint, _impl_._cached_size_),
          false,
      },
      &Waypoint::kDescriptorMethods,
      &descriptor_table_meshtastic_2fmesh_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull Waypoint_class_data_ =
        Waypoint::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
Waypoint::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&Waypoint_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(Waypoint_class_data_.tc_table);
  return Waypoint_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 8, 0, 51, 2>
Waypoint::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Waypoint, _impl_._has_bits_),
    0, // no _extensions_
    8, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967040,  // skipmap
    offsetof(decltype(_table_), field_entries),
    8,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    Waypoint_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::meshtastic::Waypoint>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // fixed32 icon = 8;
    {::_pbi::TcParser::FastF32S1,
     {69, 7, 0, PROTOBUF_FIELD_OFFSET(Waypoint, _impl_.icon_)}},
    // uint32 id = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Waypoint, _impl_.id_), 2>(),
     {8, 2, 0, PROTOBUF_FIELD_OFFSET(Waypoint, _impl_.id_)}},
    // optional sfixed32 latitude_i = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 3, 0, PROTOBUF_FIELD_OFFSET(Waypoint, _impl_.latitude_i_)}},
    // optional sfixed32 longitude_i = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 4, 0, PROTOBUF_FIELD_OFFSET(Waypoint, _impl_.longitude_i_)}},
    // uint32 expire = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Waypoint, _impl_.expire_), 5>(),
     {32, 5, 0, PROTOBUF_FIELD_OFFSET(Waypoint, _impl_.expire_)}},
    // uint32 locked_to = 5;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Waypoint, _impl_.locked_to_), 6>(),
     {40, 6, 0, PROTOBUF_FIELD_OFFSET(Waypoint, _impl_.locked_to_)}},
    // string name = 6;
    {::_pbi::TcParser::FastUS1,
     {50, 0, 0, PROTOBUF_FIELD_OFFSET(Waypoint, _impl_.name_)}},
    // string description = 7;
    {::_pbi::TcParser::FastUS1,
     {58, 1, 0, PROTOBUF_FIELD_OFFSET(Waypoint, _impl_.description_)}},
  }}, {{
    65535, 65535
  }}, {{
    // uint32 id = 1;
    {PROTOBUF_FIELD_OFFSET(Waypoint, _impl_.id_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional sfixed32 latitude_i = 2;
    {PROTOBUF_FIELD_OFFSET(Waypoint, _impl_.latitude_i_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kSFixed32)},
    // optional sfixed32 longitude_i = 3;
    {PROTOBUF_FIELD_OFFSET(Waypoint, _impl_.longitude_i_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kSFixed32)},
    // uint32 expire = 4;
    {PROTOBUF_FIELD_OFFSET(Waypoint, _impl_.expire_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // uint32 locked_to = 5;
    {PROTOBUF_FIELD_OFFSET(Waypoint, _impl_.locked_to_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // string name = 6;
    {PROTOBUF_FIELD_OFFSET(Waypoint, _impl_.name_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string description = 7;
    {PROTOBUF_FIELD_OFFSET(Waypoint, _impl_.description_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // fixed32 icon = 8;
    {PROTOBUF_FIELD_OFFSET(Waypoint, _impl_.icon_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFixed32)},
  }},
  // no aux_entries
  {{
    "\23\0\0\0\0\0\4\13\0\0\0\0\0\0\0\0"
    "meshtastic.Waypoint"
    "name"
    "description"
  }},
};
PROTOBUF_NOINLINE void Waypoint::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.Waypoint)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _impl_.description_.ClearNonDefaultToEmpty();
    }
  }
  if ((cached_has_bits & 0x000000fcu) != 0) {
    ::memset(&_impl_.id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.icon_) -
        reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.icon_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL Waypoint::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const Waypoint& this_ = static_cast<const Waypoint&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL Waypoint::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const Waypoint& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.Waypoint)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // uint32 id = 1;
  if ((this_._impl_._has_bits_[0] & 0x00000004u) != 0) {
    if (this_._internal_id() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          1, this_._internal_id(), target);
    }
  }

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional sfixed32 latitude_i = 2;
  if ((cached_has_bits & 0x00000008u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSFixed32ToArray(
        2, this_._internal_latitude_i(), target);
  }

  // optional sfixed32 longitude_i = 3;
  if ((cached_has_bits & 0x00000010u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSFixed32ToArray(
        3, this_._internal_longitude_i(), target);
  }

  // uint32 expire = 4;
  if ((cached_has_bits & 0x00000020u) != 0) {
    if (this_._internal_expire() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          4, this_._internal_expire(), target);
    }
  }

  // uint32 locked_to = 5;
  if ((cached_has_bits & 0x00000040u) != 0) {
    if (this_._internal_locked_to() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          5, this_._internal_locked_to(), target);
    }
  }

  // string name = 6;
  if ((cached_has_bits & 0x00000001u) != 0) {
    if (!this_._internal_name().empty()) {
      const ::std::string& _s = this_._internal_name();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "meshtastic.Waypoint.name");
      target = stream->WriteStringMaybeAliased(6, _s, target);
    }
  }

  // string description = 7;
  if ((cached_has_bits & 0x00000002u) != 0) {
    if (!this_._internal_description().empty()) {
      const ::std::string& _s = this_._internal_description();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "meshtastic.Waypoint.description");
      target = stream->WriteStringMaybeAliased(7, _s, target);
    }
  }

  // fixed32 icon = 8;
  if ((cached_has_bits & 0x00000080u) != 0) {
    if (this_._internal_icon() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
          8, this_._internal_icon(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.Waypoint)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t Waypoint::ByteSizeLong(const MessageLite& base) {
  const Waypoint& this_ = static_cast<const Waypoint&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t Waypoint::ByteSizeLong() const {
  const Waypoint& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:meshtastic.Waypoint)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  total_size += ::absl::popcount(0x00000018u & cached_has_bits) * 5;
  if ((cached_has_bits & 0x000000e7u) != 0) {
    // string name = 6;
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (!this_._internal_name().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_name());
      }
    }
    // string description = 7;
    if ((cached_has_bits & 0x00000002u) != 0) {
      if (!this_._internal_description().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_description());
      }
    }
    // uint32 id = 1;
    if ((cached_has_bits & 0x00000004u) != 0) {
      if (this_._internal_id() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
            this_._internal_id());
      }
    }
    // uint32 expire = 4;
    if ((cached_has_bits & 0x00000020u) != 0) {
      if (this_._internal_expire() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
            this_._internal_expire());
      }
    }
    // uint32 locked_to = 5;
    if ((cached_has_bits & 0x00000040u) != 0) {
      if (this_._internal_locked_to() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
            this_._internal_locked_to());
      }
    }
    // fixed32 icon = 8;
    if ((cached_has_bits & 0x00000080u) != 0) {
      if (this_._internal_icon() != 0) {
        total_size += 5;
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void Waypoint::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Waypoint*>(&to_msg);
  auto& from = static_cast<const Waypoint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.Waypoint)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x000000ffu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (!from._internal_name().empty()) {
        _this->_internal_set_name(from._internal_name());
      } else {
        if (_this->_impl_.name_.IsDefault()) {
          _this->_internal_set_name("");
        }
      }
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      if (!from._internal_description().empty()) {
        _this->_internal_set_description(from._internal_description());
      } else {
        if (_this->_impl_.description_.IsDefault()) {
          _this->_internal_set_description("");
        }
      }
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      if (from._internal_id() != 0) {
        _this->_impl_.id_ = from._impl_.id_;
      }
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      _this->_impl_.latitude_i_ = from._impl_.latitude_i_;
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      _this->_impl_.longitude_i_ = from._impl_.longitude_i_;
    }
    if ((cached_has_bits & 0x00000020u) != 0) {
      if (from._internal_expire() != 0) {
        _this->_impl_.expire_ = from._impl_.expire_;
      }
    }
    if ((cached_has_bits & 0x00000040u) != 0) {
      if (from._internal_locked_to() != 0) {
        _this->_impl_.locked_to_ = from._impl_.locked_to_;
      }
    }
    if ((cached_has_bits & 0x00000080u) != 0) {
      if (from._internal_icon() != 0) {
        _this->_impl_.icon_ = from._impl_.icon_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Waypoint::CopyFrom(const Waypoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.Waypoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Waypoint::InternalSwap(Waypoint* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, &other->_impl_.name_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.description_, &other->_impl_.description_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Waypoint, _impl_.icon_)
      + sizeof(Waypoint::_impl_.icon_)
      - PROTOBUF_FIELD_OFFSET(Waypoint, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::google::protobuf::Metadata Waypoint::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class MqttClientProxyMessage::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<MqttClientProxyMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(MqttClientProxyMessage, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::meshtastic::MqttClientProxyMessage, _impl_._oneof_case_);
};

MqttClientProxyMessage::MqttClientProxyMessage(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, MqttClientProxyMessage_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:meshtastic.MqttClientProxyMessage)
}
PROTOBUF_NDEBUG_INLINE MqttClientProxyMessage::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::meshtastic::MqttClientProxyMessage& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        topic_(arena, from.topic_),
        payload_variant_{},
        _oneof_case_{from._oneof_case_[0]} {}

MqttClientProxyMessage::MqttClientProxyMessage(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const MqttClientProxyMessage& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, MqttClientProxyMessage_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  MqttClientProxyMessage* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.retained_ = from._impl_.retained_;
  switch (payload_variant_case()) {
    case PAYLOAD_VARIANT_NOT_SET:
      break;
      case kData:
        new (&_impl_.payload_variant_.data_) decltype(_impl_.payload_variant_.data_){arena, from._impl_.payload_variant_.data_};
        break;
      case kText:
        new (&_impl_.payload_variant_.text_) decltype(_impl_.payload_variant_.text_){arena, from._impl_.payload_variant_.text_};
        break;
  }

  // @@protoc_insertion_point(copy_constructor:meshtastic.MqttClientProxyMessage)
}
PROTOBUF_NDEBUG_INLINE MqttClientProxyMessage::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        topic_(arena),
        payload_variant_{},
        _oneof_case_{} {}

inline void MqttClientProxyMessage::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.retained_ = {};
}
MqttClientProxyMessage::~MqttClientProxyMessage() {
  // @@protoc_insertion_point(destructor:meshtastic.MqttClientProxyMessage)
  SharedDtor(*this);
}
inline void MqttClientProxyMessage::SharedDtor(MessageLite& self) {
  MqttClientProxyMessage& this_ = static_cast<MqttClientProxyMessage&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.topic_.Destroy();
  if (this_.has_payload_variant()) {
    this_.clear_payload_variant();
  }
  this_._impl_.~Impl_();
}

void MqttClientProxyMessage::clear_payload_variant() {
// @@protoc_insertion_point(one_of_clear_start:meshtastic.MqttClientProxyMessage)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (payload_variant_case()) {
    case kData: {
      _impl_.payload_variant_.data_.Destroy();
      break;
    }
    case kText: {
      _impl_.payload_variant_.text_.Destroy();
      break;
    }
    case PAYLOAD_VARIANT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = PAYLOAD_VARIANT_NOT_SET;
}


inline void* PROTOBUF_NONNULL MqttClientProxyMessage::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) MqttClientProxyMessage(arena);
}
constexpr auto MqttClientProxyMessage::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(MqttClientProxyMessage),
                                            alignof(MqttClientProxyMessage));
}
constexpr auto MqttClientProxyMessage::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_MqttClientProxyMessage_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &MqttClientProxyMessage::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<MqttClientProxyMessage>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &MqttClientProxyMessage::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<MqttClientProxyMessage>(), &MqttClientProxyMessage::ByteSizeLong,
              &MqttClientProxyMessage::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(MqttClientProxyMessage, _impl_._cached_size_),
          false,
      },
      &MqttClientProxyMessage::kDescriptorMethods,
      &descriptor_table_meshtastic_2fmesh_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull MqttClientProxyMessage_class_data_ =
        MqttClientProxyMessage::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
MqttClientProxyMessage::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&MqttClientProxyMessage_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(MqttClientProxyMessage_class_data_.tc_table);
  return MqttClientProxyMessage_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 4, 0, 51, 2>
MqttClientProxyMessage::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(MqttClientProxyMessage, _impl_._has_bits_),
    0, // no _extensions_
    4, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    MqttClientProxyMessage_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::meshtastic::MqttClientProxyMessage>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // bool retained = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(MqttClientProxyMessage, _impl_.retained_), 1>(),
     {32, 1, 0, PROTOBUF_FIELD_OFFSET(MqttClientProxyMessage, _impl_.retained_)}},
    // string topic = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(MqttClientProxyMessage, _impl_.topic_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string topic = 1;
    {PROTOBUF_FIELD_OFFSET(MqttClientProxyMessage, _impl_.topic_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // bytes data = 2;
    {PROTOBUF_FIELD_OFFSET(MqttClientProxyMessage, _impl_.payload_variant_.data_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBytes | ::_fl::kRepAString)},
    // string text = 3;
    {PROTOBUF_FIELD_OFFSET(MqttClientProxyMessage, _impl_.payload_variant_.text_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // bool retained = 4;
    {PROTOBUF_FIELD_OFFSET(MqttClientProxyMessage, _impl_.retained_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
    "\41\5\0\4\0\0\0\0"
    "meshtastic.MqttClientProxyMessage"
    "topic"
    "text"
  }},
};
PROTOBUF_NOINLINE void MqttClientProxyMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.MqttClientProxyMessage)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    _impl_.topic_.ClearNonDefaultToEmpty();
  }
  _impl_.retained_ = false;
  clear_payload_variant();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL MqttClientProxyMessage::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const MqttClientProxyMessage& this_ = static_cast<const MqttClientProxyMessage&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL MqttClientProxyMessage::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const MqttClientProxyMessage& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.MqttClientProxyMessage)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // string topic = 1;
  if ((this_._impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (!this_._internal_topic().empty()) {
      const ::std::string& _s = this_._internal_topic();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "meshtastic.MqttClientProxyMessage.topic");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  switch (this_.payload_variant_case()) {
    case kData: {
      const ::std::string& _s = this_._internal_data();
      target = stream->WriteBytesMaybeAliased(2, _s, target);
      break;
    }
    case kText: {
      const ::std::string& _s = this_._internal_text();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "meshtastic.MqttClientProxyMessage.text");
      target = stream->WriteStringMaybeAliased(3, _s, target);
      break;
    }
    default:
      break;
  }
  // bool retained = 4;
  if ((this_._impl_._has_bits_[0] & 0x00000002u) != 0) {
    if (this_._internal_retained() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          4, this_._internal_retained(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.MqttClientProxyMessage)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t MqttClientProxyMessage::ByteSizeLong(const MessageLite& base) {
  const MqttClientProxyMessage& this_ = static_cast<const MqttClientProxyMessage&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t MqttClientProxyMessage::ByteSizeLong() const {
  const MqttClientProxyMessage& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:meshtastic.MqttClientProxyMessage)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    // string topic = 1;
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (!this_._internal_topic().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_topic());
      }
    }
    // bool retained = 4;
    if ((cached_has_bits & 0x00000002u) != 0) {
      if (this_._internal_retained() != 0) {
        total_size += 2;
      }
    }
  }
  switch (this_.payload_variant_case()) {
    // bytes data = 2;
    case kData: {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_data());
      break;
    }
    // string text = 3;
    case kText: {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_text());
      break;
    }
    case PAYLOAD_VARIANT_NOT_SET: {
      break;
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void MqttClientProxyMessage::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<MqttClientProxyMessage*>(&to_msg);
  auto& from = static_cast<const MqttClientProxyMessage&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.MqttClientProxyMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (!from._internal_topic().empty()) {
        _this->_internal_set_topic(from._internal_topic());
      } else {
        if (_this->_impl_.topic_.IsDefault()) {
          _this->_internal_set_topic("");
        }
      }
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      if (from._internal_retained() != 0) {
        _this->_impl_.retained_ = from._impl_.retained_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_payload_variant();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kData: {
        if (oneof_needs_init) {
          _this->_impl_.payload_variant_.data_.InitDefault();
        }
        _this->_impl_.payload_variant_.data_.Set(from._internal_data(), arena);
        break;
      }
      case kText: {
        if (oneof_needs_init) {
          _this->_impl_.payload_variant_.text_.InitDefault();
        }
        _this->_impl_.payload_variant_.text_.Set(from._internal_text(), arena);
        break;
      }
      case PAYLOAD_VARIANT_NOT_SET:
        break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void MqttClientProxyMessage::CopyFrom(const MqttClientProxyMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.MqttClientProxyMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void MqttClientProxyMessage::InternalSwap(MqttClientProxyMessage* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.topic_, &other->_impl_.topic_, arena);
  swap(_impl_.retained_, other->_impl_.retained_);
  swap(_impl_.payload_variant_, other->_impl_.payload_variant_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::google::protobuf::Metadata MqttClientProxyMessage::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class MeshPacket::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<MeshPacket>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(MeshPacket, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::meshtastic::MeshPacket, _impl_._oneof_case_);
};

void MeshPacket::set_allocated_decoded(::meshtastic::Data* PROTOBUF_NULLABLE decoded) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_payload_variant();
  if (decoded) {
    ::google::protobuf::Arena* submessage_arena = decoded->GetArena();
    if (message_arena != submessage_arena) {
      decoded = ::google::protobuf::internal::GetOwnedMessage(message_arena, decoded, submessage_arena);
    }
    set_has_decoded();
    _impl_.payload_variant_.decoded_ = decoded;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.MeshPacket.decoded)
}
MeshPacket::MeshPacket(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, MeshPacket_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:meshtastic.MeshPacket)
}
PROTOBUF_NDEBUG_INLINE MeshPacket::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::meshtastic::MeshPacket& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        public_key_(arena, from.public_key_),
        payload_variant_{},
        _oneof_case_{from._oneof_case_[0]} {}

MeshPacket::MeshPacket(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const MeshPacket& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, MeshPacket_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  MeshPacket* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, from_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, from_),
           offsetof(Impl_, transport_mechanism_) -
               offsetof(Impl_, from_) +
               sizeof(Impl_::transport_mechanism_));
  switch (payload_variant_case()) {
    case PAYLOAD_VARIANT_NOT_SET:
      break;
      case kDecoded:
        _impl_.payload_variant_.decoded_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.decoded_);
        break;
      case kEncrypted:
        new (&_impl_.payload_variant_.encrypted_) decltype(_impl_.payload_variant_.encrypted_){arena, from._impl_.payload_variant_.encrypted_};
        break;
  }

  // @@protoc_insertion_point(copy_constructor:meshtastic.MeshPacket)
}
PROTOBUF_NDEBUG_INLINE MeshPacket::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        public_key_(arena),
        payload_variant_{},
        _oneof_case_{} {}

inline void MeshPacket::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, from_),
           0,
           offsetof(Impl_, transport_mechanism_) -
               offsetof(Impl_, from_) +
               sizeof(Impl_::transport_mechanism_));
}
MeshPacket::~MeshPacket() {
  // @@protoc_insertion_point(destructor:meshtastic.MeshPacket)
  SharedDtor(*this);
}
inline void MeshPacket::SharedDtor(MessageLite& self) {
  MeshPacket& this_ = static_cast<MeshPacket&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.public_key_.Destroy();
  if (this_.has_payload_variant()) {
    this_.clear_payload_variant();
  }
  this_._impl_.~Impl_();
}

void MeshPacket::clear_payload_variant() {
// @@protoc_insertion_point(one_of_clear_start:meshtastic.MeshPacket)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (payload_variant_case()) {
    case kDecoded: {
      if (GetArena() == nullptr) {
        delete _impl_.payload_variant_.decoded_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.decoded_);
      }
      break;
    }
    case kEncrypted: {
      _impl_.payload_variant_.encrypted_.Destroy();
      break;
    }
    case PAYLOAD_VARIANT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = PAYLOAD_VARIANT_NOT_SET;
}


inline void* PROTOBUF_NONNULL MeshPacket::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) MeshPacket(arena);
}
constexpr auto MeshPacket::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(MeshPacket),
                                            alignof(MeshPacket));
}
constexpr auto MeshPacket::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_MeshPacket_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &MeshPacket::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<MeshPacket>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &MeshPacket::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<MeshPacket>(), &MeshPacket::ByteSizeLong,
              &MeshPacket::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(MeshPacket, _impl_._cached_size_),
          false,
      },
      &MeshPacket::kDescriptorMethods,
      &descriptor_table_meshtastic_2fmesh_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull MeshPacket_class_data_ =
        MeshPacket::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
MeshPacket::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&MeshPacket_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(MeshPacket_class_data_.tc_table);
  return MeshPacket_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<5, 21, 1, 0, 2>
MeshPacket::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(MeshPacket, _impl_._has_bits_),
    0, // no _extensions_
    21, 248,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4292870144,  // skipmap
    offsetof(decltype(_table_), field_entries),
    21,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    MeshPacket_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::meshtastic::MeshPacket>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // fixed32 from = 1;
    {::_pbi::TcParser::FastF32S1,
     {13, 1, 0, PROTOBUF_FIELD_OFFSET(MeshPacket, _impl_.from_)}},
    // fixed32 to = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 2, 0, PROTOBUF_FIELD_OFFSET(MeshPacket, _impl_.to_)}},
    // uint32 channel = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(MeshPacket, _impl_.channel_), 3>(),
     {24, 3, 0, PROTOBUF_FIELD_OFFSET(MeshPacket, _impl_.channel_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // fixed32 id = 6;
    {::_pbi::TcParser::FastF32S1,
     {53, 4, 0, PROTOBUF_FIELD_OFFSET(MeshPacket, _impl_.id_)}},
    // fixed32 rx_time = 7;
    {::_pbi::TcParser::FastF32S1,
     {61, 5, 0, PROTOBUF_FIELD_OFFSET(MeshPacket, _impl_.rx_time_)}},
    // float rx_snr = 8;
    {::_pbi::TcParser::FastF32S1,
     {69, 6, 0, PROTOBUF_FIELD_OFFSET(MeshPacket, _impl_.rx_snr_)}},
    // uint32 hop_limit = 9;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(MeshPacket, _impl_.hop_limit_), 7>(),
     {72, 7, 0, PROTOBUF_FIELD_OFFSET(MeshPacket, _impl_.hop_limit_)}},
    // bool want_ack = 10;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(MeshPacket, _impl_.want_ack_), 11>(),
     {80, 11, 0, PROTOBUF_FIELD_OFFSET(MeshPacket, _impl_.want_ack_)}},
    // .meshtastic.MeshPacket.Priority priority = 11;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(MeshPacket, _impl_.priority_), 8>(),
     {88, 8, 0, PROTOBUF_FIELD_OFFSET(MeshPacket, _impl_.priority_)}},
    // int32 rx_rssi = 12;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(MeshPacket, _impl_.rx_rssi_), 9>(),
     {96, 9, 0, PROTOBUF_FIELD_OFFSET(MeshPacket, _impl_.rx_rssi_)}},
    // .meshtastic.MeshPacket.Delayed delayed = 13 [deprecated = true];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(MeshPacket, _impl_.delayed_), 10>(),
     {104, 10, 0, PROTOBUF_FIELD_OFFSET(MeshPacket, _impl_.delayed_)}},
    // bool via_mqtt = 14;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(MeshPacket, _impl_.via_mqtt_), 12>(),
     {112, 12, 0, PROTOBUF_FIELD_OFFSET(MeshPacket, _impl_.via_mqtt_)}},
    // uint32 hop_start = 15;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(MeshPacket, _impl_.hop_start_), 14>(),
     {120, 14, 0, PROTOBUF_FIELD_OFFSET(MeshPacket, _impl_.hop_start_)}},
    // bytes public_key = 16;
    {::_pbi::TcParser::FastBS2,
     {386, 0, 0, PROTOBUF_FIELD_OFFSET(MeshPacket, _impl_.public_key_)}},
    // bool pki_encrypted = 17;
    {::_pbi::TcParser::FastV8S2,
     {392, 13, 0, PROTOBUF_FIELD_OFFSET(MeshPacket, _impl_.pki_encrypted_)}},
    // uint32 next_hop = 18;
    {::_pbi::TcParser::FastV32S2,
     {400, 15, 0, PROTOBUF_FIELD_OFFSET(MeshPacket, _impl_.next_hop_)}},
    // uint32 relay_node = 19;
    {::_pbi::TcParser::FastV32S2,
     {408, 16, 0, PROTOBUF_FIELD_OFFSET(MeshPacket, _impl_.relay_node_)}},
    // uint32 tx_after = 20;
    {::_pbi::TcParser::FastV32S2,
     {416, 17, 0, PROTOBUF_FIELD_OFFSET(MeshPacket, _impl_.tx_after_)}},
    // .meshtastic.MeshPacket.TransportMechanism transport_mechanism = 21;
    {::_pbi::TcParser::FastV32S2,
     {424, 18, 0, PROTOBUF_FIELD_OFFSET(MeshPacket, _impl_.transport_mechanism_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // fixed32 from = 1;
    {PROTOBUF_FIELD_OFFSET(MeshPacket, _impl_.from_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFixed32)},
    // fixed32 to = 2;
    {PROTOBUF_FIELD_OFFSET(MeshPacket, _impl_.to_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFixed32)},
    // uint32 channel = 3;
    {PROTOBUF_FIELD_OFFSET(MeshPacket, _impl_.channel_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // .meshtastic.Data decoded = 4;
    {PROTOBUF_FIELD_OFFSET(MeshPacket, _impl_.payload_variant_.decoded_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // bytes encrypted = 5;
    {PROTOBUF_FIELD_OFFSET(MeshPacket, _impl_.payload_variant_.encrypted_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBytes | ::_fl::kRepAString)},
    // fixed32 id = 6;
    {PROTOBUF_FIELD_OFFSET(MeshPacket, _impl_.id_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFixed32)},
    // fixed32 rx_time = 7;
    {PROTOBUF_FIELD_OFFSET(MeshPacket, _impl_.rx_time_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFixed32)},
    // float rx_snr = 8;
    {PROTOBUF_FIELD_OFFSET(MeshPacket, _impl_.rx_snr_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // uint32 hop_limit = 9;
    {PROTOBUF_FIELD_OFFSET(MeshPacket, _impl_.hop_limit_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // bool want_ack = 10;
    {PROTOBUF_FIELD_OFFSET(MeshPacket, _impl_.want_ack_), _Internal::kHasBitsOffset + 11, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // .meshtastic.MeshPacket.Priority priority = 11;
    {PROTOBUF_FIELD_OFFSET(MeshPacket, _impl_.priority_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kOpenEnum)},
    // int32 rx_rssi = 12;
    {PROTOBUF_FIELD_OFFSET(MeshPacket, _impl_.rx_rssi_), _Internal::kHasBitsOffset + 9, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // .meshtastic.MeshPacket.Delayed delayed = 13 [deprecated = true];
    {PROTOBUF_FIELD_OFFSET(MeshPacket, _impl_.delayed_), _Internal::kHasBitsOffset + 10, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kOpenEnum)},
    // bool via_mqtt = 14;
    {PROTOBUF_FIELD_OFFSET(MeshPacket, _impl_.via_mqtt_), _Internal::kHasBitsOffset + 12, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // uint32 hop_start = 15;
    {PROTOBUF_FIELD_OFFSET(MeshPacket, _impl_.hop_start_), _Internal::kHasBitsOffset + 14, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // bytes public_key = 16;
    {PROTOBUF_FIELD_OFFSET(MeshPacket, _impl_.public_key_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // bool pki_encrypted = 17;
    {PROTOBUF_FIELD_OFFSET(MeshPacket, _impl_.pki_encrypted_), _Internal::kHasBitsOffset + 13, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // uint32 next_hop = 18;
    {PROTOBUF_FIELD_OFFSET(MeshPacket, _impl_.next_hop_), _Internal::kHasBitsOffset + 15, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // uint32 relay_node = 19;
    {PROTOBUF_FIELD_OFFSET(MeshPacket, _impl_.relay_node_), _Internal::kHasBitsOffset + 16, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // uint32 tx_after = 20;
    {PROTOBUF_FIELD_OFFSET(MeshPacket, _impl_.tx_after_), _Internal::kHasBitsOffset + 17, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // .meshtastic.MeshPacket.TransportMechanism transport_mechanism = 21;
    {PROTOBUF_FIELD_OFFSET(MeshPacket, _impl_.transport_mechanism_), _Internal::kHasBitsOffset + 18, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kOpenEnum)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::meshtastic::Data>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void MeshPacket::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.MeshPacket)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    _impl_.public_key_.ClearNonDefaultToEmpty();
  }
  if ((cached_has_bits & 0x000000feu) != 0) {
    ::memset(&_impl_.from_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.hop_limit_) -
        reinterpret_cast<char*>(&_impl_.from_)) + sizeof(_impl_.hop_limit_));
  }
  if ((cached_has_bits & 0x0000ff00u) != 0) {
    ::memset(&_impl_.priority_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.next_hop_) -
        reinterpret_cast<char*>(&_impl_.priority_)) + sizeof(_impl_.next_hop_));
  }
  if ((cached_has_bits & 0x00070000u) != 0) {
    ::memset(&_impl_.relay_node_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.transport_mechanism_) -
        reinterpret_cast<char*>(&_impl_.relay_node_)) + sizeof(_impl_.transport_mechanism_));
  }
  clear_payload_variant();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL MeshPacket::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const MeshPacket& this_ = static_cast<const MeshPacket&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL MeshPacket::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const MeshPacket& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.MeshPacket)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // fixed32 from = 1;
  if ((this_._impl_._has_bits_[0] & 0x00000002u) != 0) {
    if (this_._internal_from() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
          1, this_._internal_from(), target);
    }
  }

  // fixed32 to = 2;
  if ((this_._impl_._has_bits_[0] & 0x00000004u) != 0) {
    if (this_._internal_to() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
          2, this_._internal_to(), target);
    }
  }

  // uint32 channel = 3;
  if ((this_._impl_._has_bits_[0] & 0x00000008u) != 0) {
    if (this_._internal_channel() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          3, this_._internal_channel(), target);
    }
  }

  switch (this_.payload_variant_case()) {
    case kDecoded: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          4, *this_._impl_.payload_variant_.decoded_, this_._impl_.payload_variant_.decoded_->GetCachedSize(), target,
          stream);
      break;
    }
    case kEncrypted: {
      const ::std::string& _s = this_._internal_encrypted();
      target = stream->WriteBytesMaybeAliased(5, _s, target);
      break;
    }
    default:
      break;
  }
  // fixed32 id = 6;
  if ((this_._impl_._has_bits_[0] & 0x00000010u) != 0) {
    if (this_._internal_id() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
          6, this_._internal_id(), target);
    }
  }

  // fixed32 rx_time = 7;
  if ((this_._impl_._has_bits_[0] & 0x00000020u) != 0) {
    if (this_._internal_rx_time() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
          7, this_._internal_rx_time(), target);
    }
  }

  // float rx_snr = 8;
  if ((this_._impl_._has_bits_[0] & 0x00000040u) != 0) {
    if (::absl::bit_cast<::uint32_t>(this_._internal_rx_snr()) != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFloatToArray(
          8, this_._internal_rx_snr(), target);
    }
  }

  // uint32 hop_limit = 9;
  if ((this_._impl_._has_bits_[0] & 0x00000080u) != 0) {
    if (this_._internal_hop_limit() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          9, this_._internal_hop_limit(), target);
    }
  }

  // bool want_ack = 10;
  if ((this_._impl_._has_bits_[0] & 0x00000800u) != 0) {
    if (this_._internal_want_ack() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          10, this_._internal_want_ack(), target);
    }
  }

  // .meshtastic.MeshPacket.Priority priority = 11;
  if ((this_._impl_._has_bits_[0] & 0x00000100u) != 0) {
    if (this_._internal_priority() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          11, this_._internal_priority(), target);
    }
  }

  // int32 rx_rssi = 12;
  if ((this_._impl_._has_bits_[0] & 0x00000200u) != 0) {
    if (this_._internal_rx_rssi() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<12>(
              stream, this_._internal_rx_rssi(), target);
    }
  }

  // .meshtastic.MeshPacket.Delayed delayed = 13 [deprecated = true];
  if ((this_._impl_._has_bits_[0] & 0x00000400u) != 0) {
    if (this_._internal_delayed() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          13, this_._internal_delayed(), target);
    }
  }

  // bool via_mqtt = 14;
  if ((this_._impl_._has_bits_[0] & 0x00001000u) != 0) {
    if (this_._internal_via_mqtt() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          14, this_._internal_via_mqtt(), target);
    }
  }

  // uint32 hop_start = 15;
  if ((this_._impl_._has_bits_[0] & 0x00004000u) != 0) {
    if (this_._internal_hop_start() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          15, this_._internal_hop_start(), target);
    }
  }

  // bytes public_key = 16;
  if ((this_._impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (!this_._internal_public_key().empty()) {
      const ::std::string& _s = this_._internal_public_key();
      target = stream->WriteBytesMaybeAliased(16, _s, target);
    }
  }

  // bool pki_encrypted = 17;
  if ((this_._impl_._has_bits_[0] & 0x00002000u) != 0) {
    if (this_._internal_pki_encrypted() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          17, this_._internal_pki_encrypted(), target);
    }
  }

  // uint32 next_hop = 18;
  if ((this_._impl_._has_bits_[0] & 0x00008000u) != 0) {
    if (this_._internal_next_hop() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          18, this_._internal_next_hop(), target);
    }
  }

  // uint32 relay_node = 19;
  if ((this_._impl_._has_bits_[0] & 0x00010000u) != 0) {
    if (this_._internal_relay_node() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          19, this_._internal_relay_node(), target);
    }
  }

  // uint32 tx_after = 20;
  if ((this_._impl_._has_bits_[0] & 0x00020000u) != 0) {
    if (this_._internal_tx_after() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          20, this_._internal_tx_after(), target);
    }
  }

  // .meshtastic.MeshPacket.TransportMechanism transport_mechanism = 21;
  if ((this_._impl_._has_bits_[0] & 0x00040000u) != 0) {
    if (this_._internal_transport_mechanism() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          21, this_._internal_transport_mechanism(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.MeshPacket)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t MeshPacket::ByteSizeLong(const MessageLite& base) {
  const MeshPacket& this_ = static_cast<const MeshPacket&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t MeshPacket::ByteSizeLong() const {
  const MeshPacket& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:meshtastic.MeshPacket)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x000000ffu) != 0) {
    // bytes public_key = 16;
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (!this_._internal_public_key().empty()) {
        total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                        this_._internal_public_key());
      }
    }
    // fixed32 from = 1;
    if ((cached_has_bits & 0x00000002u) != 0) {
      if (this_._internal_from() != 0) {
        total_size += 5;
      }
    }
    // fixed32 to = 2;
    if ((cached_has_bits & 0x00000004u) != 0) {
      if (this_._internal_to() != 0) {
        total_size += 5;
      }
    }
    // uint32 channel = 3;
    if ((cached_has_bits & 0x00000008u) != 0) {
      if (this_._internal_channel() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
            this_._internal_channel());
      }
    }
    // fixed32 id = 6;
    if ((cached_has_bits & 0x00000010u) != 0) {
      if (this_._internal_id() != 0) {
        total_size += 5;
      }
    }
    // fixed32 rx_time = 7;
    if ((cached_has_bits & 0x00000020u) != 0) {
      if (this_._internal_rx_time() != 0) {
        total_size += 5;
      }
    }
    // float rx_snr = 8;
    if ((cached_has_bits & 0x00000040u) != 0) {
      if (::absl::bit_cast<::uint32_t>(this_._internal_rx_snr()) != 0) {
        total_size += 5;
      }
    }
    // uint32 hop_limit = 9;
    if ((cached_has_bits & 0x00000080u) != 0) {
      if (this_._internal_hop_limit() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
            this_._internal_hop_limit());
      }
    }
  }
  if ((cached_has_bits & 0x0000ff00u) != 0) {
    // .meshtastic.MeshPacket.Priority priority = 11;
    if ((cached_has_bits & 0x00000100u) != 0) {
      if (this_._internal_priority() != 0) {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this_._internal_priority());
      }
    }
    // int32 rx_rssi = 12;
    if ((cached_has_bits & 0x00000200u) != 0) {
      if (this_._internal_rx_rssi() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
            this_._internal_rx_rssi());
      }
    }
    // .meshtastic.MeshPacket.Delayed delayed = 13 [deprecated = true];
    if ((cached_has_bits & 0x00000400u) != 0) {
      if (this_._internal_delayed() != 0) {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this_._internal_delayed());
      }
    }
    // bool want_ack = 10;
    if ((cached_has_bits & 0x00000800u) != 0) {
      if (this_._internal_want_ack() != 0) {
        total_size += 2;
      }
    }
    // bool via_mqtt = 14;
    if ((cached_has_bits & 0x00001000u) != 0) {
      if (this_._internal_via_mqtt() != 0) {
        total_size += 2;
      }
    }
    // bool pki_encrypted = 17;
    if ((cached_has_bits & 0x00002000u) != 0) {
      if (this_._internal_pki_encrypted() != 0) {
        total_size += 3;
      }
    }
    // uint32 hop_start = 15;
    if ((cached_has_bits & 0x00004000u) != 0) {
      if (this_._internal_hop_start() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
            this_._internal_hop_start());
      }
    }
    // uint32 next_hop = 18;
    if ((cached_has_bits & 0x00008000u) != 0) {
      if (this_._internal_next_hop() != 0) {
        total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                        this_._internal_next_hop());
      }
    }
  }
  if ((cached_has_bits & 0x00070000u) != 0) {
    // uint32 relay_node = 19;
    if ((cached_has_bits & 0x00010000u) != 0) {
      if (this_._internal_relay_node() != 0) {
        total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                        this_._internal_relay_node());
      }
    }
    // uint32 tx_after = 20;
    if ((cached_has_bits & 0x00020000u) != 0) {
      if (this_._internal_tx_after() != 0) {
        total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                        this_._internal_tx_after());
      }
    }
    // .meshtastic.MeshPacket.TransportMechanism transport_mechanism = 21;
    if ((cached_has_bits & 0x00040000u) != 0) {
      if (this_._internal_transport_mechanism() != 0) {
        total_size += 2 +
                      ::_pbi::WireFormatLite::EnumSize(this_._internal_transport_mechanism());
      }
    }
  }
  switch (this_.payload_variant_case()) {
    // .meshtastic.Data decoded = 4;
    case kDecoded: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.payload_variant_.decoded_);
      break;
    }
    // bytes encrypted = 5;
    case kEncrypted: {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this_._internal_encrypted());
      break;
    }
    case PAYLOAD_VARIANT_NOT_SET: {
      break;
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void MeshPacket::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<MeshPacket*>(&to_msg);
  auto& from = static_cast<const MeshPacket&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.MeshPacket)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x000000ffu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (!from._internal_public_key().empty()) {
        _this->_internal_set_public_key(from._internal_public_key());
      } else {
        if (_this->_impl_.public_key_.IsDefault()) {
          _this->_internal_set_public_key("");
        }
      }
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      if (from._internal_from() != 0) {
        _this->_impl_.from_ = from._impl_.from_;
      }
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      if (from._internal_to() != 0) {
        _this->_impl_.to_ = from._impl_.to_;
      }
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      if (from._internal_channel() != 0) {
        _this->_impl_.channel_ = from._impl_.channel_;
      }
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      if (from._internal_id() != 0) {
        _this->_impl_.id_ = from._impl_.id_;
      }
    }
    if ((cached_has_bits & 0x00000020u) != 0) {
      if (from._internal_rx_time() != 0) {
        _this->_impl_.rx_time_ = from._impl_.rx_time_;
      }
    }
    if ((cached_has_bits & 0x00000040u) != 0) {
      if (::absl::bit_cast<::uint32_t>(from._internal_rx_snr()) != 0) {
        _this->_impl_.rx_snr_ = from._impl_.rx_snr_;
      }
    }
    if ((cached_has_bits & 0x00000080u) != 0) {
      if (from._internal_hop_limit() != 0) {
        _this->_impl_.hop_limit_ = from._impl_.hop_limit_;
      }
    }
  }
  if ((cached_has_bits & 0x0000ff00u) != 0) {
    if ((cached_has_bits & 0x00000100u) != 0) {
      if (from._internal_priority() != 0) {
        _this->_impl_.priority_ = from._impl_.priority_;
      }
    }
    if ((cached_has_bits & 0x00000200u) != 0) {
      if (from._internal_rx_rssi() != 0) {
        _this->_impl_.rx_rssi_ = from._impl_.rx_rssi_;
      }
    }
    if ((cached_has_bits & 0x00000400u) != 0) {
      if (from._internal_delayed() != 0) {
        _this->_impl_.delayed_ = from._impl_.delayed_;
      }
    }
    if ((cached_has_bits & 0x00000800u) != 0) {
      if (from._internal_want_ack() != 0) {
        _this->_impl_.want_ack_ = from._impl_.want_ack_;
      }
    }
    if ((cached_has_bits & 0x00001000u) != 0) {
      if (from._internal_via_mqtt() != 0) {
        _this->_impl_.via_mqtt_ = from._impl_.via_mqtt_;
      }
    }
    if ((cached_has_bits & 0x00002000u) != 0) {
      if (from._internal_pki_encrypted() != 0) {
        _this->_impl_.pki_encrypted_ = from._impl_.pki_encrypted_;
      }
    }
    if ((cached_has_bits & 0x00004000u) != 0) {
      if (from._internal_hop_start() != 0) {
        _this->_impl_.hop_start_ = from._impl_.hop_start_;
      }
    }
    if ((cached_has_bits & 0x00008000u) != 0) {
      if (from._internal_next_hop() != 0) {
        _this->_impl_.next_hop_ = from._impl_.next_hop_;
      }
    }
  }
  if ((cached_has_bits & 0x00070000u) != 0) {
    if ((cached_has_bits & 0x00010000u) != 0) {
      if (from._internal_relay_node() != 0) {
        _this->_impl_.relay_node_ = from._impl_.relay_node_;
      }
    }
    if ((cached_has_bits & 0x00020000u) != 0) {
      if (from._internal_tx_after() != 0) {
        _this->_impl_.tx_after_ = from._impl_.tx_after_;
      }
    }
    if ((cached_has_bits & 0x00040000u) != 0) {
      if (from._internal_transport_mechanism() != 0) {
        _this->_impl_.transport_mechanism_ = from._impl_.transport_mechanism_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_payload_variant();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kDecoded: {
        if (oneof_needs_init) {
          _this->_impl_.payload_variant_.decoded_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.decoded_);
        } else {
          _this->_impl_.payload_variant_.decoded_->MergeFrom(*from._impl_.payload_variant_.decoded_);
        }
        break;
      }
      case kEncrypted: {
        if (oneof_needs_init) {
          _this->_impl_.payload_variant_.encrypted_.InitDefault();
        }
        _this->_impl_.payload_variant_.encrypted_.Set(from._internal_encrypted(), arena);
        break;
      }
      case PAYLOAD_VARIANT_NOT_SET:
        break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void MeshPacket::CopyFrom(const MeshPacket& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.MeshPacket)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void MeshPacket::InternalSwap(MeshPacket* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.public_key_, &other->_impl_.public_key_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MeshPacket, _impl_.transport_mechanism_)
      + sizeof(MeshPacket::_impl_.transport_mechanism_)
      - PROTOBUF_FIELD_OFFSET(MeshPacket, _impl_.from_)>(
          reinterpret_cast<char*>(&_impl_.from_),
          reinterpret_cast<char*>(&other->_impl_.from_));
  swap(_impl_.payload_variant_, other->_impl_.payload_variant_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::google::protobuf::Metadata MeshPacket::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class NodeInfo::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<NodeInfo>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(NodeInfo, _impl_._has_bits_);
};

void NodeInfo::clear_device_metrics() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.device_metrics_ != nullptr) _impl_.device_metrics_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
NodeInfo::NodeInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, NodeInfo_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:meshtastic.NodeInfo)
}
PROTOBUF_NDEBUG_INLINE NodeInfo::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::meshtastic::NodeInfo& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

NodeInfo::NodeInfo(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const NodeInfo& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, NodeInfo_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  NodeInfo* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.user_ = ((cached_has_bits & 0x00000001u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.user_)
                : nullptr;
  _impl_.position_ = ((cached_has_bits & 0x00000002u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.position_)
                : nullptr;
  _impl_.device_metrics_ = ((cached_has_bits & 0x00000004u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.device_metrics_)
                : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, num_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, num_),
           offsetof(Impl_, is_key_manually_verified_) -
               offsetof(Impl_, num_) +
               sizeof(Impl_::is_key_manually_verified_));

  // @@protoc_insertion_point(copy_constructor:meshtastic.NodeInfo)
}
PROTOBUF_NDEBUG_INLINE NodeInfo::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void NodeInfo::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, user_),
           0,
           offsetof(Impl_, is_key_manually_verified_) -
               offsetof(Impl_, user_) +
               sizeof(Impl_::is_key_manually_verified_));
}
NodeInfo::~NodeInfo() {
  // @@protoc_insertion_point(destructor:meshtastic.NodeInfo)
  SharedDtor(*this);
}
inline void NodeInfo::SharedDtor(MessageLite& self) {
  NodeInfo& this_ = static_cast<NodeInfo&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.user_;
  delete this_._impl_.position_;
  delete this_._impl_.device_metrics_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL NodeInfo::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) NodeInfo(arena);
}
constexpr auto NodeInfo::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(NodeInfo),
                                            alignof(NodeInfo));
}
constexpr auto NodeInfo::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_NodeInfo_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &NodeInfo::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<NodeInfo>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &NodeInfo::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<NodeInfo>(), &NodeInfo::ByteSizeLong,
              &NodeInfo::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(NodeInfo, _impl_._cached_size_),
          false,
      },
      &NodeInfo::kDescriptorMethods,
      &descriptor_table_meshtastic_2fmesh_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull NodeInfo_class_data_ =
        NodeInfo::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
NodeInfo::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&NodeInfo_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(NodeInfo_class_data_.tc_table);
  return NodeInfo_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 12, 3, 0, 2>
NodeInfo::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(NodeInfo, _impl_._has_bits_),
    0, // no _extensions_
    12, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294963200,  // skipmap
    offsetof(decltype(_table_), field_entries),
    12,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    NodeInfo_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::meshtastic::NodeInfo>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // uint32 num = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(NodeInfo, _impl_.num_), 3>(),
     {8, 3, 0, PROTOBUF_FIELD_OFFSET(NodeInfo, _impl_.num_)}},
    // .meshtastic.User user = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(NodeInfo, _impl_.user_)}},
    // .meshtastic.Position position = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 1, 1, PROTOBUF_FIELD_OFFSET(NodeInfo, _impl_.position_)}},
    // float snr = 4;
    {::_pbi::TcParser::FastF32S1,
     {37, 4, 0, PROTOBUF_FIELD_OFFSET(NodeInfo, _impl_.snr_)}},
    // fixed32 last_heard = 5;
    {::_pbi::TcParser::FastF32S1,
     {45, 5, 0, PROTOBUF_FIELD_OFFSET(NodeInfo, _impl_.last_heard_)}},
    // .meshtastic.DeviceMetrics device_metrics = 6;
    {::_pbi::TcParser::FastMtS1,
     {50, 2, 2, PROTOBUF_FIELD_OFFSET(NodeInfo, _impl_.device_metrics_)}},
    // uint32 channel = 7;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(NodeInfo, _impl_.channel_), 6>(),
     {56, 6, 0, PROTOBUF_FIELD_OFFSET(NodeInfo, _impl_.channel_)}},
    // bool via_mqtt = 8;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(NodeInfo, _impl_.via_mqtt_), 8>(),
     {64, 8, 0, PROTOBUF_FIELD_OFFSET(NodeInfo, _impl_.via_mqtt_)}},
    // optional uint32 hops_away = 9;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(NodeInfo, _impl_.hops_away_), 7>(),
     {72, 7, 0, PROTOBUF_FIELD_OFFSET(NodeInfo, _impl_.hops_away_)}},
    // bool is_favorite = 10;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(NodeInfo, _impl_.is_favorite_), 9>(),
     {80, 9, 0, PROTOBUF_FIELD_OFFSET(NodeInfo, _impl_.is_favorite_)}},
    // bool is_ignored = 11;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(NodeInfo, _impl_.is_ignored_), 10>(),
     {88, 10, 0, PROTOBUF_FIELD_OFFSET(NodeInfo, _impl_.is_ignored_)}},
    // bool is_key_manually_verified = 12;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(NodeInfo, _impl_.is_key_manually_verified_), 11>(),
     {96, 11, 0, PROTOBUF_FIELD_OFFSET(NodeInfo, _impl_.is_key_manually_verified_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // uint32 num = 1;
    {PROTOBUF_FIELD_OFFSET(NodeInfo, _impl_.num_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // .meshtastic.User user = 2;
    {PROTOBUF_FIELD_OFFSET(NodeInfo, _impl_.user_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .meshtastic.Position position = 3;
    {PROTOBUF_FIELD_OFFSET(NodeInfo, _impl_.position_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // float snr = 4;
    {PROTOBUF_FIELD_OFFSET(NodeInfo, _impl_.snr_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // fixed32 last_heard = 5;
    {PROTOBUF_FIELD_OFFSET(NodeInfo, _impl_.last_heard_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFixed32)},
    // .meshtastic.DeviceMetrics device_metrics = 6;
    {PROTOBUF_FIELD_OFFSET(NodeInfo, _impl_.device_metrics_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // uint32 channel = 7;
    {PROTOBUF_FIELD_OFFSET(NodeInfo, _impl_.channel_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // bool via_mqtt = 8;
    {PROTOBUF_FIELD_OFFSET(NodeInfo, _impl_.via_mqtt_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional uint32 hops_away = 9;
    {PROTOBUF_FIELD_OFFSET(NodeInfo, _impl_.hops_away_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // bool is_favorite = 10;
    {PROTOBUF_FIELD_OFFSET(NodeInfo, _impl_.is_favorite_), _Internal::kHasBitsOffset + 9, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // bool is_ignored = 11;
    {PROTOBUF_FIELD_OFFSET(NodeInfo, _impl_.is_ignored_), _Internal::kHasBitsOffset + 10, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // bool is_key_manually_verified = 12;
    {PROTOBUF_FIELD_OFFSET(NodeInfo, _impl_.is_key_manually_verified_), _Internal::kHasBitsOffset + 11, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::meshtastic::User>()},
      {::_pbi::TcParser::GetTable<::meshtastic::Position>()},
      {::_pbi::TcParser::GetTable<::meshtastic::DeviceMetrics>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void NodeInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.NodeInfo)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(_impl_.user_ != nullptr);
      _impl_.user_->Clear();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(_impl_.position_ != nullptr);
      _impl_.position_->Clear();
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      ABSL_DCHECK(_impl_.device_metrics_ != nullptr);
      _impl_.device_metrics_->Clear();
    }
  }
  if ((cached_has_bits & 0x000000f8u) != 0) {
    ::memset(&_impl_.num_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.hops_away_) -
        reinterpret_cast<char*>(&_impl_.num_)) + sizeof(_impl_.hops_away_));
  }
  if ((cached_has_bits & 0x00000f00u) != 0) {
    ::memset(&_impl_.via_mqtt_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.is_key_manually_verified_) -
        reinterpret_cast<char*>(&_impl_.via_mqtt_)) + sizeof(_impl_.is_key_manually_verified_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL NodeInfo::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const NodeInfo& this_ = static_cast<const NodeInfo&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL NodeInfo::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const NodeInfo& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.NodeInfo)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // uint32 num = 1;
  if ((this_._impl_._has_bits_[0] & 0x00000008u) != 0) {
    if (this_._internal_num() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          1, this_._internal_num(), target);
    }
  }

  cached_has_bits = this_._impl_._has_bits_[0];
  // .meshtastic.User user = 2;
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, *this_._impl_.user_, this_._impl_.user_->GetCachedSize(), target,
        stream);
  }

  // .meshtastic.Position position = 3;
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, *this_._impl_.position_, this_._impl_.position_->GetCachedSize(), target,
        stream);
  }

  // float snr = 4;
  if ((cached_has_bits & 0x00000010u) != 0) {
    if (::absl::bit_cast<::uint32_t>(this_._internal_snr()) != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFloatToArray(
          4, this_._internal_snr(), target);
    }
  }

  // fixed32 last_heard = 5;
  if ((cached_has_bits & 0x00000020u) != 0) {
    if (this_._internal_last_heard() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
          5, this_._internal_last_heard(), target);
    }
  }

  // .meshtastic.DeviceMetrics device_metrics = 6;
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        6, *this_._impl_.device_metrics_, this_._impl_.device_metrics_->GetCachedSize(), target,
        stream);
  }

  // uint32 channel = 7;
  if ((cached_has_bits & 0x00000040u) != 0) {
    if (this_._internal_channel() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          7, this_._internal_channel(), target);
    }
  }

  // bool via_mqtt = 8;
  if ((cached_has_bits & 0x00000100u) != 0) {
    if (this_._internal_via_mqtt() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          8, this_._internal_via_mqtt(), target);
    }
  }

  // optional uint32 hops_away = 9;
  if ((cached_has_bits & 0x00000080u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        9, this_._internal_hops_away(), target);
  }

  // bool is_favorite = 10;
  if ((cached_has_bits & 0x00000200u) != 0) {
    if (this_._internal_is_favorite() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          10, this_._internal_is_favorite(), target);
    }
  }

  // bool is_ignored = 11;
  if ((cached_has_bits & 0x00000400u) != 0) {
    if (this_._internal_is_ignored() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          11, this_._internal_is_ignored(), target);
    }
  }

  // bool is_key_manually_verified = 12;
  if ((cached_has_bits & 0x00000800u) != 0) {
    if (this_._internal_is_key_manually_verified() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          12, this_._internal_is_key_manually_verified(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.NodeInfo)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t NodeInfo::ByteSizeLong(const MessageLite& base) {
  const NodeInfo& this_ = static_cast<const NodeInfo&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t NodeInfo::ByteSizeLong() const {
  const NodeInfo& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:meshtastic.NodeInfo)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x000000ffu) != 0) {
    // .meshtastic.User user = 2;
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.user_);
    }
    // .meshtastic.Position position = 3;
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.position_);
    }
    // .meshtastic.DeviceMetrics device_metrics = 6;
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.device_metrics_);
    }
    // uint32 num = 1;
    if ((cached_has_bits & 0x00000008u) != 0) {
      if (this_._internal_num() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
            this_._internal_num());
      }
    }
    // float snr = 4;
    if ((cached_has_bits & 0x00000010u) != 0) {
      if (::absl::bit_cast<::uint32_t>(this_._internal_snr()) != 0) {
        total_size += 5;
      }
    }
    // fixed32 last_heard = 5;
    if ((cached_has_bits & 0x00000020u) != 0) {
      if (this_._internal_last_heard() != 0) {
        total_size += 5;
      }
    }
    // uint32 channel = 7;
    if ((cached_has_bits & 0x00000040u) != 0) {
      if (this_._internal_channel() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
            this_._internal_channel());
      }
    }
    // optional uint32 hops_away = 9;
    if ((cached_has_bits & 0x00000080u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_hops_away());
    }
  }
  if ((cached_has_bits & 0x00000f00u) != 0) {
    // bool via_mqtt = 8;
    if ((cached_has_bits & 0x00000100u) != 0) {
      if (this_._internal_via_mqtt() != 0) {
        total_size += 2;
      }
    }
    // bool is_favorite = 10;
    if ((cached_has_bits & 0x00000200u) != 0) {
      if (this_._internal_is_favorite() != 0) {
        total_size += 2;
      }
    }
    // bool is_ignored = 11;
    if ((cached_has_bits & 0x00000400u) != 0) {
      if (this_._internal_is_ignored() != 0) {
        total_size += 2;
      }
    }
    // bool is_key_manually_verified = 12;
    if ((cached_has_bits & 0x00000800u) != 0) {
      if (this_._internal_is_key_manually_verified() != 0) {
        total_size += 2;
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void NodeInfo::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<NodeInfo*>(&to_msg);
  auto& from = static_cast<const NodeInfo&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.NodeInfo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x000000ffu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(from._impl_.user_ != nullptr);
      if (_this->_impl_.user_ == nullptr) {
        _this->_impl_.user_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.user_);
      } else {
        _this->_impl_.user_->MergeFrom(*from._impl_.user_);
      }
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      ABSL_DCHECK(from._impl_.position_ != nullptr);
      if (_this->_impl_.position_ == nullptr) {
        _this->_impl_.position_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.position_);
      } else {
        _this->_impl_.position_->MergeFrom(*from._impl_.position_);
      }
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      ABSL_DCHECK(from._impl_.device_metrics_ != nullptr);
      if (_this->_impl_.device_metrics_ == nullptr) {
        _this->_impl_.device_metrics_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.device_metrics_);
      } else {
        _this->_impl_.device_metrics_->MergeFrom(*from._impl_.device_metrics_);
      }
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      if (from._internal_num() != 0) {
        _this->_impl_.num_ = from._impl_.num_;
      }
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      if (::absl::bit_cast<::uint32_t>(from._internal_snr()) != 0) {
        _this->_impl_.snr_ = from._impl_.snr_;
      }
    }
    if ((cached_has_bits & 0x00000020u) != 0) {
      if (from._internal_last_heard() != 0) {
        _this->_impl_.last_heard_ = from._impl_.last_heard_;
      }
    }
    if ((cached_has_bits & 0x00000040u) != 0) {
      if (from._internal_channel() != 0) {
        _this->_impl_.channel_ = from._impl_.channel_;
      }
    }
    if ((cached_has_bits & 0x00000080u) != 0) {
      _this->_impl_.hops_away_ = from._impl_.hops_away_;
    }
  }
  if ((cached_has_bits & 0x00000f00u) != 0) {
    if ((cached_has_bits & 0x00000100u) != 0) {
      if (from._internal_via_mqtt() != 0) {
        _this->_impl_.via_mqtt_ = from._impl_.via_mqtt_;
      }
    }
    if ((cached_has_bits & 0x00000200u) != 0) {
      if (from._internal_is_favorite() != 0) {
        _this->_impl_.is_favorite_ = from._impl_.is_favorite_;
      }
    }
    if ((cached_has_bits & 0x00000400u) != 0) {
      if (from._internal_is_ignored() != 0) {
        _this->_impl_.is_ignored_ = from._impl_.is_ignored_;
      }
    }
    if ((cached_has_bits & 0x00000800u) != 0) {
      if (from._internal_is_key_manually_verified() != 0) {
        _this->_impl_.is_key_manually_verified_ = from._impl_.is_key_manually_verified_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void NodeInfo::CopyFrom(const NodeInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.NodeInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void NodeInfo::InternalSwap(NodeInfo* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NodeInfo, _impl_.is_key_manually_verified_)
      + sizeof(NodeInfo::_impl_.is_key_manually_verified_)
      - PROTOBUF_FIELD_OFFSET(NodeInfo, _impl_.user_)>(
          reinterpret_cast<char*>(&_impl_.user_),
          reinterpret_cast<char*>(&other->_impl_.user_));
}

::google::protobuf::Metadata NodeInfo::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class MyNodeInfo::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<MyNodeInfo>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(MyNodeInfo, _impl_._has_bits_);
};

MyNodeInfo::MyNodeInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, MyNodeInfo_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:meshtastic.MyNodeInfo)
}
PROTOBUF_NDEBUG_INLINE MyNodeInfo::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::meshtastic::MyNodeInfo& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        device_id_(arena, from.device_id_),
        pio_env_(arena, from.pio_env_) {}

MyNodeInfo::MyNodeInfo(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const MyNodeInfo& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, MyNodeInfo_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  MyNodeInfo* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, my_node_num_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, my_node_num_),
           offsetof(Impl_, nodedb_count_) -
               offsetof(Impl_, my_node_num_) +
               sizeof(Impl_::nodedb_count_));

  // @@protoc_insertion_point(copy_constructor:meshtastic.MyNodeInfo)
}
PROTOBUF_NDEBUG_INLINE MyNodeInfo::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        device_id_(arena),
        pio_env_(arena) {}

inline void MyNodeInfo::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, my_node_num_),
           0,
           offsetof(Impl_, nodedb_count_) -
               offsetof(Impl_, my_node_num_) +
               sizeof(Impl_::nodedb_count_));
}
MyNodeInfo::~MyNodeInfo() {
  // @@protoc_insertion_point(destructor:meshtastic.MyNodeInfo)
  SharedDtor(*this);
}
inline void MyNodeInfo::SharedDtor(MessageLite& self) {
  MyNodeInfo& this_ = static_cast<MyNodeInfo&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.device_id_.Destroy();
  this_._impl_.pio_env_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL MyNodeInfo::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) MyNodeInfo(arena);
}
constexpr auto MyNodeInfo::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(MyNodeInfo),
                                            alignof(MyNodeInfo));
}
constexpr auto MyNodeInfo::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_MyNodeInfo_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &MyNodeInfo::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<MyNodeInfo>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &MyNodeInfo::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<MyNodeInfo>(), &MyNodeInfo::ByteSizeLong,
              &MyNodeInfo::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(MyNodeInfo, _impl_._cached_size_),
          false,
      },
      &MyNodeInfo::kDescriptorMethods,
      &descriptor_table_meshtastic_2fmesh_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull MyNodeInfo_class_data_ =
        MyNodeInfo::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
MyNodeInfo::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&MyNodeInfo_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(MyNodeInfo_class_data_.tc_table);
  return MyNodeInfo_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 7, 0, 37, 2>
MyNodeInfo::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(MyNodeInfo, _impl_._has_bits_),
    0, // no _extensions_
    15, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294935422,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    MyNodeInfo_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::meshtastic::MyNodeInfo>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // uint32 reboot_count = 8;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(MyNodeInfo, _impl_.reboot_count_), 3>(),
     {64, 3, 0, PROTOBUF_FIELD_OFFSET(MyNodeInfo, _impl_.reboot_count_)}},
    // uint32 my_node_num = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(MyNodeInfo, _impl_.my_node_num_), 2>(),
     {8, 2, 0, PROTOBUF_FIELD_OFFSET(MyNodeInfo, _impl_.my_node_num_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // uint32 min_app_version = 11;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(MyNodeInfo, _impl_.min_app_version_), 4>(),
     {88, 4, 0, PROTOBUF_FIELD_OFFSET(MyNodeInfo, _impl_.min_app_version_)}},
    // bytes device_id = 12;
    {::_pbi::TcParser::FastBS1,
     {98, 0, 0, PROTOBUF_FIELD_OFFSET(MyNodeInfo, _impl_.device_id_)}},
    // string pio_env = 13;
    {::_pbi::TcParser::FastUS1,
     {106, 1, 0, PROTOBUF_FIELD_OFFSET(MyNodeInfo, _impl_.pio_env_)}},
    // .meshtastic.FirmwareEdition firmware_edition = 14;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(MyNodeInfo, _impl_.firmware_edition_), 5>(),
     {112, 5, 0, PROTOBUF_FIELD_OFFSET(MyNodeInfo, _impl_.firmware_edition_)}},
    // uint32 nodedb_count = 15;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(MyNodeInfo, _impl_.nodedb_count_), 6>(),
     {120, 6, 0, PROTOBUF_FIELD_OFFSET(MyNodeInfo, _impl_.nodedb_count_)}},
  }}, {{
    65535, 65535
  }}, {{
    // uint32 my_node_num = 1;
    {PROTOBUF_FIELD_OFFSET(MyNodeInfo, _impl_.my_node_num_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // uint32 reboot_count = 8;
    {PROTOBUF_FIELD_OFFSET(MyNodeInfo, _impl_.reboot_count_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // uint32 min_app_version = 11;
    {PROTOBUF_FIELD_OFFSET(MyNodeInfo, _impl_.min_app_version_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // bytes device_id = 12;
    {PROTOBUF_FIELD_OFFSET(MyNodeInfo, _impl_.device_id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // string pio_env = 13;
    {PROTOBUF_FIELD_OFFSET(MyNodeInfo, _impl_.pio_env_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .meshtastic.FirmwareEdition firmware_edition = 14;
    {PROTOBUF_FIELD_OFFSET(MyNodeInfo, _impl_.firmware_edition_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kOpenEnum)},
    // uint32 nodedb_count = 15;
    {PROTOBUF_FIELD_OFFSET(MyNodeInfo, _impl_.nodedb_count_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
  }},
  // no aux_entries
  {{
    "\25\0\0\0\0\7\0\0"
    "meshtastic.MyNodeInfo"
    "pio_env"
  }},
};
PROTOBUF_NOINLINE void MyNodeInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.MyNodeInfo)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _impl_.device_id_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _impl_.pio_env_.ClearNonDefaultToEmpty();
    }
  }
  if ((cached_has_bits & 0x0000007cu) != 0) {
    ::memset(&_impl_.my_node_num_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.nodedb_count_) -
        reinterpret_cast<char*>(&_impl_.my_node_num_)) + sizeof(_impl_.nodedb_count_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL MyNodeInfo::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const MyNodeInfo& this_ = static_cast<const MyNodeInfo&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL MyNodeInfo::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const MyNodeInfo& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.MyNodeInfo)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // uint32 my_node_num = 1;
  if ((this_._impl_._has_bits_[0] & 0x00000004u) != 0) {
    if (this_._internal_my_node_num() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          1, this_._internal_my_node_num(), target);
    }
  }

  // uint32 reboot_count = 8;
  if ((this_._impl_._has_bits_[0] & 0x00000008u) != 0) {
    if (this_._internal_reboot_count() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          8, this_._internal_reboot_count(), target);
    }
  }

  // uint32 min_app_version = 11;
  if ((this_._impl_._has_bits_[0] & 0x00000010u) != 0) {
    if (this_._internal_min_app_version() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          11, this_._internal_min_app_version(), target);
    }
  }

  // bytes device_id = 12;
  if ((this_._impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (!this_._internal_device_id().empty()) {
      const ::std::string& _s = this_._internal_device_id();
      target = stream->WriteBytesMaybeAliased(12, _s, target);
    }
  }

  // string pio_env = 13;
  if ((this_._impl_._has_bits_[0] & 0x00000002u) != 0) {
    if (!this_._internal_pio_env().empty()) {
      const ::std::string& _s = this_._internal_pio_env();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "meshtastic.MyNodeInfo.pio_env");
      target = stream->WriteStringMaybeAliased(13, _s, target);
    }
  }

  // .meshtastic.FirmwareEdition firmware_edition = 14;
  if ((this_._impl_._has_bits_[0] & 0x00000020u) != 0) {
    if (this_._internal_firmware_edition() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          14, this_._internal_firmware_edition(), target);
    }
  }

  // uint32 nodedb_count = 15;
  if ((this_._impl_._has_bits_[0] & 0x00000040u) != 0) {
    if (this_._internal_nodedb_count() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          15, this_._internal_nodedb_count(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.MyNodeInfo)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t MyNodeInfo::ByteSizeLong(const MessageLite& base) {
  const MyNodeInfo& this_ = static_cast<const MyNodeInfo&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t MyNodeInfo::ByteSizeLong() const {
  const MyNodeInfo& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:meshtastic.MyNodeInfo)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000007fu) != 0) {
    // bytes device_id = 12;
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (!this_._internal_device_id().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                        this_._internal_device_id());
      }
    }
    // string pio_env = 13;
    if ((cached_has_bits & 0x00000002u) != 0) {
      if (!this_._internal_pio_env().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_pio_env());
      }
    }
    // uint32 my_node_num = 1;
    if ((cached_has_bits & 0x00000004u) != 0) {
      if (this_._internal_my_node_num() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
            this_._internal_my_node_num());
      }
    }
    // uint32 reboot_count = 8;
    if ((cached_has_bits & 0x00000008u) != 0) {
      if (this_._internal_reboot_count() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
            this_._internal_reboot_count());
      }
    }
    // uint32 min_app_version = 11;
    if ((cached_has_bits & 0x00000010u) != 0) {
      if (this_._internal_min_app_version() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
            this_._internal_min_app_version());
      }
    }
    // .meshtastic.FirmwareEdition firmware_edition = 14;
    if ((cached_has_bits & 0x00000020u) != 0) {
      if (this_._internal_firmware_edition() != 0) {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this_._internal_firmware_edition());
      }
    }
    // uint32 nodedb_count = 15;
    if ((cached_has_bits & 0x00000040u) != 0) {
      if (this_._internal_nodedb_count() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
            this_._internal_nodedb_count());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void MyNodeInfo::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<MyNodeInfo*>(&to_msg);
  auto& from = static_cast<const MyNodeInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.MyNodeInfo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000007fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (!from._internal_device_id().empty()) {
        _this->_internal_set_device_id(from._internal_device_id());
      } else {
        if (_this->_impl_.device_id_.IsDefault()) {
          _this->_internal_set_device_id("");
        }
      }
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      if (!from._internal_pio_env().empty()) {
        _this->_internal_set_pio_env(from._internal_pio_env());
      } else {
        if (_this->_impl_.pio_env_.IsDefault()) {
          _this->_internal_set_pio_env("");
        }
      }
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      if (from._internal_my_node_num() != 0) {
        _this->_impl_.my_node_num_ = from._impl_.my_node_num_;
      }
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      if (from._internal_reboot_count() != 0) {
        _this->_impl_.reboot_count_ = from._impl_.reboot_count_;
      }
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      if (from._internal_min_app_version() != 0) {
        _this->_impl_.min_app_version_ = from._impl_.min_app_version_;
      }
    }
    if ((cached_has_bits & 0x00000020u) != 0) {
      if (from._internal_firmware_edition() != 0) {
        _this->_impl_.firmware_edition_ = from._impl_.firmware_edition_;
      }
    }
    if ((cached_has_bits & 0x00000040u) != 0) {
      if (from._internal_nodedb_count() != 0) {
        _this->_impl_.nodedb_count_ = from._impl_.nodedb_count_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void MyNodeInfo::CopyFrom(const MyNodeInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.MyNodeInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void MyNodeInfo::InternalSwap(MyNodeInfo* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.device_id_, &other->_impl_.device_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.pio_env_, &other->_impl_.pio_env_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MyNodeInfo, _impl_.nodedb_count_)
      + sizeof(MyNodeInfo::_impl_.nodedb_count_)
      - PROTOBUF_FIELD_OFFSET(MyNodeInfo, _impl_.my_node_num_)>(
          reinterpret_cast<char*>(&_impl_.my_node_num_),
          reinterpret_cast<char*>(&other->_impl_.my_node_num_));
}

::google::protobuf::Metadata MyNodeInfo::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class LogRecord::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<LogRecord>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(LogRecord, _impl_._has_bits_);
};

LogRecord::LogRecord(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, LogRecord_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:meshtastic.LogRecord)
}
PROTOBUF_NDEBUG_INLINE LogRecord::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::meshtastic::LogRecord& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        message_(arena, from.message_),
        source_(arena, from.source_) {}

LogRecord::LogRecord(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const LogRecord& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, LogRecord_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  LogRecord* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, time_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, time_),
           offsetof(Impl_, level_) -
               offsetof(Impl_, time_) +
               sizeof(Impl_::level_));

  // @@protoc_insertion_point(copy_constructor:meshtastic.LogRecord)
}
PROTOBUF_NDEBUG_INLINE LogRecord::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        message_(arena),
        source_(arena) {}

inline void LogRecord::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, time_),
           0,
           offsetof(Impl_, level_) -
               offsetof(Impl_, time_) +
               sizeof(Impl_::level_));
}
LogRecord::~LogRecord() {
  // @@protoc_insertion_point(destructor:meshtastic.LogRecord)
  SharedDtor(*this);
}
inline void LogRecord::SharedDtor(MessageLite& self) {
  LogRecord& this_ = static_cast<LogRecord&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.message_.Destroy();
  this_._impl_.source_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL LogRecord::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) LogRecord(arena);
}
constexpr auto LogRecord::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(LogRecord),
                                            alignof(LogRecord));
}
constexpr auto LogRecord::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_LogRecord_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &LogRecord::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<LogRecord>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &LogRecord::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<LogRecord>(), &LogRecord::ByteSizeLong,
              &LogRecord::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(LogRecord, _impl_._cached_size_),
          false,
      },
      &LogRecord::kDescriptorMethods,
      &descriptor_table_meshtastic_2fmesh_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull LogRecord_class_data_ =
        LogRecord::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
LogRecord::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&LogRecord_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(LogRecord_class_data_.tc_table);
  return LogRecord_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 42, 2>
LogRecord::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(LogRecord, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    LogRecord_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::meshtastic::LogRecord>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // .meshtastic.LogRecord.Level level = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(LogRecord, _impl_.level_), 3>(),
     {32, 3, 0, PROTOBUF_FIELD_OFFSET(LogRecord, _impl_.level_)}},
    // string message = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(LogRecord, _impl_.message_)}},
    // fixed32 time = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 2, 0, PROTOBUF_FIELD_OFFSET(LogRecord, _impl_.time_)}},
    // string source = 3;
    {::_pbi::TcParser::FastUS1,
     {26, 1, 0, PROTOBUF_FIELD_OFFSET(LogRecord, _impl_.source_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string message = 1;
    {PROTOBUF_FIELD_OFFSET(LogRecord, _impl_.message_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // fixed32 time = 2;
    {PROTOBUF_FIELD_OFFSET(LogRecord, _impl_.time_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFixed32)},
    // string source = 3;
    {PROTOBUF_FIELD_OFFSET(LogRecord, _impl_.source_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .meshtastic.LogRecord.Level level = 4;
    {PROTOBUF_FIELD_OFFSET(LogRecord, _impl_.level_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kOpenEnum)},
  }},
  // no aux_entries
  {{
    "\24\7\0\6\0\0\0\0"
    "meshtastic.LogRecord"
    "message"
    "source"
  }},
};
PROTOBUF_NOINLINE void LogRecord::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.LogRecord)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _impl_.message_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _impl_.source_.ClearNonDefaultToEmpty();
    }
  }
  if ((cached_has_bits & 0x0000000cu) != 0) {
    ::memset(&_impl_.time_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.level_) -
        reinterpret_cast<char*>(&_impl_.time_)) + sizeof(_impl_.level_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL LogRecord::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const LogRecord& this_ = static_cast<const LogRecord&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL LogRecord::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const LogRecord& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.LogRecord)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // string message = 1;
  if ((this_._impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (!this_._internal_message().empty()) {
      const ::std::string& _s = this_._internal_message();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "meshtastic.LogRecord.message");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // fixed32 time = 2;
  if ((this_._impl_._has_bits_[0] & 0x00000004u) != 0) {
    if (this_._internal_time() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
          2, this_._internal_time(), target);
    }
  }

  // string source = 3;
  if ((this_._impl_._has_bits_[0] & 0x00000002u) != 0) {
    if (!this_._internal_source().empty()) {
      const ::std::string& _s = this_._internal_source();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "meshtastic.LogRecord.source");
      target = stream->WriteStringMaybeAliased(3, _s, target);
    }
  }

  // .meshtastic.LogRecord.Level level = 4;
  if ((this_._impl_._has_bits_[0] & 0x00000008u) != 0) {
    if (this_._internal_level() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          4, this_._internal_level(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.LogRecord)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t LogRecord::ByteSizeLong(const MessageLite& base) {
  const LogRecord& this_ = static_cast<const LogRecord&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t LogRecord::ByteSizeLong() const {
  const LogRecord& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:meshtastic.LogRecord)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000000fu) != 0) {
    // string message = 1;
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (!this_._internal_message().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_message());
      }
    }
    // string source = 3;
    if ((cached_has_bits & 0x00000002u) != 0) {
      if (!this_._internal_source().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_source());
      }
    }
    // fixed32 time = 2;
    if ((cached_has_bits & 0x00000004u) != 0) {
      if (this_._internal_time() != 0) {
        total_size += 5;
      }
    }
    // .meshtastic.LogRecord.Level level = 4;
    if ((cached_has_bits & 0x00000008u) != 0) {
      if (this_._internal_level() != 0) {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this_._internal_level());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void LogRecord::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<LogRecord*>(&to_msg);
  auto& from = static_cast<const LogRecord&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.LogRecord)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000000fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (!from._internal_message().empty()) {
        _this->_internal_set_message(from._internal_message());
      } else {
        if (_this->_impl_.message_.IsDefault()) {
          _this->_internal_set_message("");
        }
      }
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      if (!from._internal_source().empty()) {
        _this->_internal_set_source(from._internal_source());
      } else {
        if (_this->_impl_.source_.IsDefault()) {
          _this->_internal_set_source("");
        }
      }
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      if (from._internal_time() != 0) {
        _this->_impl_.time_ = from._impl_.time_;
      }
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      if (from._internal_level() != 0) {
        _this->_impl_.level_ = from._impl_.level_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void LogRecord::CopyFrom(const LogRecord& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.LogRecord)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void LogRecord::InternalSwap(LogRecord* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.message_, &other->_impl_.message_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.source_, &other->_impl_.source_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LogRecord, _impl_.level_)
      + sizeof(LogRecord::_impl_.level_)
      - PROTOBUF_FIELD_OFFSET(LogRecord, _impl_.time_)>(
          reinterpret_cast<char*>(&_impl_.time_),
          reinterpret_cast<char*>(&other->_impl_.time_));
}

::google::protobuf::Metadata LogRecord::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class QueueStatus::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<QueueStatus>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(QueueStatus, _impl_._has_bits_);
};

QueueStatus::QueueStatus(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, QueueStatus_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:meshtastic.QueueStatus)
}
QueueStatus::QueueStatus(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const QueueStatus& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, QueueStatus_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}
PROTOBUF_NDEBUG_INLINE QueueStatus::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void QueueStatus::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, res_),
           0,
           offsetof(Impl_, mesh_packet_id_) -
               offsetof(Impl_, res_) +
               sizeof(Impl_::mesh_packet_id_));
}
QueueStatus::~QueueStatus() {
  // @@protoc_insertion_point(destructor:meshtastic.QueueStatus)
  SharedDtor(*this);
}
inline void QueueStatus::SharedDtor(MessageLite& self) {
  QueueStatus& this_ = static_cast<QueueStatus&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL QueueStatus::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) QueueStatus(arena);
}
constexpr auto QueueStatus::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(QueueStatus),
                                            alignof(QueueStatus));
}
constexpr auto QueueStatus::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_QueueStatus_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &QueueStatus::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<QueueStatus>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &QueueStatus::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<QueueStatus>(), &QueueStatus::ByteSizeLong,
              &QueueStatus::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(QueueStatus, _impl_._cached_size_),
          false,
      },
      &QueueStatus::kDescriptorMethods,
      &descriptor_table_meshtastic_2fmesh_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull QueueStatus_class_data_ =
        QueueStatus::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
QueueStatus::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&QueueStatus_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(QueueStatus_class_data_.tc_table);
  return QueueStatus_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 0, 2>
QueueStatus::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(QueueStatus, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    QueueStatus_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::meshtastic::QueueStatus>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // uint32 mesh_packet_id = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(QueueStatus, _impl_.mesh_packet_id_), 3>(),
     {32, 3, 0, PROTOBUF_FIELD_OFFSET(QueueStatus, _impl_.mesh_packet_id_)}},
    // int32 res = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(QueueStatus, _impl_.res_), 0>(),
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(QueueStatus, _impl_.res_)}},
    // uint32 free = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(QueueStatus, _impl_.free_), 1>(),
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(QueueStatus, _impl_.free_)}},
    // uint32 maxlen = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(QueueStatus, _impl_.maxlen_), 2>(),
     {24, 2, 0, PROTOBUF_FIELD_OFFSET(QueueStatus, _impl_.maxlen_)}},
  }}, {{
    65535, 65535
  }}, {{
    // int32 res = 1;
    {PROTOBUF_FIELD_OFFSET(QueueStatus, _impl_.res_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // uint32 free = 2;
    {PROTOBUF_FIELD_OFFSET(QueueStatus, _impl_.free_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // uint32 maxlen = 3;
    {PROTOBUF_FIELD_OFFSET(QueueStatus, _impl_.maxlen_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // uint32 mesh_packet_id = 4;
    {PROTOBUF_FIELD_OFFSET(QueueStatus, _impl_.mesh_packet_id_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void QueueStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.QueueStatus)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000000fu) != 0) {
    ::memset(&_impl_.res_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.mesh_packet_id_) -
        reinterpret_cast<char*>(&_impl_.res_)) + sizeof(_impl_.mesh_packet_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL QueueStatus::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const QueueStatus& this_ = static_cast<const QueueStatus&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL QueueStatus::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const QueueStatus& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.QueueStatus)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // int32 res = 1;
  if ((this_._impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (this_._internal_res() != 0) {
      target =
          ::google::protobuf::internal::WireFormatLite::WriteInt32ToArrayWithField<1>(
              stream, this_._internal_res(), target);
    }
  }

  // uint32 free = 2;
  if ((this_._impl_._has_bits_[0] & 0x00000002u) != 0) {
    if (this_._internal_free() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          2, this_._internal_free(), target);
    }
  }

  // uint32 maxlen = 3;
  if ((this_._impl_._has_bits_[0] & 0x00000004u) != 0) {
    if (this_._internal_maxlen() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          3, this_._internal_maxlen(), target);
    }
  }

  // uint32 mesh_packet_id = 4;
  if ((this_._impl_._has_bits_[0] & 0x00000008u) != 0) {
    if (this_._internal_mesh_packet_id() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          4, this_._internal_mesh_packet_id(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.QueueStatus)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t QueueStatus::ByteSizeLong(const MessageLite& base) {
  const QueueStatus& this_ = static_cast<const QueueStatus&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t QueueStatus::ByteSizeLong() const {
  const QueueStatus& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:meshtastic.QueueStatus)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000000fu) != 0) {
    // int32 res = 1;
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (this_._internal_res() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
            this_._internal_res());
      }
    }
    // uint32 free = 2;
    if ((cached_has_bits & 0x00000002u) != 0) {
      if (this_._internal_free() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
            this_._internal_free());
      }
    }
    // uint32 maxlen = 3;
    if ((cached_has_bits & 0x00000004u) != 0) {
      if (this_._internal_maxlen() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
            this_._internal_maxlen());
      }
    }
    // uint32 mesh_packet_id = 4;
    if ((cached_has_bits & 0x00000008u) != 0) {
      if (this_._internal_mesh_packet_id() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
            this_._internal_mesh_packet_id());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void QueueStatus::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<QueueStatus*>(&to_msg);
  auto& from = static_cast<const QueueStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.QueueStatus)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000000fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (from._internal_res() != 0) {
        _this->_impl_.res_ = from._impl_.res_;
      }
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      if (from._internal_free() != 0) {
        _this->_impl_.free_ = from._impl_.free_;
      }
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      if (from._internal_maxlen() != 0) {
        _this->_impl_.maxlen_ = from._impl_.maxlen_;
      }
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      if (from._internal_mesh_packet_id() != 0) {
        _this->_impl_.mesh_packet_id_ = from._impl_.mesh_packet_id_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void QueueStatus::CopyFrom(const QueueStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.QueueStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void QueueStatus::InternalSwap(QueueStatus* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(QueueStatus, _impl_.mesh_packet_id_)
      + sizeof(QueueStatus::_impl_.mesh_packet_id_)
      - PROTOBUF_FIELD_OFFSET(QueueStatus, _impl_.res_)>(
          reinterpret_cast<char*>(&_impl_.res_),
          reinterpret_cast<char*>(&other->_impl_.res_));
}

::google::protobuf::Metadata QueueStatus::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class FromRadio::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<FromRadio>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(FromRadio, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::meshtastic::FromRadio, _impl_._oneof_case_);
};

void FromRadio::set_allocated_packet(::meshtastic::MeshPacket* PROTOBUF_NULLABLE packet) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_payload_variant();
  if (packet) {
    ::google::protobuf::Arena* submessage_arena = packet->GetArena();
    if (message_arena != submessage_arena) {
      packet = ::google::protobuf::internal::GetOwnedMessage(message_arena, packet, submessage_arena);
    }
    set_has_packet();
    _impl_.payload_variant_.packet_ = packet;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.FromRadio.packet)
}
void FromRadio::set_allocated_my_info(::meshtastic::MyNodeInfo* PROTOBUF_NULLABLE my_info) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_payload_variant();
  if (my_info) {
    ::google::protobuf::Arena* submessage_arena = my_info->GetArena();
    if (message_arena != submessage_arena) {
      my_info = ::google::protobuf::internal::GetOwnedMessage(message_arena, my_info, submessage_arena);
    }
    set_has_my_info();
    _impl_.payload_variant_.my_info_ = my_info;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.FromRadio.my_info)
}
void FromRadio::set_allocated_node_info(::meshtastic::NodeInfo* PROTOBUF_NULLABLE node_info) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_payload_variant();
  if (node_info) {
    ::google::protobuf::Arena* submessage_arena = node_info->GetArena();
    if (message_arena != submessage_arena) {
      node_info = ::google::protobuf::internal::GetOwnedMessage(message_arena, node_info, submessage_arena);
    }
    set_has_node_info();
    _impl_.payload_variant_.node_info_ = node_info;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.FromRadio.node_info)
}
void FromRadio::set_allocated_config(::meshtastic::Config* PROTOBUF_NULLABLE config) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_payload_variant();
  if (config) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(config)->GetArena();
    if (message_arena != submessage_arena) {
      config = ::google::protobuf::internal::GetOwnedMessage(message_arena, config, submessage_arena);
    }
    set_has_config();
    _impl_.payload_variant_.config_ = config;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.FromRadio.config)
}
void FromRadio::clear_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kConfig) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_variant_.config_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.config_);
    }
    clear_has_payload_variant();
  }
}
void FromRadio::set_allocated_log_record(::meshtastic::LogRecord* PROTOBUF_NULLABLE log_record) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_payload_variant();
  if (log_record) {
    ::google::protobuf::Arena* submessage_arena = log_record->GetArena();
    if (message_arena != submessage_arena) {
      log_record = ::google::protobuf::internal::GetOwnedMessage(message_arena, log_record, submessage_arena);
    }
    set_has_log_record();
    _impl_.payload_variant_.log_record_ = log_record;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.FromRadio.log_record)
}
void FromRadio::set_allocated_moduleconfig(::meshtastic::ModuleConfig* PROTOBUF_NULLABLE moduleconfig) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_payload_variant();
  if (moduleconfig) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(moduleconfig)->GetArena();
    if (message_arena != submessage_arena) {
      moduleconfig = ::google::protobuf::internal::GetOwnedMessage(message_arena, moduleconfig, submessage_arena);
    }
    set_has_moduleconfig();
    _impl_.payload_variant_.moduleconfig_ = moduleconfig;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.FromRadio.moduleConfig)
}
void FromRadio::clear_moduleconfig() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kModuleConfig) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_variant_.moduleconfig_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.moduleconfig_);
    }
    clear_has_payload_variant();
  }
}
void FromRadio::set_allocated_channel(::meshtastic::Channel* PROTOBUF_NULLABLE channel) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_payload_variant();
  if (channel) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(channel)->GetArena();
    if (message_arena != submessage_arena) {
      channel = ::google::protobuf::internal::GetOwnedMessage(message_arena, channel, submessage_arena);
    }
    set_has_channel();
    _impl_.payload_variant_.channel_ = channel;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.FromRadio.channel)
}
void FromRadio::clear_channel() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kChannel) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_variant_.channel_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.channel_);
    }
    clear_has_payload_variant();
  }
}
void FromRadio::set_allocated_queuestatus(::meshtastic::QueueStatus* PROTOBUF_NULLABLE queuestatus) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_payload_variant();
  if (queuestatus) {
    ::google::protobuf::Arena* submessage_arena = queuestatus->GetArena();
    if (message_arena != submessage_arena) {
      queuestatus = ::google::protobuf::internal::GetOwnedMessage(message_arena, queuestatus, submessage_arena);
    }
    set_has_queuestatus();
    _impl_.payload_variant_.queuestatus_ = queuestatus;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.FromRadio.queueStatus)
}
void FromRadio::set_allocated_xmodempacket(::meshtastic::XModem* PROTOBUF_NULLABLE xmodempacket) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_payload_variant();
  if (xmodempacket) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(xmodempacket)->GetArena();
    if (message_arena != submessage_arena) {
      xmodempacket = ::google::protobuf::internal::GetOwnedMessage(message_arena, xmodempacket, submessage_arena);
    }
    set_has_xmodempacket();
    _impl_.payload_variant_.xmodempacket_ = xmodempacket;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.FromRadio.xmodemPacket)
}
void FromRadio::clear_xmodempacket() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kXmodemPacket) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_variant_.xmodempacket_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.xmodempacket_);
    }
    clear_has_payload_variant();
  }
}
void FromRadio::set_allocated_metadata(::meshtastic::DeviceMetadata* PROTOBUF_NULLABLE metadata) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_payload_variant();
  if (metadata) {
    ::google::protobuf::Arena* submessage_arena = metadata->GetArena();
    if (message_arena != submessage_arena) {
      metadata = ::google::protobuf::internal::GetOwnedMessage(message_arena, metadata, submessage_arena);
    }
    set_has_metadata();
    _impl_.payload_variant_.metadata_ = metadata;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.FromRadio.metadata)
}
void FromRadio::set_allocated_mqttclientproxymessage(::meshtastic::MqttClientProxyMessage* PROTOBUF_NULLABLE mqttclientproxymessage) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_payload_variant();
  if (mqttclientproxymessage) {
    ::google::protobuf::Arena* submessage_arena = mqttclientproxymessage->GetArena();
    if (message_arena != submessage_arena) {
      mqttclientproxymessage = ::google::protobuf::internal::GetOwnedMessage(message_arena, mqttclientproxymessage, submessage_arena);
    }
    set_has_mqttclientproxymessage();
    _impl_.payload_variant_.mqttclientproxymessage_ = mqttclientproxymessage;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.FromRadio.mqttClientProxyMessage)
}
void FromRadio::set_allocated_fileinfo(::meshtastic::FileInfo* PROTOBUF_NULLABLE fileinfo) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_payload_variant();
  if (fileinfo) {
    ::google::protobuf::Arena* submessage_arena = fileinfo->GetArena();
    if (message_arena != submessage_arena) {
      fileinfo = ::google::protobuf::internal::GetOwnedMessage(message_arena, fileinfo, submessage_arena);
    }
    set_has_fileinfo();
    _impl_.payload_variant_.fileinfo_ = fileinfo;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.FromRadio.fileInfo)
}
void FromRadio::set_allocated_clientnotification(::meshtastic::ClientNotification* PROTOBUF_NULLABLE clientnotification) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_payload_variant();
  if (clientnotification) {
    ::google::protobuf::Arena* submessage_arena = clientnotification->GetArena();
    if (message_arena != submessage_arena) {
      clientnotification = ::google::protobuf::internal::GetOwnedMessage(message_arena, clientnotification, submessage_arena);
    }
    set_has_clientnotification();
    _impl_.payload_variant_.clientnotification_ = clientnotification;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.FromRadio.clientNotification)
}
void FromRadio::set_allocated_deviceuiconfig(::meshtastic::DeviceUIConfig* PROTOBUF_NULLABLE deviceuiconfig) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_payload_variant();
  if (deviceuiconfig) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(deviceuiconfig)->GetArena();
    if (message_arena != submessage_arena) {
      deviceuiconfig = ::google::protobuf::internal::GetOwnedMessage(message_arena, deviceuiconfig, submessage_arena);
    }
    set_has_deviceuiconfig();
    _impl_.payload_variant_.deviceuiconfig_ = deviceuiconfig;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.FromRadio.deviceuiConfig)
}
void FromRadio::clear_deviceuiconfig() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kDeviceuiConfig) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_variant_.deviceuiconfig_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.deviceuiconfig_);
    }
    clear_has_payload_variant();
  }
}
FromRadio::FromRadio(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, FromRadio_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:meshtastic.FromRadio)
}
PROTOBUF_NDEBUG_INLINE FromRadio::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::meshtastic::FromRadio& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        payload_variant_{},
        _oneof_case_{from._oneof_case_[0]} {}

FromRadio::FromRadio(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const FromRadio& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, FromRadio_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  FromRadio* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.id_ = from._impl_.id_;
  switch (payload_variant_case()) {
    case PAYLOAD_VARIANT_NOT_SET:
      break;
      case kPacket:
        _impl_.payload_variant_.packet_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.packet_);
        break;
      case kMyInfo:
        _impl_.payload_variant_.my_info_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.my_info_);
        break;
      case kNodeInfo:
        _impl_.payload_variant_.node_info_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.node_info_);
        break;
      case kConfig:
        _impl_.payload_variant_.config_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.config_);
        break;
      case kLogRecord:
        _impl_.payload_variant_.log_record_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.log_record_);
        break;
      case kConfigCompleteId:
        _impl_.payload_variant_.config_complete_id_ = from._impl_.payload_variant_.config_complete_id_;
        break;
      case kRebooted:
        _impl_.payload_variant_.rebooted_ = from._impl_.payload_variant_.rebooted_;
        break;
      case kModuleConfig:
        _impl_.payload_variant_.moduleconfig_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.moduleconfig_);
        break;
      case kChannel:
        _impl_.payload_variant_.channel_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.channel_);
        break;
      case kQueueStatus:
        _impl_.payload_variant_.queuestatus_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.queuestatus_);
        break;
      case kXmodemPacket:
        _impl_.payload_variant_.xmodempacket_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.xmodempacket_);
        break;
      case kMetadata:
        _impl_.payload_variant_.metadata_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.metadata_);
        break;
      case kMqttClientProxyMessage:
        _impl_.payload_variant_.mqttclientproxymessage_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.mqttclientproxymessage_);
        break;
      case kFileInfo:
        _impl_.payload_variant_.fileinfo_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.fileinfo_);
        break;
      case kClientNotification:
        _impl_.payload_variant_.clientnotification_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.clientnotification_);
        break;
      case kDeviceuiConfig:
        _impl_.payload_variant_.deviceuiconfig_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.deviceuiconfig_);
        break;
  }

  // @@protoc_insertion_point(copy_constructor:meshtastic.FromRadio)
}
PROTOBUF_NDEBUG_INLINE FromRadio::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        payload_variant_{},
        _oneof_case_{} {}

inline void FromRadio::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.id_ = {};
}
FromRadio::~FromRadio() {
  // @@protoc_insertion_point(destructor:meshtastic.FromRadio)
  SharedDtor(*this);
}
inline void FromRadio::SharedDtor(MessageLite& self) {
  FromRadio& this_ = static_cast<FromRadio&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  if (this_.has_payload_variant()) {
    this_.clear_payload_variant();
  }
  this_._impl_.~Impl_();
}

void FromRadio::clear_payload_variant() {
// @@protoc_insertion_point(one_of_clear_start:meshtastic.FromRadio)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (payload_variant_case()) {
    case kPacket: {
      if (GetArena() == nullptr) {
        delete _impl_.payload_variant_.packet_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.packet_);
      }
      break;
    }
    case kMyInfo: {
      if (GetArena() == nullptr) {
        delete _impl_.payload_variant_.my_info_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.my_info_);
      }
      break;
    }
    case kNodeInfo: {
      if (GetArena() == nullptr) {
        delete _impl_.payload_variant_.node_info_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.node_info_);
      }
      break;
    }
    case kConfig: {
      if (GetArena() == nullptr) {
        delete _impl_.payload_variant_.config_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.config_);
      }
      break;
    }
    case kLogRecord: {
      if (GetArena() == nullptr) {
        delete _impl_.payload_variant_.log_record_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.log_record_);
      }
      break;
    }
    case kConfigCompleteId: {
      // No need to clear
      break;
    }
    case kRebooted: {
      // No need to clear
      break;
    }
    case kModuleConfig: {
      if (GetArena() == nullptr) {
        delete _impl_.payload_variant_.moduleconfig_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.moduleconfig_);
      }
      break;
    }
    case kChannel: {
      if (GetArena() == nullptr) {
        delete _impl_.payload_variant_.channel_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.channel_);
      }
      break;
    }
    case kQueueStatus: {
      if (GetArena() == nullptr) {
        delete _impl_.payload_variant_.queuestatus_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.queuestatus_);
      }
      break;
    }
    case kXmodemPacket: {
      if (GetArena() == nullptr) {
        delete _impl_.payload_variant_.xmodempacket_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.xmodempacket_);
      }
      break;
    }
    case kMetadata: {
      if (GetArena() == nullptr) {
        delete _impl_.payload_variant_.metadata_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.metadata_);
      }
      break;
    }
    case kMqttClientProxyMessage: {
      if (GetArena() == nullptr) {
        delete _impl_.payload_variant_.mqttclientproxymessage_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.mqttclientproxymessage_);
      }
      break;
    }
    case kFileInfo: {
      if (GetArena() == nullptr) {
        delete _impl_.payload_variant_.fileinfo_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.fileinfo_);
      }
      break;
    }
    case kClientNotification: {
      if (GetArena() == nullptr) {
        delete _impl_.payload_variant_.clientnotification_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.clientnotification_);
      }
      break;
    }
    case kDeviceuiConfig: {
      if (GetArena() == nullptr) {
        delete _impl_.payload_variant_.deviceuiconfig_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.deviceuiconfig_);
      }
      break;
    }
    case PAYLOAD_VARIANT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = PAYLOAD_VARIANT_NOT_SET;
}


inline void* PROTOBUF_NONNULL FromRadio::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) FromRadio(arena);
}
constexpr auto FromRadio::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(FromRadio),
                                            alignof(FromRadio));
}
constexpr auto FromRadio::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_FromRadio_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &FromRadio::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<FromRadio>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &FromRadio::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<FromRadio>(), &FromRadio::ByteSizeLong,
              &FromRadio::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(FromRadio, _impl_._cached_size_),
          false,
      },
      &FromRadio::kDescriptorMethods,
      &descriptor_table_meshtastic_2fmesh_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull FromRadio_class_data_ =
        FromRadio::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
FromRadio::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&FromRadio_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(FromRadio_class_data_.tc_table);
  return FromRadio_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 17, 14, 0, 2>
FromRadio::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(FromRadio, _impl_._has_bits_),
    0, // no _extensions_
    17, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294836224,  // skipmap
    offsetof(decltype(_table_), field_entries),
    17,  // num_field_entries
    14,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    FromRadio_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::meshtastic::FromRadio>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // uint32 id = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(FromRadio, _impl_.id_), 0>(),
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(FromRadio, _impl_.id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // uint32 id = 1;
    {PROTOBUF_FIELD_OFFSET(FromRadio, _impl_.id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // .meshtastic.MeshPacket packet = 2;
    {PROTOBUF_FIELD_OFFSET(FromRadio, _impl_.payload_variant_.packet_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .meshtastic.MyNodeInfo my_info = 3;
    {PROTOBUF_FIELD_OFFSET(FromRadio, _impl_.payload_variant_.my_info_), _Internal::kOneofCaseOffset + 0, 1,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .meshtastic.NodeInfo node_info = 4;
    {PROTOBUF_FIELD_OFFSET(FromRadio, _impl_.payload_variant_.node_info_), _Internal::kOneofCaseOffset + 0, 2,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .meshtastic.Config config = 5;
    {PROTOBUF_FIELD_OFFSET(FromRadio, _impl_.payload_variant_.config_), _Internal::kOneofCaseOffset + 0, 3,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .meshtastic.LogRecord log_record = 6;
    {PROTOBUF_FIELD_OFFSET(FromRadio, _impl_.payload_variant_.log_record_), _Internal::kOneofCaseOffset + 0, 4,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // uint32 config_complete_id = 7;
    {PROTOBUF_FIELD_OFFSET(FromRadio, _impl_.payload_variant_.config_complete_id_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUInt32)},
    // bool rebooted = 8;
    {PROTOBUF_FIELD_OFFSET(FromRadio, _impl_.payload_variant_.rebooted_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // .meshtastic.ModuleConfig moduleConfig = 9;
    {PROTOBUF_FIELD_OFFSET(FromRadio, _impl_.payload_variant_.moduleconfig_), _Internal::kOneofCaseOffset + 0, 5,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .meshtastic.Channel channel = 10;
    {PROTOBUF_FIELD_OFFSET(FromRadio, _impl_.payload_variant_.channel_), _Internal::kOneofCaseOffset + 0, 6,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .meshtastic.QueueStatus queueStatus = 11;
    {PROTOBUF_FIELD_OFFSET(FromRadio, _impl_.payload_variant_.queuestatus_), _Internal::kOneofCaseOffset + 0, 7,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .meshtastic.XModem xmodemPacket = 12;
    {PROTOBUF_FIELD_OFFSET(FromRadio, _impl_.payload_variant_.xmodempacket_), _Internal::kOneofCaseOffset + 0, 8,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .meshtastic.DeviceMetadata metadata = 13;
    {PROTOBUF_FIELD_OFFSET(FromRadio, _impl_.payload_variant_.metadata_), _Internal::kOneofCaseOffset + 0, 9,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .meshtastic.MqttClientProxyMessage mqttClientProxyMessage = 14;
    {PROTOBUF_FIELD_OFFSET(FromRadio, _impl_.payload_variant_.mqttclientproxymessage_), _Internal::kOneofCaseOffset + 0, 10,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .meshtastic.FileInfo fileInfo = 15;
    {PROTOBUF_FIELD_OFFSET(FromRadio, _impl_.payload_variant_.fileinfo_), _Internal::kOneofCaseOffset + 0, 11,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .meshtastic.ClientNotification clientNotification = 16;
    {PROTOBUF_FIELD_OFFSET(FromRadio, _impl_.payload_variant_.clientnotification_), _Internal::kOneofCaseOffset + 0, 12,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .meshtastic.DeviceUIConfig deviceuiConfig = 17;
    {PROTOBUF_FIELD_OFFSET(FromRadio, _impl_.payload_variant_.deviceuiconfig_), _Internal::kOneofCaseOffset + 0, 13,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::meshtastic::MeshPacket>()},
      {::_pbi::TcParser::GetTable<::meshtastic::MyNodeInfo>()},
      {::_pbi::TcParser::GetTable<::meshtastic::NodeInfo>()},
      {::_pbi::TcParser::GetTable<::meshtastic::Config>()},
      {::_pbi::TcParser::GetTable<::meshtastic::LogRecord>()},
      {::_pbi::TcParser::GetTable<::meshtastic::ModuleConfig>()},
      {::_pbi::TcParser::GetTable<::meshtastic::Channel>()},
      {::_pbi::TcParser::GetTable<::meshtastic::QueueStatus>()},
      {::_pbi::TcParser::GetTable<::meshtastic::XModem>()},
      {::_pbi::TcParser::GetTable<::meshtastic::DeviceMetadata>()},
      {::_pbi::TcParser::GetTable<::meshtastic::MqttClientProxyMessage>()},
      {::_pbi::TcParser::GetTable<::meshtastic::FileInfo>()},
      {::_pbi::TcParser::GetTable<::meshtastic::ClientNotification>()},
      {::_pbi::TcParser::GetTable<::meshtastic::DeviceUIConfig>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void FromRadio::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.FromRadio)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.id_ = 0u;
  clear_payload_variant();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL FromRadio::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const FromRadio& this_ = static_cast<const FromRadio&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL FromRadio::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const FromRadio& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.FromRadio)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // uint32 id = 1;
  if ((this_._impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (this_._internal_id() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          1, this_._internal_id(), target);
    }
  }

  switch (this_.payload_variant_case()) {
    case kPacket: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          2, *this_._impl_.payload_variant_.packet_, this_._impl_.payload_variant_.packet_->GetCachedSize(), target,
          stream);
      break;
    }
    case kMyInfo: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          3, *this_._impl_.payload_variant_.my_info_, this_._impl_.payload_variant_.my_info_->GetCachedSize(), target,
          stream);
      break;
    }
    case kNodeInfo: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          4, *this_._impl_.payload_variant_.node_info_, this_._impl_.payload_variant_.node_info_->GetCachedSize(), target,
          stream);
      break;
    }
    case kConfig: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          5, *this_._impl_.payload_variant_.config_, this_._impl_.payload_variant_.config_->GetCachedSize(), target,
          stream);
      break;
    }
    case kLogRecord: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          6, *this_._impl_.payload_variant_.log_record_, this_._impl_.payload_variant_.log_record_->GetCachedSize(), target,
          stream);
      break;
    }
    case kConfigCompleteId: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          7, this_._internal_config_complete_id(), target);
      break;
    }
    case kRebooted: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          8, this_._internal_rebooted(), target);
      break;
    }
    case kModuleConfig: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          9, *this_._impl_.payload_variant_.moduleconfig_, this_._impl_.payload_variant_.moduleconfig_->GetCachedSize(), target,
          stream);
      break;
    }
    case kChannel: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          10, *this_._impl_.payload_variant_.channel_, this_._impl_.payload_variant_.channel_->GetCachedSize(), target,
          stream);
      break;
    }
    case kQueueStatus: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          11, *this_._impl_.payload_variant_.queuestatus_, this_._impl_.payload_variant_.queuestatus_->GetCachedSize(), target,
          stream);
      break;
    }
    case kXmodemPacket: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          12, *this_._impl_.payload_variant_.xmodempacket_, this_._impl_.payload_variant_.xmodempacket_->GetCachedSize(), target,
          stream);
      break;
    }
    case kMetadata: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          13, *this_._impl_.payload_variant_.metadata_, this_._impl_.payload_variant_.metadata_->GetCachedSize(), target,
          stream);
      break;
    }
    case kMqttClientProxyMessage: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          14, *this_._impl_.payload_variant_.mqttclientproxymessage_, this_._impl_.payload_variant_.mqttclientproxymessage_->GetCachedSize(), target,
          stream);
      break;
    }
    case kFileInfo: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          15, *this_._impl_.payload_variant_.fileinfo_, this_._impl_.payload_variant_.fileinfo_->GetCachedSize(), target,
          stream);
      break;
    }
    case kClientNotification: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          16, *this_._impl_.payload_variant_.clientnotification_, this_._impl_.payload_variant_.clientnotification_->GetCachedSize(), target,
          stream);
      break;
    }
    case kDeviceuiConfig: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          17, *this_._impl_.payload_variant_.deviceuiconfig_, this_._impl_.payload_variant_.deviceuiconfig_->GetCachedSize(), target,
          stream);
      break;
    }
    default:
      break;
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.FromRadio)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t FromRadio::ByteSizeLong(const MessageLite& base) {
  const FromRadio& this_ = static_cast<const FromRadio&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t FromRadio::ByteSizeLong() const {
  const FromRadio& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:meshtastic.FromRadio)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

   {
    // uint32 id = 1;
    cached_has_bits = this_._impl_._has_bits_[0];
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (this_._internal_id() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
            this_._internal_id());
      }
    }
  }
  switch (this_.payload_variant_case()) {
    // .meshtastic.MeshPacket packet = 2;
    case kPacket: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.payload_variant_.packet_);
      break;
    }
    // .meshtastic.MyNodeInfo my_info = 3;
    case kMyInfo: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.payload_variant_.my_info_);
      break;
    }
    // .meshtastic.NodeInfo node_info = 4;
    case kNodeInfo: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.payload_variant_.node_info_);
      break;
    }
    // .meshtastic.Config config = 5;
    case kConfig: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.payload_variant_.config_);
      break;
    }
    // .meshtastic.LogRecord log_record = 6;
    case kLogRecord: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.payload_variant_.log_record_);
      break;
    }
    // uint32 config_complete_id = 7;
    case kConfigCompleteId: {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_config_complete_id());
      break;
    }
    // bool rebooted = 8;
    case kRebooted: {
      total_size += 2;
      break;
    }
    // .meshtastic.ModuleConfig moduleConfig = 9;
    case kModuleConfig: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.payload_variant_.moduleconfig_);
      break;
    }
    // .meshtastic.Channel channel = 10;
    case kChannel: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.payload_variant_.channel_);
      break;
    }
    // .meshtastic.QueueStatus queueStatus = 11;
    case kQueueStatus: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.payload_variant_.queuestatus_);
      break;
    }
    // .meshtastic.XModem xmodemPacket = 12;
    case kXmodemPacket: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.payload_variant_.xmodempacket_);
      break;
    }
    // .meshtastic.DeviceMetadata metadata = 13;
    case kMetadata: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.payload_variant_.metadata_);
      break;
    }
    // .meshtastic.MqttClientProxyMessage mqttClientProxyMessage = 14;
    case kMqttClientProxyMessage: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.payload_variant_.mqttclientproxymessage_);
      break;
    }
    // .meshtastic.FileInfo fileInfo = 15;
    case kFileInfo: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.payload_variant_.fileinfo_);
      break;
    }
    // .meshtastic.ClientNotification clientNotification = 16;
    case kClientNotification: {
      total_size += 2 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.payload_variant_.clientnotification_);
      break;
    }
    // .meshtastic.DeviceUIConfig deviceuiConfig = 17;
    case kDeviceuiConfig: {
      total_size += 2 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.payload_variant_.deviceuiconfig_);
      break;
    }
    case PAYLOAD_VARIANT_NOT_SET: {
      break;
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void FromRadio::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<FromRadio*>(&to_msg);
  auto& from = static_cast<const FromRadio&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.FromRadio)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    if (from._internal_id() != 0) {
      _this->_impl_.id_ = from._impl_.id_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_payload_variant();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kPacket: {
        if (oneof_needs_init) {
          _this->_impl_.payload_variant_.packet_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.packet_);
        } else {
          _this->_impl_.payload_variant_.packet_->MergeFrom(*from._impl_.payload_variant_.packet_);
        }
        break;
      }
      case kMyInfo: {
        if (oneof_needs_init) {
          _this->_impl_.payload_variant_.my_info_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.my_info_);
        } else {
          _this->_impl_.payload_variant_.my_info_->MergeFrom(*from._impl_.payload_variant_.my_info_);
        }
        break;
      }
      case kNodeInfo: {
        if (oneof_needs_init) {
          _this->_impl_.payload_variant_.node_info_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.node_info_);
        } else {
          _this->_impl_.payload_variant_.node_info_->MergeFrom(*from._impl_.payload_variant_.node_info_);
        }
        break;
      }
      case kConfig: {
        if (oneof_needs_init) {
          _this->_impl_.payload_variant_.config_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.config_);
        } else {
          _this->_impl_.payload_variant_.config_->MergeFrom(*from._impl_.payload_variant_.config_);
        }
        break;
      }
      case kLogRecord: {
        if (oneof_needs_init) {
          _this->_impl_.payload_variant_.log_record_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.log_record_);
        } else {
          _this->_impl_.payload_variant_.log_record_->MergeFrom(*from._impl_.payload_variant_.log_record_);
        }
        break;
      }
      case kConfigCompleteId: {
        _this->_impl_.payload_variant_.config_complete_id_ = from._impl_.payload_variant_.config_complete_id_;
        break;
      }
      case kRebooted: {
        _this->_impl_.payload_variant_.rebooted_ = from._impl_.payload_variant_.rebooted_;
        break;
      }
      case kModuleConfig: {
        if (oneof_needs_init) {
          _this->_impl_.payload_variant_.moduleconfig_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.moduleconfig_);
        } else {
          _this->_impl_.payload_variant_.moduleconfig_->MergeFrom(*from._impl_.payload_variant_.moduleconfig_);
        }
        break;
      }
      case kChannel: {
        if (oneof_needs_init) {
          _this->_impl_.payload_variant_.channel_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.channel_);
        } else {
          _this->_impl_.payload_variant_.channel_->MergeFrom(*from._impl_.payload_variant_.channel_);
        }
        break;
      }
      case kQueueStatus: {
        if (oneof_needs_init) {
          _this->_impl_.payload_variant_.queuestatus_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.queuestatus_);
        } else {
          _this->_impl_.payload_variant_.queuestatus_->MergeFrom(*from._impl_.payload_variant_.queuestatus_);
        }
        break;
      }
      case kXmodemPacket: {
        if (oneof_needs_init) {
          _this->_impl_.payload_variant_.xmodempacket_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.xmodempacket_);
        } else {
          _this->_impl_.payload_variant_.xmodempacket_->MergeFrom(*from._impl_.payload_variant_.xmodempacket_);
        }
        break;
      }
      case kMetadata: {
        if (oneof_needs_init) {
          _this->_impl_.payload_variant_.metadata_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.metadata_);
        } else {
          _this->_impl_.payload_variant_.metadata_->MergeFrom(*from._impl_.payload_variant_.metadata_);
        }
        break;
      }
      case kMqttClientProxyMessage: {
        if (oneof_needs_init) {
          _this->_impl_.payload_variant_.mqttclientproxymessage_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.mqttclientproxymessage_);
        } else {
          _this->_impl_.payload_variant_.mqttclientproxymessage_->MergeFrom(*from._impl_.payload_variant_.mqttclientproxymessage_);
        }
        break;
      }
      case kFileInfo: {
        if (oneof_needs_init) {
          _this->_impl_.payload_variant_.fileinfo_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.fileinfo_);
        } else {
          _this->_impl_.payload_variant_.fileinfo_->MergeFrom(*from._impl_.payload_variant_.fileinfo_);
        }
        break;
      }
      case kClientNotification: {
        if (oneof_needs_init) {
          _this->_impl_.payload_variant_.clientnotification_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.clientnotification_);
        } else {
          _this->_impl_.payload_variant_.clientnotification_->MergeFrom(*from._impl_.payload_variant_.clientnotification_);
        }
        break;
      }
      case kDeviceuiConfig: {
        if (oneof_needs_init) {
          _this->_impl_.payload_variant_.deviceuiconfig_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.deviceuiconfig_);
        } else {
          _this->_impl_.payload_variant_.deviceuiconfig_->MergeFrom(*from._impl_.payload_variant_.deviceuiconfig_);
        }
        break;
      }
      case PAYLOAD_VARIANT_NOT_SET:
        break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void FromRadio::CopyFrom(const FromRadio& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.FromRadio)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void FromRadio::InternalSwap(FromRadio* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.id_, other->_impl_.id_);
  swap(_impl_.payload_variant_, other->_impl_.payload_variant_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::google::protobuf::Metadata FromRadio::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class ClientNotification::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<ClientNotification>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(ClientNotification, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::meshtastic::ClientNotification, _impl_._oneof_case_);
};

void ClientNotification::set_allocated_key_verification_number_inform(::meshtastic::KeyVerificationNumberInform* PROTOBUF_NULLABLE key_verification_number_inform) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_payload_variant();
  if (key_verification_number_inform) {
    ::google::protobuf::Arena* submessage_arena = key_verification_number_inform->GetArena();
    if (message_arena != submessage_arena) {
      key_verification_number_inform = ::google::protobuf::internal::GetOwnedMessage(message_arena, key_verification_number_inform, submessage_arena);
    }
    set_has_key_verification_number_inform();
    _impl_.payload_variant_.key_verification_number_inform_ = key_verification_number_inform;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.ClientNotification.key_verification_number_inform)
}
void ClientNotification::set_allocated_key_verification_number_request(::meshtastic::KeyVerificationNumberRequest* PROTOBUF_NULLABLE key_verification_number_request) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_payload_variant();
  if (key_verification_number_request) {
    ::google::protobuf::Arena* submessage_arena = key_verification_number_request->GetArena();
    if (message_arena != submessage_arena) {
      key_verification_number_request = ::google::protobuf::internal::GetOwnedMessage(message_arena, key_verification_number_request, submessage_arena);
    }
    set_has_key_verification_number_request();
    _impl_.payload_variant_.key_verification_number_request_ = key_verification_number_request;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.ClientNotification.key_verification_number_request)
}
void ClientNotification::set_allocated_key_verification_final(::meshtastic::KeyVerificationFinal* PROTOBUF_NULLABLE key_verification_final) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_payload_variant();
  if (key_verification_final) {
    ::google::protobuf::Arena* submessage_arena = key_verification_final->GetArena();
    if (message_arena != submessage_arena) {
      key_verification_final = ::google::protobuf::internal::GetOwnedMessage(message_arena, key_verification_final, submessage_arena);
    }
    set_has_key_verification_final();
    _impl_.payload_variant_.key_verification_final_ = key_verification_final;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.ClientNotification.key_verification_final)
}
void ClientNotification::set_allocated_duplicated_public_key(::meshtastic::DuplicatedPublicKey* PROTOBUF_NULLABLE duplicated_public_key) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_payload_variant();
  if (duplicated_public_key) {
    ::google::protobuf::Arena* submessage_arena = duplicated_public_key->GetArena();
    if (message_arena != submessage_arena) {
      duplicated_public_key = ::google::protobuf::internal::GetOwnedMessage(message_arena, duplicated_public_key, submessage_arena);
    }
    set_has_duplicated_public_key();
    _impl_.payload_variant_.duplicated_public_key_ = duplicated_public_key;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.ClientNotification.duplicated_public_key)
}
void ClientNotification::set_allocated_low_entropy_key(::meshtastic::LowEntropyKey* PROTOBUF_NULLABLE low_entropy_key) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_payload_variant();
  if (low_entropy_key) {
    ::google::protobuf::Arena* submessage_arena = low_entropy_key->GetArena();
    if (message_arena != submessage_arena) {
      low_entropy_key = ::google::protobuf::internal::GetOwnedMessage(message_arena, low_entropy_key, submessage_arena);
    }
    set_has_low_entropy_key();
    _impl_.payload_variant_.low_entropy_key_ = low_entropy_key;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.ClientNotification.low_entropy_key)
}
ClientNotification::ClientNotification(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ClientNotification_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:meshtastic.ClientNotification)
}
PROTOBUF_NDEBUG_INLINE ClientNotification::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::meshtastic::ClientNotification& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        message_(arena, from.message_),
        payload_variant_{},
        _oneof_case_{from._oneof_case_[0]} {}

ClientNotification::ClientNotification(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const ClientNotification& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ClientNotification_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  ClientNotification* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, reply_id_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, reply_id_),
           offsetof(Impl_, level_) -
               offsetof(Impl_, reply_id_) +
               sizeof(Impl_::level_));
  switch (payload_variant_case()) {
    case PAYLOAD_VARIANT_NOT_SET:
      break;
      case kKeyVerificationNumberInform:
        _impl_.payload_variant_.key_verification_number_inform_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.key_verification_number_inform_);
        break;
      case kKeyVerificationNumberRequest:
        _impl_.payload_variant_.key_verification_number_request_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.key_verification_number_request_);
        break;
      case kKeyVerificationFinal:
        _impl_.payload_variant_.key_verification_final_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.key_verification_final_);
        break;
      case kDuplicatedPublicKey:
        _impl_.payload_variant_.duplicated_public_key_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.duplicated_public_key_);
        break;
      case kLowEntropyKey:
        _impl_.payload_variant_.low_entropy_key_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.low_entropy_key_);
        break;
  }

  // @@protoc_insertion_point(copy_constructor:meshtastic.ClientNotification)
}
PROTOBUF_NDEBUG_INLINE ClientNotification::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        message_(arena),
        payload_variant_{},
        _oneof_case_{} {}

inline void ClientNotification::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, reply_id_),
           0,
           offsetof(Impl_, level_) -
               offsetof(Impl_, reply_id_) +
               sizeof(Impl_::level_));
}
ClientNotification::~ClientNotification() {
  // @@protoc_insertion_point(destructor:meshtastic.ClientNotification)
  SharedDtor(*this);
}
inline void ClientNotification::SharedDtor(MessageLite& self) {
  ClientNotification& this_ = static_cast<ClientNotification&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.message_.Destroy();
  if (this_.has_payload_variant()) {
    this_.clear_payload_variant();
  }
  this_._impl_.~Impl_();
}

void ClientNotification::clear_payload_variant() {
// @@protoc_insertion_point(one_of_clear_start:meshtastic.ClientNotification)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (payload_variant_case()) {
    case kKeyVerificationNumberInform: {
      if (GetArena() == nullptr) {
        delete _impl_.payload_variant_.key_verification_number_inform_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.key_verification_number_inform_);
      }
      break;
    }
    case kKeyVerificationNumberRequest: {
      if (GetArena() == nullptr) {
        delete _impl_.payload_variant_.key_verification_number_request_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.key_verification_number_request_);
      }
      break;
    }
    case kKeyVerificationFinal: {
      if (GetArena() == nullptr) {
        delete _impl_.payload_variant_.key_verification_final_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.key_verification_final_);
      }
      break;
    }
    case kDuplicatedPublicKey: {
      if (GetArena() == nullptr) {
        delete _impl_.payload_variant_.duplicated_public_key_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.duplicated_public_key_);
      }
      break;
    }
    case kLowEntropyKey: {
      if (GetArena() == nullptr) {
        delete _impl_.payload_variant_.low_entropy_key_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.low_entropy_key_);
      }
      break;
    }
    case PAYLOAD_VARIANT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = PAYLOAD_VARIANT_NOT_SET;
}


inline void* PROTOBUF_NONNULL ClientNotification::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) ClientNotification(arena);
}
constexpr auto ClientNotification::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(ClientNotification),
                                            alignof(ClientNotification));
}
constexpr auto ClientNotification::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_ClientNotification_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &ClientNotification::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<ClientNotification>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &ClientNotification::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<ClientNotification>(), &ClientNotification::ByteSizeLong,
              &ClientNotification::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(ClientNotification, _impl_._cached_size_),
          false,
      },
      &ClientNotification::kDescriptorMethods,
      &descriptor_table_meshtastic_2fmesh_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull ClientNotification_class_data_ =
        ClientNotification::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
ClientNotification::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&ClientNotification_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(ClientNotification_class_data_.tc_table);
  return ClientNotification_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 9, 5, 53, 2>
ClientNotification::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(ClientNotification, _impl_._has_bits_),
    0, // no _extensions_
    15, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294935536,  // skipmap
    offsetof(decltype(_table_), field_entries),
    9,  // num_field_entries
    5,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    ClientNotification_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::meshtastic::ClientNotification>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // string message = 4;
    {::_pbi::TcParser::FastUS1,
     {34, 0, 0, PROTOBUF_FIELD_OFFSET(ClientNotification, _impl_.message_)}},
    // optional uint32 reply_id = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ClientNotification, _impl_.reply_id_), 1>(),
     {8, 1, 0, PROTOBUF_FIELD_OFFSET(ClientNotification, _impl_.reply_id_)}},
    // fixed32 time = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 2, 0, PROTOBUF_FIELD_OFFSET(ClientNotification, _impl_.time_)}},
    // .meshtastic.LogRecord.Level level = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ClientNotification, _impl_.level_), 3>(),
     {24, 3, 0, PROTOBUF_FIELD_OFFSET(ClientNotification, _impl_.level_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional uint32 reply_id = 1;
    {PROTOBUF_FIELD_OFFSET(ClientNotification, _impl_.reply_id_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // fixed32 time = 2;
    {PROTOBUF_FIELD_OFFSET(ClientNotification, _impl_.time_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFixed32)},
    // .meshtastic.LogRecord.Level level = 3;
    {PROTOBUF_FIELD_OFFSET(ClientNotification, _impl_.level_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kOpenEnum)},
    // string message = 4;
    {PROTOBUF_FIELD_OFFSET(ClientNotification, _impl_.message_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .meshtastic.KeyVerificationNumberInform key_verification_number_inform = 11;
    {PROTOBUF_FIELD_OFFSET(ClientNotification, _impl_.payload_variant_.key_verification_number_inform_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .meshtastic.KeyVerificationNumberRequest key_verification_number_request = 12;
    {PROTOBUF_FIELD_OFFSET(ClientNotification, _impl_.payload_variant_.key_verification_number_request_), _Internal::kOneofCaseOffset + 0, 1,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .meshtastic.KeyVerificationFinal key_verification_final = 13;
    {PROTOBUF_FIELD_OFFSET(ClientNotification, _impl_.payload_variant_.key_verification_final_), _Internal::kOneofCaseOffset + 0, 2,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .meshtastic.DuplicatedPublicKey duplicated_public_key = 14;
    {PROTOBUF_FIELD_OFFSET(ClientNotification, _impl_.payload_variant_.duplicated_public_key_), _Internal::kOneofCaseOffset + 0, 3,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .meshtastic.LowEntropyKey low_entropy_key = 15;
    {PROTOBUF_FIELD_OFFSET(ClientNotification, _impl_.payload_variant_.low_entropy_key_), _Internal::kOneofCaseOffset + 0, 4,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::meshtastic::KeyVerificationNumberInform>()},
      {::_pbi::TcParser::GetTable<::meshtastic::KeyVerificationNumberRequest>()},
      {::_pbi::TcParser::GetTable<::meshtastic::KeyVerificationFinal>()},
      {::_pbi::TcParser::GetTable<::meshtastic::DuplicatedPublicKey>()},
      {::_pbi::TcParser::GetTable<::meshtastic::LowEntropyKey>()},
  }},
  {{
    "\35\0\0\0\7\0\0\0\0\0\0\0\0\0\0\0"
    "meshtastic.ClientNotification"
    "message"
  }},
};
PROTOBUF_NOINLINE void ClientNotification::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.ClientNotification)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    _impl_.message_.ClearNonDefaultToEmpty();
  }
  if ((cached_has_bits & 0x0000000eu) != 0) {
    ::memset(&_impl_.reply_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.level_) -
        reinterpret_cast<char*>(&_impl_.reply_id_)) + sizeof(_impl_.level_));
  }
  clear_payload_variant();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL ClientNotification::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const ClientNotification& this_ = static_cast<const ClientNotification&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL ClientNotification::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const ClientNotification& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.ClientNotification)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional uint32 reply_id = 1;
  if ((cached_has_bits & 0x00000002u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this_._internal_reply_id(), target);
  }

  // fixed32 time = 2;
  if ((cached_has_bits & 0x00000004u) != 0) {
    if (this_._internal_time() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
          2, this_._internal_time(), target);
    }
  }

  // .meshtastic.LogRecord.Level level = 3;
  if ((cached_has_bits & 0x00000008u) != 0) {
    if (this_._internal_level() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          3, this_._internal_level(), target);
    }
  }

  // string message = 4;
  if ((cached_has_bits & 0x00000001u) != 0) {
    if (!this_._internal_message().empty()) {
      const ::std::string& _s = this_._internal_message();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "meshtastic.ClientNotification.message");
      target = stream->WriteStringMaybeAliased(4, _s, target);
    }
  }

  switch (this_.payload_variant_case()) {
    case kKeyVerificationNumberInform: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          11, *this_._impl_.payload_variant_.key_verification_number_inform_, this_._impl_.payload_variant_.key_verification_number_inform_->GetCachedSize(), target,
          stream);
      break;
    }
    case kKeyVerificationNumberRequest: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          12, *this_._impl_.payload_variant_.key_verification_number_request_, this_._impl_.payload_variant_.key_verification_number_request_->GetCachedSize(), target,
          stream);
      break;
    }
    case kKeyVerificationFinal: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          13, *this_._impl_.payload_variant_.key_verification_final_, this_._impl_.payload_variant_.key_verification_final_->GetCachedSize(), target,
          stream);
      break;
    }
    case kDuplicatedPublicKey: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          14, *this_._impl_.payload_variant_.duplicated_public_key_, this_._impl_.payload_variant_.duplicated_public_key_->GetCachedSize(), target,
          stream);
      break;
    }
    case kLowEntropyKey: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          15, *this_._impl_.payload_variant_.low_entropy_key_, this_._impl_.payload_variant_.low_entropy_key_->GetCachedSize(), target,
          stream);
      break;
    }
    default:
      break;
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.ClientNotification)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t ClientNotification::ByteSizeLong(const MessageLite& base) {
  const ClientNotification& this_ = static_cast<const ClientNotification&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t ClientNotification::ByteSizeLong() const {
  const ClientNotification& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:meshtastic.ClientNotification)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000000fu) != 0) {
    // string message = 4;
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (!this_._internal_message().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_message());
      }
    }
    // optional uint32 reply_id = 1;
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_reply_id());
    }
    // fixed32 time = 2;
    if ((cached_has_bits & 0x00000004u) != 0) {
      if (this_._internal_time() != 0) {
        total_size += 5;
      }
    }
    // .meshtastic.LogRecord.Level level = 3;
    if ((cached_has_bits & 0x00000008u) != 0) {
      if (this_._internal_level() != 0) {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this_._internal_level());
      }
    }
  }
  switch (this_.payload_variant_case()) {
    // .meshtastic.KeyVerificationNumberInform key_verification_number_inform = 11;
    case kKeyVerificationNumberInform: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.payload_variant_.key_verification_number_inform_);
      break;
    }
    // .meshtastic.KeyVerificationNumberRequest key_verification_number_request = 12;
    case kKeyVerificationNumberRequest: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.payload_variant_.key_verification_number_request_);
      break;
    }
    // .meshtastic.KeyVerificationFinal key_verification_final = 13;
    case kKeyVerificationFinal: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.payload_variant_.key_verification_final_);
      break;
    }
    // .meshtastic.DuplicatedPublicKey duplicated_public_key = 14;
    case kDuplicatedPublicKey: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.payload_variant_.duplicated_public_key_);
      break;
    }
    // .meshtastic.LowEntropyKey low_entropy_key = 15;
    case kLowEntropyKey: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.payload_variant_.low_entropy_key_);
      break;
    }
    case PAYLOAD_VARIANT_NOT_SET: {
      break;
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void ClientNotification::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<ClientNotification*>(&to_msg);
  auto& from = static_cast<const ClientNotification&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.ClientNotification)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000000fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (!from._internal_message().empty()) {
        _this->_internal_set_message(from._internal_message());
      } else {
        if (_this->_impl_.message_.IsDefault()) {
          _this->_internal_set_message("");
        }
      }
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _this->_impl_.reply_id_ = from._impl_.reply_id_;
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      if (from._internal_time() != 0) {
        _this->_impl_.time_ = from._impl_.time_;
      }
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      if (from._internal_level() != 0) {
        _this->_impl_.level_ = from._impl_.level_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_payload_variant();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kKeyVerificationNumberInform: {
        if (oneof_needs_init) {
          _this->_impl_.payload_variant_.key_verification_number_inform_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.key_verification_number_inform_);
        } else {
          _this->_impl_.payload_variant_.key_verification_number_inform_->MergeFrom(*from._impl_.payload_variant_.key_verification_number_inform_);
        }
        break;
      }
      case kKeyVerificationNumberRequest: {
        if (oneof_needs_init) {
          _this->_impl_.payload_variant_.key_verification_number_request_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.key_verification_number_request_);
        } else {
          _this->_impl_.payload_variant_.key_verification_number_request_->MergeFrom(*from._impl_.payload_variant_.key_verification_number_request_);
        }
        break;
      }
      case kKeyVerificationFinal: {
        if (oneof_needs_init) {
          _this->_impl_.payload_variant_.key_verification_final_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.key_verification_final_);
        } else {
          _this->_impl_.payload_variant_.key_verification_final_->MergeFrom(*from._impl_.payload_variant_.key_verification_final_);
        }
        break;
      }
      case kDuplicatedPublicKey: {
        if (oneof_needs_init) {
          _this->_impl_.payload_variant_.duplicated_public_key_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.duplicated_public_key_);
        } else {
          _this->_impl_.payload_variant_.duplicated_public_key_->MergeFrom(*from._impl_.payload_variant_.duplicated_public_key_);
        }
        break;
      }
      case kLowEntropyKey: {
        if (oneof_needs_init) {
          _this->_impl_.payload_variant_.low_entropy_key_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.low_entropy_key_);
        } else {
          _this->_impl_.payload_variant_.low_entropy_key_->MergeFrom(*from._impl_.payload_variant_.low_entropy_key_);
        }
        break;
      }
      case PAYLOAD_VARIANT_NOT_SET:
        break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void ClientNotification::CopyFrom(const ClientNotification& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.ClientNotification)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void ClientNotification::InternalSwap(ClientNotification* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.message_, &other->_impl_.message_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ClientNotification, _impl_.level_)
      + sizeof(ClientNotification::_impl_.level_)
      - PROTOBUF_FIELD_OFFSET(ClientNotification, _impl_.reply_id_)>(
          reinterpret_cast<char*>(&_impl_.reply_id_),
          reinterpret_cast<char*>(&other->_impl_.reply_id_));
  swap(_impl_.payload_variant_, other->_impl_.payload_variant_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::google::protobuf::Metadata ClientNotification::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class KeyVerificationNumberInform::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<KeyVerificationNumberInform>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(KeyVerificationNumberInform, _impl_._has_bits_);
};

KeyVerificationNumberInform::KeyVerificationNumberInform(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, KeyVerificationNumberInform_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:meshtastic.KeyVerificationNumberInform)
}
PROTOBUF_NDEBUG_INLINE KeyVerificationNumberInform::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::meshtastic::KeyVerificationNumberInform& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        remote_longname_(arena, from.remote_longname_) {}

KeyVerificationNumberInform::KeyVerificationNumberInform(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const KeyVerificationNumberInform& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, KeyVerificationNumberInform_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  KeyVerificationNumberInform* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, nonce_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, nonce_),
           offsetof(Impl_, security_number_) -
               offsetof(Impl_, nonce_) +
               sizeof(Impl_::security_number_));

  // @@protoc_insertion_point(copy_constructor:meshtastic.KeyVerificationNumberInform)
}
PROTOBUF_NDEBUG_INLINE KeyVerificationNumberInform::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        remote_longname_(arena) {}

inline void KeyVerificationNumberInform::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, nonce_),
           0,
           offsetof(Impl_, security_number_) -
               offsetof(Impl_, nonce_) +
               sizeof(Impl_::security_number_));
}
KeyVerificationNumberInform::~KeyVerificationNumberInform() {
  // @@protoc_insertion_point(destructor:meshtastic.KeyVerificationNumberInform)
  SharedDtor(*this);
}
inline void KeyVerificationNumberInform::SharedDtor(MessageLite& self) {
  KeyVerificationNumberInform& this_ = static_cast<KeyVerificationNumberInform&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.remote_longname_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL KeyVerificationNumberInform::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) KeyVerificationNumberInform(arena);
}
constexpr auto KeyVerificationNumberInform::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(KeyVerificationNumberInform),
                                            alignof(KeyVerificationNumberInform));
}
constexpr auto KeyVerificationNumberInform::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_KeyVerificationNumberInform_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &KeyVerificationNumberInform::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<KeyVerificationNumberInform>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &KeyVerificationNumberInform::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<KeyVerificationNumberInform>(), &KeyVerificationNumberInform::ByteSizeLong,
              &KeyVerificationNumberInform::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(KeyVerificationNumberInform, _impl_._cached_size_),
          false,
      },
      &KeyVerificationNumberInform::kDescriptorMethods,
      &descriptor_table_meshtastic_2fmesh_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull KeyVerificationNumberInform_class_data_ =
        KeyVerificationNumberInform::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
KeyVerificationNumberInform::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&KeyVerificationNumberInform_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(KeyVerificationNumberInform_class_data_.tc_table);
  return KeyVerificationNumberInform_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 62, 2>
KeyVerificationNumberInform::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(KeyVerificationNumberInform, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    KeyVerificationNumberInform_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::meshtastic::KeyVerificationNumberInform>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // uint64 nonce = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(KeyVerificationNumberInform, _impl_.nonce_), 1>(),
     {8, 1, 0, PROTOBUF_FIELD_OFFSET(KeyVerificationNumberInform, _impl_.nonce_)}},
    // string remote_longname = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(KeyVerificationNumberInform, _impl_.remote_longname_)}},
    // uint32 security_number = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(KeyVerificationNumberInform, _impl_.security_number_), 2>(),
     {24, 2, 0, PROTOBUF_FIELD_OFFSET(KeyVerificationNumberInform, _impl_.security_number_)}},
  }}, {{
    65535, 65535
  }}, {{
    // uint64 nonce = 1;
    {PROTOBUF_FIELD_OFFSET(KeyVerificationNumberInform, _impl_.nonce_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // string remote_longname = 2;
    {PROTOBUF_FIELD_OFFSET(KeyVerificationNumberInform, _impl_.remote_longname_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // uint32 security_number = 3;
    {PROTOBUF_FIELD_OFFSET(KeyVerificationNumberInform, _impl_.security_number_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
  }},
  // no aux_entries
  {{
    "\46\0\17\0\0\0\0\0"
    "meshtastic.KeyVerificationNumberInform"
    "remote_longname"
  }},
};
PROTOBUF_NOINLINE void KeyVerificationNumberInform::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.KeyVerificationNumberInform)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    _impl_.remote_longname_.ClearNonDefaultToEmpty();
  }
  if ((cached_has_bits & 0x00000006u) != 0) {
    ::memset(&_impl_.nonce_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.security_number_) -
        reinterpret_cast<char*>(&_impl_.nonce_)) + sizeof(_impl_.security_number_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL KeyVerificationNumberInform::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const KeyVerificationNumberInform& this_ = static_cast<const KeyVerificationNumberInform&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL KeyVerificationNumberInform::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const KeyVerificationNumberInform& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.KeyVerificationNumberInform)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // uint64 nonce = 1;
  if ((this_._impl_._has_bits_[0] & 0x00000002u) != 0) {
    if (this_._internal_nonce() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
          1, this_._internal_nonce(), target);
    }
  }

  // string remote_longname = 2;
  if ((this_._impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (!this_._internal_remote_longname().empty()) {
      const ::std::string& _s = this_._internal_remote_longname();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "meshtastic.KeyVerificationNumberInform.remote_longname");
      target = stream->WriteStringMaybeAliased(2, _s, target);
    }
  }

  // uint32 security_number = 3;
  if ((this_._impl_._has_bits_[0] & 0x00000004u) != 0) {
    if (this_._internal_security_number() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          3, this_._internal_security_number(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.KeyVerificationNumberInform)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t KeyVerificationNumberInform::ByteSizeLong(const MessageLite& base) {
  const KeyVerificationNumberInform& this_ = static_cast<const KeyVerificationNumberInform&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t KeyVerificationNumberInform::ByteSizeLong() const {
  const KeyVerificationNumberInform& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:meshtastic.KeyVerificationNumberInform)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    // string remote_longname = 2;
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (!this_._internal_remote_longname().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_remote_longname());
      }
    }
    // uint64 nonce = 1;
    if ((cached_has_bits & 0x00000002u) != 0) {
      if (this_._internal_nonce() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
            this_._internal_nonce());
      }
    }
    // uint32 security_number = 3;
    if ((cached_has_bits & 0x00000004u) != 0) {
      if (this_._internal_security_number() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
            this_._internal_security_number());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void KeyVerificationNumberInform::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<KeyVerificationNumberInform*>(&to_msg);
  auto& from = static_cast<const KeyVerificationNumberInform&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.KeyVerificationNumberInform)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (!from._internal_remote_longname().empty()) {
        _this->_internal_set_remote_longname(from._internal_remote_longname());
      } else {
        if (_this->_impl_.remote_longname_.IsDefault()) {
          _this->_internal_set_remote_longname("");
        }
      }
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      if (from._internal_nonce() != 0) {
        _this->_impl_.nonce_ = from._impl_.nonce_;
      }
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      if (from._internal_security_number() != 0) {
        _this->_impl_.security_number_ = from._impl_.security_number_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void KeyVerificationNumberInform::CopyFrom(const KeyVerificationNumberInform& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.KeyVerificationNumberInform)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void KeyVerificationNumberInform::InternalSwap(KeyVerificationNumberInform* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.remote_longname_, &other->_impl_.remote_longname_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KeyVerificationNumberInform, _impl_.security_number_)
      + sizeof(KeyVerificationNumberInform::_impl_.security_number_)
      - PROTOBUF_FIELD_OFFSET(KeyVerificationNumberInform, _impl_.nonce_)>(
          reinterpret_cast<char*>(&_impl_.nonce_),
          reinterpret_cast<char*>(&other->_impl_.nonce_));
}

::google::protobuf::Metadata KeyVerificationNumberInform::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class KeyVerificationNumberRequest::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<KeyVerificationNumberRequest>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(KeyVerificationNumberRequest, _impl_._has_bits_);
};

KeyVerificationNumberRequest::KeyVerificationNumberRequest(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, KeyVerificationNumberRequest_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:meshtastic.KeyVerificationNumberRequest)
}
PROTOBUF_NDEBUG_INLINE KeyVerificationNumberRequest::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::meshtastic::KeyVerificationNumberRequest& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        remote_longname_(arena, from.remote_longname_) {}

KeyVerificationNumberRequest::KeyVerificationNumberRequest(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const KeyVerificationNumberRequest& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, KeyVerificationNumberRequest_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  KeyVerificationNumberRequest* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.nonce_ = from._impl_.nonce_;

  // @@protoc_insertion_point(copy_constructor:meshtastic.KeyVerificationNumberRequest)
}
PROTOBUF_NDEBUG_INLINE KeyVerificationNumberRequest::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        remote_longname_(arena) {}

inline void KeyVerificationNumberRequest::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.nonce_ = {};
}
KeyVerificationNumberRequest::~KeyVerificationNumberRequest() {
  // @@protoc_insertion_point(destructor:meshtastic.KeyVerificationNumberRequest)
  SharedDtor(*this);
}
inline void KeyVerificationNumberRequest::SharedDtor(MessageLite& self) {
  KeyVerificationNumberRequest& this_ = static_cast<KeyVerificationNumberRequest&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.remote_longname_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL KeyVerificationNumberRequest::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) KeyVerificationNumberRequest(arena);
}
constexpr auto KeyVerificationNumberRequest::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(KeyVerificationNumberRequest),
                                            alignof(KeyVerificationNumberRequest));
}
constexpr auto KeyVerificationNumberRequest::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_KeyVerificationNumberRequest_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &KeyVerificationNumberRequest::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<KeyVerificationNumberRequest>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &KeyVerificationNumberRequest::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<KeyVerificationNumberRequest>(), &KeyVerificationNumberRequest::ByteSizeLong,
              &KeyVerificationNumberRequest::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(KeyVerificationNumberRequest, _impl_._cached_size_),
          false,
      },
      &KeyVerificationNumberRequest::kDescriptorMethods,
      &descriptor_table_meshtastic_2fmesh_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull KeyVerificationNumberRequest_class_data_ =
        KeyVerificationNumberRequest::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
KeyVerificationNumberRequest::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&KeyVerificationNumberRequest_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(KeyVerificationNumberRequest_class_data_.tc_table);
  return KeyVerificationNumberRequest_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 63, 2>
KeyVerificationNumberRequest::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(KeyVerificationNumberRequest, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    KeyVerificationNumberRequest_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::meshtastic::KeyVerificationNumberRequest>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // string remote_longname = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(KeyVerificationNumberRequest, _impl_.remote_longname_)}},
    // uint64 nonce = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(KeyVerificationNumberRequest, _impl_.nonce_), 1>(),
     {8, 1, 0, PROTOBUF_FIELD_OFFSET(KeyVerificationNumberRequest, _impl_.nonce_)}},
  }}, {{
    65535, 65535
  }}, {{
    // uint64 nonce = 1;
    {PROTOBUF_FIELD_OFFSET(KeyVerificationNumberRequest, _impl_.nonce_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // string remote_longname = 2;
    {PROTOBUF_FIELD_OFFSET(KeyVerificationNumberRequest, _impl_.remote_longname_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\47\0\17\0\0\0\0\0"
    "meshtastic.KeyVerificationNumberRequest"
    "remote_longname"
  }},
};
PROTOBUF_NOINLINE void KeyVerificationNumberRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.KeyVerificationNumberRequest)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    _impl_.remote_longname_.ClearNonDefaultToEmpty();
  }
  _impl_.nonce_ = ::uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL KeyVerificationNumberRequest::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const KeyVerificationNumberRequest& this_ = static_cast<const KeyVerificationNumberRequest&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL KeyVerificationNumberRequest::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const KeyVerificationNumberRequest& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.KeyVerificationNumberRequest)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // uint64 nonce = 1;
  if ((this_._impl_._has_bits_[0] & 0x00000002u) != 0) {
    if (this_._internal_nonce() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
          1, this_._internal_nonce(), target);
    }
  }

  // string remote_longname = 2;
  if ((this_._impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (!this_._internal_remote_longname().empty()) {
      const ::std::string& _s = this_._internal_remote_longname();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "meshtastic.KeyVerificationNumberRequest.remote_longname");
      target = stream->WriteStringMaybeAliased(2, _s, target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.KeyVerificationNumberRequest)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t KeyVerificationNumberRequest::ByteSizeLong(const MessageLite& base) {
  const KeyVerificationNumberRequest& this_ = static_cast<const KeyVerificationNumberRequest&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t KeyVerificationNumberRequest::ByteSizeLong() const {
  const KeyVerificationNumberRequest& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:meshtastic.KeyVerificationNumberRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    // string remote_longname = 2;
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (!this_._internal_remote_longname().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_remote_longname());
      }
    }
    // uint64 nonce = 1;
    if ((cached_has_bits & 0x00000002u) != 0) {
      if (this_._internal_nonce() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
            this_._internal_nonce());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void KeyVerificationNumberRequest::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<KeyVerificationNumberRequest*>(&to_msg);
  auto& from = static_cast<const KeyVerificationNumberRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.KeyVerificationNumberRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (!from._internal_remote_longname().empty()) {
        _this->_internal_set_remote_longname(from._internal_remote_longname());
      } else {
        if (_this->_impl_.remote_longname_.IsDefault()) {
          _this->_internal_set_remote_longname("");
        }
      }
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      if (from._internal_nonce() != 0) {
        _this->_impl_.nonce_ = from._impl_.nonce_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void KeyVerificationNumberRequest::CopyFrom(const KeyVerificationNumberRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.KeyVerificationNumberRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void KeyVerificationNumberRequest::InternalSwap(KeyVerificationNumberRequest* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.remote_longname_, &other->_impl_.remote_longname_, arena);
  swap(_impl_.nonce_, other->_impl_.nonce_);
}

::google::protobuf::Metadata KeyVerificationNumberRequest::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class KeyVerificationFinal::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<KeyVerificationFinal>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(KeyVerificationFinal, _impl_._has_bits_);
};

KeyVerificationFinal::KeyVerificationFinal(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, KeyVerificationFinal_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:meshtastic.KeyVerificationFinal)
}
PROTOBUF_NDEBUG_INLINE KeyVerificationFinal::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::meshtastic::KeyVerificationFinal& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        remote_longname_(arena, from.remote_longname_),
        verification_characters_(arena, from.verification_characters_) {}

KeyVerificationFinal::KeyVerificationFinal(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const KeyVerificationFinal& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, KeyVerificationFinal_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  KeyVerificationFinal* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, nonce_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, nonce_),
           offsetof(Impl_, issender_) -
               offsetof(Impl_, nonce_) +
               sizeof(Impl_::issender_));

  // @@protoc_insertion_point(copy_constructor:meshtastic.KeyVerificationFinal)
}
PROTOBUF_NDEBUG_INLINE KeyVerificationFinal::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        remote_longname_(arena),
        verification_characters_(arena) {}

inline void KeyVerificationFinal::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, nonce_),
           0,
           offsetof(Impl_, issender_) -
               offsetof(Impl_, nonce_) +
               sizeof(Impl_::issender_));
}
KeyVerificationFinal::~KeyVerificationFinal() {
  // @@protoc_insertion_point(destructor:meshtastic.KeyVerificationFinal)
  SharedDtor(*this);
}
inline void KeyVerificationFinal::SharedDtor(MessageLite& self) {
  KeyVerificationFinal& this_ = static_cast<KeyVerificationFinal&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.remote_longname_.Destroy();
  this_._impl_.verification_characters_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL KeyVerificationFinal::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) KeyVerificationFinal(arena);
}
constexpr auto KeyVerificationFinal::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(KeyVerificationFinal),
                                            alignof(KeyVerificationFinal));
}
constexpr auto KeyVerificationFinal::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_KeyVerificationFinal_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &KeyVerificationFinal::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<KeyVerificationFinal>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &KeyVerificationFinal::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<KeyVerificationFinal>(), &KeyVerificationFinal::ByteSizeLong,
              &KeyVerificationFinal::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(KeyVerificationFinal, _impl_._cached_size_),
          false,
      },
      &KeyVerificationFinal::kDescriptorMethods,
      &descriptor_table_meshtastic_2fmesh_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull KeyVerificationFinal_class_data_ =
        KeyVerificationFinal::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
KeyVerificationFinal::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&KeyVerificationFinal_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(KeyVerificationFinal_class_data_.tc_table);
  return KeyVerificationFinal_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 78, 2>
KeyVerificationFinal::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(KeyVerificationFinal, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    KeyVerificationFinal_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::meshtastic::KeyVerificationFinal>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // string verification_characters = 4;
    {::_pbi::TcParser::FastUS1,
     {34, 1, 0, PROTOBUF_FIELD_OFFSET(KeyVerificationFinal, _impl_.verification_characters_)}},
    // uint64 nonce = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(KeyVerificationFinal, _impl_.nonce_), 2>(),
     {8, 2, 0, PROTOBUF_FIELD_OFFSET(KeyVerificationFinal, _impl_.nonce_)}},
    // string remote_longname = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(KeyVerificationFinal, _impl_.remote_longname_)}},
    // bool isSender = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(KeyVerificationFinal, _impl_.issender_), 3>(),
     {24, 3, 0, PROTOBUF_FIELD_OFFSET(KeyVerificationFinal, _impl_.issender_)}},
  }}, {{
    65535, 65535
  }}, {{
    // uint64 nonce = 1;
    {PROTOBUF_FIELD_OFFSET(KeyVerificationFinal, _impl_.nonce_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // string remote_longname = 2;
    {PROTOBUF_FIELD_OFFSET(KeyVerificationFinal, _impl_.remote_longname_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // bool isSender = 3;
    {PROTOBUF_FIELD_OFFSET(KeyVerificationFinal, _impl_.issender_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // string verification_characters = 4;
    {PROTOBUF_FIELD_OFFSET(KeyVerificationFinal, _impl_.verification_characters_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\37\0\17\0\27\0\0\0"
    "meshtastic.KeyVerificationFinal"
    "remote_longname"
    "verification_characters"
  }},
};
PROTOBUF_NOINLINE void KeyVerificationFinal::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.KeyVerificationFinal)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _impl_.remote_longname_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _impl_.verification_characters_.ClearNonDefaultToEmpty();
    }
  }
  if ((cached_has_bits & 0x0000000cu) != 0) {
    ::memset(&_impl_.nonce_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.issender_) -
        reinterpret_cast<char*>(&_impl_.nonce_)) + sizeof(_impl_.issender_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL KeyVerificationFinal::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const KeyVerificationFinal& this_ = static_cast<const KeyVerificationFinal&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL KeyVerificationFinal::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const KeyVerificationFinal& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.KeyVerificationFinal)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // uint64 nonce = 1;
  if ((this_._impl_._has_bits_[0] & 0x00000004u) != 0) {
    if (this_._internal_nonce() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
          1, this_._internal_nonce(), target);
    }
  }

  // string remote_longname = 2;
  if ((this_._impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (!this_._internal_remote_longname().empty()) {
      const ::std::string& _s = this_._internal_remote_longname();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "meshtastic.KeyVerificationFinal.remote_longname");
      target = stream->WriteStringMaybeAliased(2, _s, target);
    }
  }

  // bool isSender = 3;
  if ((this_._impl_._has_bits_[0] & 0x00000008u) != 0) {
    if (this_._internal_issender() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          3, this_._internal_issender(), target);
    }
  }

  // string verification_characters = 4;
  if ((this_._impl_._has_bits_[0] & 0x00000002u) != 0) {
    if (!this_._internal_verification_characters().empty()) {
      const ::std::string& _s = this_._internal_verification_characters();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "meshtastic.KeyVerificationFinal.verification_characters");
      target = stream->WriteStringMaybeAliased(4, _s, target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.KeyVerificationFinal)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t KeyVerificationFinal::ByteSizeLong(const MessageLite& base) {
  const KeyVerificationFinal& this_ = static_cast<const KeyVerificationFinal&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t KeyVerificationFinal::ByteSizeLong() const {
  const KeyVerificationFinal& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:meshtastic.KeyVerificationFinal)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000000fu) != 0) {
    // string remote_longname = 2;
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (!this_._internal_remote_longname().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_remote_longname());
      }
    }
    // string verification_characters = 4;
    if ((cached_has_bits & 0x00000002u) != 0) {
      if (!this_._internal_verification_characters().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_verification_characters());
      }
    }
    // uint64 nonce = 1;
    if ((cached_has_bits & 0x00000004u) != 0) {
      if (this_._internal_nonce() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
            this_._internal_nonce());
      }
    }
    // bool isSender = 3;
    if ((cached_has_bits & 0x00000008u) != 0) {
      if (this_._internal_issender() != 0) {
        total_size += 2;
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void KeyVerificationFinal::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<KeyVerificationFinal*>(&to_msg);
  auto& from = static_cast<const KeyVerificationFinal&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.KeyVerificationFinal)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000000fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (!from._internal_remote_longname().empty()) {
        _this->_internal_set_remote_longname(from._internal_remote_longname());
      } else {
        if (_this->_impl_.remote_longname_.IsDefault()) {
          _this->_internal_set_remote_longname("");
        }
      }
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      if (!from._internal_verification_characters().empty()) {
        _this->_internal_set_verification_characters(from._internal_verification_characters());
      } else {
        if (_this->_impl_.verification_characters_.IsDefault()) {
          _this->_internal_set_verification_characters("");
        }
      }
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      if (from._internal_nonce() != 0) {
        _this->_impl_.nonce_ = from._impl_.nonce_;
      }
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      if (from._internal_issender() != 0) {
        _this->_impl_.issender_ = from._impl_.issender_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void KeyVerificationFinal::CopyFrom(const KeyVerificationFinal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.KeyVerificationFinal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void KeyVerificationFinal::InternalSwap(KeyVerificationFinal* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.remote_longname_, &other->_impl_.remote_longname_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.verification_characters_, &other->_impl_.verification_characters_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KeyVerificationFinal, _impl_.issender_)
      + sizeof(KeyVerificationFinal::_impl_.issender_)
      - PROTOBUF_FIELD_OFFSET(KeyVerificationFinal, _impl_.nonce_)>(
          reinterpret_cast<char*>(&_impl_.nonce_),
          reinterpret_cast<char*>(&other->_impl_.nonce_));
}

::google::protobuf::Metadata KeyVerificationFinal::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class DuplicatedPublicKey::_Internal {
 public:
};

DuplicatedPublicKey::DuplicatedPublicKey(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::internal::ZeroFieldsBase(arena, DuplicatedPublicKey_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::internal::ZeroFieldsBase(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(arena_constructor:meshtastic.DuplicatedPublicKey)
}
DuplicatedPublicKey::DuplicatedPublicKey(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const DuplicatedPublicKey& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::internal::ZeroFieldsBase(arena, DuplicatedPublicKey_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::internal::ZeroFieldsBase(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  DuplicatedPublicKey* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);

  // @@protoc_insertion_point(copy_constructor:meshtastic.DuplicatedPublicKey)
}

inline void* PROTOBUF_NONNULL DuplicatedPublicKey::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) DuplicatedPublicKey(arena);
}
constexpr auto DuplicatedPublicKey::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(DuplicatedPublicKey),
                                            alignof(DuplicatedPublicKey));
}
constexpr auto DuplicatedPublicKey::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_DuplicatedPublicKey_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &DuplicatedPublicKey::MergeImpl,
          ::google::protobuf::internal::ZeroFieldsBase::GetNewImpl<DuplicatedPublicKey>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &DuplicatedPublicKey::SharedDtor,
          ::google::protobuf::internal::ZeroFieldsBase::GetClearImpl<DuplicatedPublicKey>(), &DuplicatedPublicKey::ByteSizeLong,
              &DuplicatedPublicKey::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(DuplicatedPublicKey, _impl_._cached_size_),
          false,
      },
      &DuplicatedPublicKey::kDescriptorMethods,
      &descriptor_table_meshtastic_2fmesh_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull DuplicatedPublicKey_class_data_ =
        DuplicatedPublicKey::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
DuplicatedPublicKey::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&DuplicatedPublicKey_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(DuplicatedPublicKey_class_data_.tc_table);
  return DuplicatedPublicKey_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 0, 0, 0, 2>
DuplicatedPublicKey::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    0, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967295,  // skipmap
    offsetof(decltype(_table_), field_names),  // no field_entries
    0,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    DuplicatedPublicKey_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::meshtastic::DuplicatedPublicKey>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, // no field_entries, or aux_entries
  {{
  }},
};







::google::protobuf::Metadata DuplicatedPublicKey::GetMetadata() const {
  return ::google::protobuf::internal::ZeroFieldsBase::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class LowEntropyKey::_Internal {
 public:
};

LowEntropyKey::LowEntropyKey(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::internal::ZeroFieldsBase(arena, LowEntropyKey_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::internal::ZeroFieldsBase(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(arena_constructor:meshtastic.LowEntropyKey)
}
LowEntropyKey::LowEntropyKey(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const LowEntropyKey& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::internal::ZeroFieldsBase(arena, LowEntropyKey_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::internal::ZeroFieldsBase(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  LowEntropyKey* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);

  // @@protoc_insertion_point(copy_constructor:meshtastic.LowEntropyKey)
}

inline void* PROTOBUF_NONNULL LowEntropyKey::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) LowEntropyKey(arena);
}
constexpr auto LowEntropyKey::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(LowEntropyKey),
                                            alignof(LowEntropyKey));
}
constexpr auto LowEntropyKey::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_LowEntropyKey_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &LowEntropyKey::MergeImpl,
          ::google::protobuf::internal::ZeroFieldsBase::GetNewImpl<LowEntropyKey>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &LowEntropyKey::SharedDtor,
          ::google::protobuf::internal::ZeroFieldsBase::GetClearImpl<LowEntropyKey>(), &LowEntropyKey::ByteSizeLong,
              &LowEntropyKey::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(LowEntropyKey, _impl_._cached_size_),
          false,
      },
      &LowEntropyKey::kDescriptorMethods,
      &descriptor_table_meshtastic_2fmesh_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull LowEntropyKey_class_data_ =
        LowEntropyKey::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
LowEntropyKey::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&LowEntropyKey_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(LowEntropyKey_class_data_.tc_table);
  return LowEntropyKey_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 0, 0, 0, 2>
LowEntropyKey::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    0, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967295,  // skipmap
    offsetof(decltype(_table_), field_names),  // no field_entries
    0,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    LowEntropyKey_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::meshtastic::LowEntropyKey>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, // no field_entries, or aux_entries
  {{
  }},
};







::google::protobuf::Metadata LowEntropyKey::GetMetadata() const {
  return ::google::protobuf::internal::ZeroFieldsBase::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class FileInfo::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<FileInfo>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(FileInfo, _impl_._has_bits_);
};

FileInfo::FileInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, FileInfo_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:meshtastic.FileInfo)
}
PROTOBUF_NDEBUG_INLINE FileInfo::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::meshtastic::FileInfo& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        file_name_(arena, from.file_name_) {}

FileInfo::FileInfo(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const FileInfo& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, FileInfo_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  FileInfo* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.size_bytes_ = from._impl_.size_bytes_;

  // @@protoc_insertion_point(copy_constructor:meshtastic.FileInfo)
}
PROTOBUF_NDEBUG_INLINE FileInfo::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        file_name_(arena) {}

inline void FileInfo::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.size_bytes_ = {};
}
FileInfo::~FileInfo() {
  // @@protoc_insertion_point(destructor:meshtastic.FileInfo)
  SharedDtor(*this);
}
inline void FileInfo::SharedDtor(MessageLite& self) {
  FileInfo& this_ = static_cast<FileInfo&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.file_name_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL FileInfo::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) FileInfo(arena);
}
constexpr auto FileInfo::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(FileInfo),
                                            alignof(FileInfo));
}
constexpr auto FileInfo::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_FileInfo_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &FileInfo::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<FileInfo>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &FileInfo::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<FileInfo>(), &FileInfo::ByteSizeLong,
              &FileInfo::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(FileInfo, _impl_._cached_size_),
          false,
      },
      &FileInfo::kDescriptorMethods,
      &descriptor_table_meshtastic_2fmesh_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull FileInfo_class_data_ =
        FileInfo::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
FileInfo::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&FileInfo_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(FileInfo_class_data_.tc_table);
  return FileInfo_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 37, 2>
FileInfo::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(FileInfo, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    FileInfo_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::meshtastic::FileInfo>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // uint32 size_bytes = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(FileInfo, _impl_.size_bytes_), 1>(),
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(FileInfo, _impl_.size_bytes_)}},
    // string file_name = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(FileInfo, _impl_.file_name_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string file_name = 1;
    {PROTOBUF_FIELD_OFFSET(FileInfo, _impl_.file_name_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // uint32 size_bytes = 2;
    {PROTOBUF_FIELD_OFFSET(FileInfo, _impl_.size_bytes_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
  }},
  // no aux_entries
  {{
    "\23\11\0\0\0\0\0\0"
    "meshtastic.FileInfo"
    "file_name"
  }},
};
PROTOBUF_NOINLINE void FileInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.FileInfo)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    _impl_.file_name_.ClearNonDefaultToEmpty();
  }
  _impl_.size_bytes_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL FileInfo::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const FileInfo& this_ = static_cast<const FileInfo&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL FileInfo::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const FileInfo& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.FileInfo)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // string file_name = 1;
  if ((this_._impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (!this_._internal_file_name().empty()) {
      const ::std::string& _s = this_._internal_file_name();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "meshtastic.FileInfo.file_name");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // uint32 size_bytes = 2;
  if ((this_._impl_._has_bits_[0] & 0x00000002u) != 0) {
    if (this_._internal_size_bytes() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          2, this_._internal_size_bytes(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.FileInfo)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t FileInfo::ByteSizeLong(const MessageLite& base) {
  const FileInfo& this_ = static_cast<const FileInfo&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t FileInfo::ByteSizeLong() const {
  const FileInfo& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:meshtastic.FileInfo)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    // string file_name = 1;
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (!this_._internal_file_name().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_file_name());
      }
    }
    // uint32 size_bytes = 2;
    if ((cached_has_bits & 0x00000002u) != 0) {
      if (this_._internal_size_bytes() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
            this_._internal_size_bytes());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void FileInfo::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<FileInfo*>(&to_msg);
  auto& from = static_cast<const FileInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.FileInfo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (!from._internal_file_name().empty()) {
        _this->_internal_set_file_name(from._internal_file_name());
      } else {
        if (_this->_impl_.file_name_.IsDefault()) {
          _this->_internal_set_file_name("");
        }
      }
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      if (from._internal_size_bytes() != 0) {
        _this->_impl_.size_bytes_ = from._impl_.size_bytes_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void FileInfo::CopyFrom(const FileInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.FileInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void FileInfo::InternalSwap(FileInfo* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.file_name_, &other->_impl_.file_name_, arena);
  swap(_impl_.size_bytes_, other->_impl_.size_bytes_);
}

::google::protobuf::Metadata FileInfo::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class ToRadio::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::meshtastic::ToRadio, _impl_._oneof_case_);
};

void ToRadio::set_allocated_packet(::meshtastic::MeshPacket* PROTOBUF_NULLABLE packet) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_payload_variant();
  if (packet) {
    ::google::protobuf::Arena* submessage_arena = packet->GetArena();
    if (message_arena != submessage_arena) {
      packet = ::google::protobuf::internal::GetOwnedMessage(message_arena, packet, submessage_arena);
    }
    set_has_packet();
    _impl_.payload_variant_.packet_ = packet;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.ToRadio.packet)
}
void ToRadio::set_allocated_xmodempacket(::meshtastic::XModem* PROTOBUF_NULLABLE xmodempacket) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_payload_variant();
  if (xmodempacket) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(xmodempacket)->GetArena();
    if (message_arena != submessage_arena) {
      xmodempacket = ::google::protobuf::internal::GetOwnedMessage(message_arena, xmodempacket, submessage_arena);
    }
    set_has_xmodempacket();
    _impl_.payload_variant_.xmodempacket_ = xmodempacket;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.ToRadio.xmodemPacket)
}
void ToRadio::clear_xmodempacket() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_variant_case() == kXmodemPacket) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_variant_.xmodempacket_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.xmodempacket_);
    }
    clear_has_payload_variant();
  }
}
void ToRadio::set_allocated_mqttclientproxymessage(::meshtastic::MqttClientProxyMessage* PROTOBUF_NULLABLE mqttclientproxymessage) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_payload_variant();
  if (mqttclientproxymessage) {
    ::google::protobuf::Arena* submessage_arena = mqttclientproxymessage->GetArena();
    if (message_arena != submessage_arena) {
      mqttclientproxymessage = ::google::protobuf::internal::GetOwnedMessage(message_arena, mqttclientproxymessage, submessage_arena);
    }
    set_has_mqttclientproxymessage();
    _impl_.payload_variant_.mqttclientproxymessage_ = mqttclientproxymessage;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.ToRadio.mqttClientProxyMessage)
}
void ToRadio::set_allocated_heartbeat(::meshtastic::Heartbeat* PROTOBUF_NULLABLE heartbeat) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_payload_variant();
  if (heartbeat) {
    ::google::protobuf::Arena* submessage_arena = heartbeat->GetArena();
    if (message_arena != submessage_arena) {
      heartbeat = ::google::protobuf::internal::GetOwnedMessage(message_arena, heartbeat, submessage_arena);
    }
    set_has_heartbeat();
    _impl_.payload_variant_.heartbeat_ = heartbeat;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.ToRadio.heartbeat)
}
ToRadio::ToRadio(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ToRadio_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:meshtastic.ToRadio)
}
PROTOBUF_NDEBUG_INLINE ToRadio::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::meshtastic::ToRadio& from_msg)
      : payload_variant_{},
        _cached_size_{0},
        _oneof_case_{from._oneof_case_[0]} {}

ToRadio::ToRadio(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const ToRadio& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ToRadio_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  ToRadio* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  switch (payload_variant_case()) {
    case PAYLOAD_VARIANT_NOT_SET:
      break;
      case kPacket:
        _impl_.payload_variant_.packet_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.packet_);
        break;
      case kWantConfigId:
        _impl_.payload_variant_.want_config_id_ = from._impl_.payload_variant_.want_config_id_;
        break;
      case kDisconnect:
        _impl_.payload_variant_.disconnect_ = from._impl_.payload_variant_.disconnect_;
        break;
      case kXmodemPacket:
        _impl_.payload_variant_.xmodempacket_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.xmodempacket_);
        break;
      case kMqttClientProxyMessage:
        _impl_.payload_variant_.mqttclientproxymessage_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.mqttclientproxymessage_);
        break;
      case kHeartbeat:
        _impl_.payload_variant_.heartbeat_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.heartbeat_);
        break;
  }

  // @@protoc_insertion_point(copy_constructor:meshtastic.ToRadio)
}
PROTOBUF_NDEBUG_INLINE ToRadio::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : payload_variant_{},
        _cached_size_{0},
        _oneof_case_{} {}

inline void ToRadio::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
ToRadio::~ToRadio() {
  // @@protoc_insertion_point(destructor:meshtastic.ToRadio)
  SharedDtor(*this);
}
inline void ToRadio::SharedDtor(MessageLite& self) {
  ToRadio& this_ = static_cast<ToRadio&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  if (this_.has_payload_variant()) {
    this_.clear_payload_variant();
  }
  this_._impl_.~Impl_();
}

void ToRadio::clear_payload_variant() {
// @@protoc_insertion_point(one_of_clear_start:meshtastic.ToRadio)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (payload_variant_case()) {
    case kPacket: {
      if (GetArena() == nullptr) {
        delete _impl_.payload_variant_.packet_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.packet_);
      }
      break;
    }
    case kWantConfigId: {
      // No need to clear
      break;
    }
    case kDisconnect: {
      // No need to clear
      break;
    }
    case kXmodemPacket: {
      if (GetArena() == nullptr) {
        delete _impl_.payload_variant_.xmodempacket_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.xmodempacket_);
      }
      break;
    }
    case kMqttClientProxyMessage: {
      if (GetArena() == nullptr) {
        delete _impl_.payload_variant_.mqttclientproxymessage_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.mqttclientproxymessage_);
      }
      break;
    }
    case kHeartbeat: {
      if (GetArena() == nullptr) {
        delete _impl_.payload_variant_.heartbeat_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.heartbeat_);
      }
      break;
    }
    case PAYLOAD_VARIANT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = PAYLOAD_VARIANT_NOT_SET;
}


inline void* PROTOBUF_NONNULL ToRadio::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) ToRadio(arena);
}
constexpr auto ToRadio::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(ToRadio),
                                            alignof(ToRadio));
}
constexpr auto ToRadio::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_ToRadio_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &ToRadio::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<ToRadio>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &ToRadio::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<ToRadio>(), &ToRadio::ByteSizeLong,
              &ToRadio::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(ToRadio, _impl_._cached_size_),
          false,
      },
      &ToRadio::kDescriptorMethods,
      &descriptor_table_meshtastic_2fmesh_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull ToRadio_class_data_ =
        ToRadio::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
ToRadio::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&ToRadio_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(ToRadio_class_data_.tc_table);
  return ToRadio_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 6, 4, 0, 2>
ToRadio::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    7, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967170,  // skipmap
    offsetof(decltype(_table_), field_entries),
    6,  // num_field_entries
    4,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    ToRadio_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::meshtastic::ToRadio>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // .meshtastic.MeshPacket packet = 1;
    {PROTOBUF_FIELD_OFFSET(ToRadio, _impl_.payload_variant_.packet_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // uint32 want_config_id = 3;
    {PROTOBUF_FIELD_OFFSET(ToRadio, _impl_.payload_variant_.want_config_id_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUInt32)},
    // bool disconnect = 4;
    {PROTOBUF_FIELD_OFFSET(ToRadio, _impl_.payload_variant_.disconnect_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // .meshtastic.XModem xmodemPacket = 5;
    {PROTOBUF_FIELD_OFFSET(ToRadio, _impl_.payload_variant_.xmodempacket_), _Internal::kOneofCaseOffset + 0, 1,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .meshtastic.MqttClientProxyMessage mqttClientProxyMessage = 6;
    {PROTOBUF_FIELD_OFFSET(ToRadio, _impl_.payload_variant_.mqttclientproxymessage_), _Internal::kOneofCaseOffset + 0, 2,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .meshtastic.Heartbeat heartbeat = 7;
    {PROTOBUF_FIELD_OFFSET(ToRadio, _impl_.payload_variant_.heartbeat_), _Internal::kOneofCaseOffset + 0, 3,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::meshtastic::MeshPacket>()},
      {::_pbi::TcParser::GetTable<::meshtastic::XModem>()},
      {::_pbi::TcParser::GetTable<::meshtastic::MqttClientProxyMessage>()},
      {::_pbi::TcParser::GetTable<::meshtastic::Heartbeat>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void ToRadio::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.ToRadio)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_payload_variant();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL ToRadio::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const ToRadio& this_ = static_cast<const ToRadio&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL ToRadio::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const ToRadio& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.ToRadio)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  switch (this_.payload_variant_case()) {
    case kPacket: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          1, *this_._impl_.payload_variant_.packet_, this_._impl_.payload_variant_.packet_->GetCachedSize(), target,
          stream);
      break;
    }
    case kWantConfigId: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          3, this_._internal_want_config_id(), target);
      break;
    }
    case kDisconnect: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          4, this_._internal_disconnect(), target);
      break;
    }
    case kXmodemPacket: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          5, *this_._impl_.payload_variant_.xmodempacket_, this_._impl_.payload_variant_.xmodempacket_->GetCachedSize(), target,
          stream);
      break;
    }
    case kMqttClientProxyMessage: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          6, *this_._impl_.payload_variant_.mqttclientproxymessage_, this_._impl_.payload_variant_.mqttclientproxymessage_->GetCachedSize(), target,
          stream);
      break;
    }
    case kHeartbeat: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          7, *this_._impl_.payload_variant_.heartbeat_, this_._impl_.payload_variant_.heartbeat_->GetCachedSize(), target,
          stream);
      break;
    }
    default:
      break;
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.ToRadio)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t ToRadio::ByteSizeLong(const MessageLite& base) {
  const ToRadio& this_ = static_cast<const ToRadio&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t ToRadio::ByteSizeLong() const {
  const ToRadio& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:meshtastic.ToRadio)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  switch (this_.payload_variant_case()) {
    // .meshtastic.MeshPacket packet = 1;
    case kPacket: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.payload_variant_.packet_);
      break;
    }
    // uint32 want_config_id = 3;
    case kWantConfigId: {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this_._internal_want_config_id());
      break;
    }
    // bool disconnect = 4;
    case kDisconnect: {
      total_size += 2;
      break;
    }
    // .meshtastic.XModem xmodemPacket = 5;
    case kXmodemPacket: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.payload_variant_.xmodempacket_);
      break;
    }
    // .meshtastic.MqttClientProxyMessage mqttClientProxyMessage = 6;
    case kMqttClientProxyMessage: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.payload_variant_.mqttclientproxymessage_);
      break;
    }
    // .meshtastic.Heartbeat heartbeat = 7;
    case kHeartbeat: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.payload_variant_.heartbeat_);
      break;
    }
    case PAYLOAD_VARIANT_NOT_SET: {
      break;
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void ToRadio::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<ToRadio*>(&to_msg);
  auto& from = static_cast<const ToRadio&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.ToRadio)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_payload_variant();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kPacket: {
        if (oneof_needs_init) {
          _this->_impl_.payload_variant_.packet_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.packet_);
        } else {
          _this->_impl_.payload_variant_.packet_->MergeFrom(*from._impl_.payload_variant_.packet_);
        }
        break;
      }
      case kWantConfigId: {
        _this->_impl_.payload_variant_.want_config_id_ = from._impl_.payload_variant_.want_config_id_;
        break;
      }
      case kDisconnect: {
        _this->_impl_.payload_variant_.disconnect_ = from._impl_.payload_variant_.disconnect_;
        break;
      }
      case kXmodemPacket: {
        if (oneof_needs_init) {
          _this->_impl_.payload_variant_.xmodempacket_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.xmodempacket_);
        } else {
          _this->_impl_.payload_variant_.xmodempacket_->MergeFrom(*from._impl_.payload_variant_.xmodempacket_);
        }
        break;
      }
      case kMqttClientProxyMessage: {
        if (oneof_needs_init) {
          _this->_impl_.payload_variant_.mqttclientproxymessage_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.mqttclientproxymessage_);
        } else {
          _this->_impl_.payload_variant_.mqttclientproxymessage_->MergeFrom(*from._impl_.payload_variant_.mqttclientproxymessage_);
        }
        break;
      }
      case kHeartbeat: {
        if (oneof_needs_init) {
          _this->_impl_.payload_variant_.heartbeat_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.heartbeat_);
        } else {
          _this->_impl_.payload_variant_.heartbeat_->MergeFrom(*from._impl_.payload_variant_.heartbeat_);
        }
        break;
      }
      case PAYLOAD_VARIANT_NOT_SET:
        break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void ToRadio::CopyFrom(const ToRadio& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.ToRadio)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void ToRadio::InternalSwap(ToRadio* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.payload_variant_, other->_impl_.payload_variant_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::google::protobuf::Metadata ToRadio::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class Compressed::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<Compressed>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(Compressed, _impl_._has_bits_);
};

Compressed::Compressed(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, Compressed_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:meshtastic.Compressed)
}
PROTOBUF_NDEBUG_INLINE Compressed::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::meshtastic::Compressed& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        data_(arena, from.data_) {}

Compressed::Compressed(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const Compressed& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, Compressed_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  Compressed* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.portnum_ = from._impl_.portnum_;

  // @@protoc_insertion_point(copy_constructor:meshtastic.Compressed)
}
PROTOBUF_NDEBUG_INLINE Compressed::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        data_(arena) {}

inline void Compressed::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.portnum_ = {};
}
Compressed::~Compressed() {
  // @@protoc_insertion_point(destructor:meshtastic.Compressed)
  SharedDtor(*this);
}
inline void Compressed::SharedDtor(MessageLite& self) {
  Compressed& this_ = static_cast<Compressed&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.data_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL Compressed::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) Compressed(arena);
}
constexpr auto Compressed::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(Compressed),
                                            alignof(Compressed));
}
constexpr auto Compressed::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_Compressed_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &Compressed::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<Compressed>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &Compressed::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<Compressed>(), &Compressed::ByteSizeLong,
              &Compressed::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(Compressed, _impl_._cached_size_),
          false,
      },
      &Compressed::kDescriptorMethods,
      &descriptor_table_meshtastic_2fmesh_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull Compressed_class_data_ =
        Compressed::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
Compressed::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&Compressed_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(Compressed_class_data_.tc_table);
  return Compressed_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2>
Compressed::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Compressed, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    Compressed_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::meshtastic::Compressed>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // bytes data = 2;
    {::_pbi::TcParser::FastBS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(Compressed, _impl_.data_)}},
    // .meshtastic.PortNum portnum = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Compressed, _impl_.portnum_), 1>(),
     {8, 1, 0, PROTOBUF_FIELD_OFFSET(Compressed, _impl_.portnum_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .meshtastic.PortNum portnum = 1;
    {PROTOBUF_FIELD_OFFSET(Compressed, _impl_.portnum_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kOpenEnum)},
    // bytes data = 2;
    {PROTOBUF_FIELD_OFFSET(Compressed, _impl_.data_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void Compressed::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.Compressed)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    _impl_.data_.ClearNonDefaultToEmpty();
  }
  _impl_.portnum_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL Compressed::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const Compressed& this_ = static_cast<const Compressed&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL Compressed::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const Compressed& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.Compressed)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // .meshtastic.PortNum portnum = 1;
  if ((this_._impl_._has_bits_[0] & 0x00000002u) != 0) {
    if (this_._internal_portnum() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          1, this_._internal_portnum(), target);
    }
  }

  // bytes data = 2;
  if ((this_._impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (!this_._internal_data().empty()) {
      const ::std::string& _s = this_._internal_data();
      target = stream->WriteBytesMaybeAliased(2, _s, target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.Compressed)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t Compressed::ByteSizeLong(const MessageLite& base) {
  const Compressed& this_ = static_cast<const Compressed&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t Compressed::ByteSizeLong() const {
  const Compressed& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:meshtastic.Compressed)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    // bytes data = 2;
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (!this_._internal_data().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                        this_._internal_data());
      }
    }
    // .meshtastic.PortNum portnum = 1;
    if ((cached_has_bits & 0x00000002u) != 0) {
      if (this_._internal_portnum() != 0) {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this_._internal_portnum());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void Compressed::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Compressed*>(&to_msg);
  auto& from = static_cast<const Compressed&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.Compressed)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (!from._internal_data().empty()) {
        _this->_internal_set_data(from._internal_data());
      } else {
        if (_this->_impl_.data_.IsDefault()) {
          _this->_internal_set_data("");
        }
      }
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      if (from._internal_portnum() != 0) {
        _this->_impl_.portnum_ = from._impl_.portnum_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Compressed::CopyFrom(const Compressed& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.Compressed)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Compressed::InternalSwap(Compressed* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.data_, &other->_impl_.data_, arena);
  swap(_impl_.portnum_, other->_impl_.portnum_);
}

::google::protobuf::Metadata Compressed::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class NeighborInfo::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<NeighborInfo>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(NeighborInfo, _impl_._has_bits_);
};

NeighborInfo::NeighborInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, NeighborInfo_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:meshtastic.NeighborInfo)
}
PROTOBUF_NDEBUG_INLINE NeighborInfo::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::meshtastic::NeighborInfo& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        neighbors_{visibility, arena, from.neighbors_} {}

NeighborInfo::NeighborInfo(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const NeighborInfo& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, NeighborInfo_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  NeighborInfo* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, node_id_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, node_id_),
           offsetof(Impl_, node_broadcast_interval_secs_) -
               offsetof(Impl_, node_id_) +
               sizeof(Impl_::node_broadcast_interval_secs_));

  // @@protoc_insertion_point(copy_constructor:meshtastic.NeighborInfo)
}
PROTOBUF_NDEBUG_INLINE NeighborInfo::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        neighbors_{visibility, arena} {}

inline void NeighborInfo::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, node_id_),
           0,
           offsetof(Impl_, node_broadcast_interval_secs_) -
               offsetof(Impl_, node_id_) +
               sizeof(Impl_::node_broadcast_interval_secs_));
}
NeighborInfo::~NeighborInfo() {
  // @@protoc_insertion_point(destructor:meshtastic.NeighborInfo)
  SharedDtor(*this);
}
inline void NeighborInfo::SharedDtor(MessageLite& self) {
  NeighborInfo& this_ = static_cast<NeighborInfo&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL NeighborInfo::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) NeighborInfo(arena);
}
constexpr auto NeighborInfo::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(NeighborInfo, _impl_.neighbors_) +
          decltype(NeighborInfo::_impl_.neighbors_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(NeighborInfo), alignof(NeighborInfo), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&NeighborInfo::PlacementNew_,
                                 sizeof(NeighborInfo),
                                 alignof(NeighborInfo));
  }
}
constexpr auto NeighborInfo::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_NeighborInfo_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &NeighborInfo::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<NeighborInfo>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &NeighborInfo::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<NeighborInfo>(), &NeighborInfo::ByteSizeLong,
              &NeighborInfo::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(NeighborInfo, _impl_._cached_size_),
          false,
      },
      &NeighborInfo::kDescriptorMethods,
      &descriptor_table_meshtastic_2fmesh_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull NeighborInfo_class_data_ =
        NeighborInfo::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
NeighborInfo::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&NeighborInfo_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(NeighborInfo_class_data_.tc_table);
  return NeighborInfo_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 1, 0, 2>
NeighborInfo::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(NeighborInfo, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    NeighborInfo_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::meshtastic::NeighborInfo>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated .meshtastic.Neighbor neighbors = 4;
    {::_pbi::TcParser::FastMtR1,
     {34, 63, 0, PROTOBUF_FIELD_OFFSET(NeighborInfo, _impl_.neighbors_)}},
    // uint32 node_id = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(NeighborInfo, _impl_.node_id_), 0>(),
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(NeighborInfo, _impl_.node_id_)}},
    // uint32 last_sent_by_id = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(NeighborInfo, _impl_.last_sent_by_id_), 1>(),
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(NeighborInfo, _impl_.last_sent_by_id_)}},
    // uint32 node_broadcast_interval_secs = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(NeighborInfo, _impl_.node_broadcast_interval_secs_), 2>(),
     {24, 2, 0, PROTOBUF_FIELD_OFFSET(NeighborInfo, _impl_.node_broadcast_interval_secs_)}},
  }}, {{
    65535, 65535
  }}, {{
    // uint32 node_id = 1;
    {PROTOBUF_FIELD_OFFSET(NeighborInfo, _impl_.node_id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // uint32 last_sent_by_id = 2;
    {PROTOBUF_FIELD_OFFSET(NeighborInfo, _impl_.last_sent_by_id_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // uint32 node_broadcast_interval_secs = 3;
    {PROTOBUF_FIELD_OFFSET(NeighborInfo, _impl_.node_broadcast_interval_secs_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // repeated .meshtastic.Neighbor neighbors = 4;
    {PROTOBUF_FIELD_OFFSET(NeighborInfo, _impl_.neighbors_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::meshtastic::Neighbor>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void NeighborInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.NeighborInfo)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.neighbors_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    ::memset(&_impl_.node_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.node_broadcast_interval_secs_) -
        reinterpret_cast<char*>(&_impl_.node_id_)) + sizeof(_impl_.node_broadcast_interval_secs_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL NeighborInfo::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const NeighborInfo& this_ = static_cast<const NeighborInfo&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL NeighborInfo::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const NeighborInfo& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.NeighborInfo)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // uint32 node_id = 1;
  if ((this_._impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (this_._internal_node_id() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          1, this_._internal_node_id(), target);
    }
  }

  // uint32 last_sent_by_id = 2;
  if ((this_._impl_._has_bits_[0] & 0x00000002u) != 0) {
    if (this_._internal_last_sent_by_id() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          2, this_._internal_last_sent_by_id(), target);
    }
  }

  // uint32 node_broadcast_interval_secs = 3;
  if ((this_._impl_._has_bits_[0] & 0x00000004u) != 0) {
    if (this_._internal_node_broadcast_interval_secs() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          3, this_._internal_node_broadcast_interval_secs(), target);
    }
  }

  // repeated .meshtastic.Neighbor neighbors = 4;
  for (unsigned i = 0, n = static_cast<unsigned>(
                           this_._internal_neighbors_size());
       i < n; i++) {
    const auto& repfield = this_._internal_neighbors().Get(i);
    target =
        ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
            4, repfield, repfield.GetCachedSize(),
            target, stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.NeighborInfo)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t NeighborInfo::ByteSizeLong(const MessageLite& base) {
  const NeighborInfo& this_ = static_cast<const NeighborInfo&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t NeighborInfo::ByteSizeLong() const {
  const NeighborInfo& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:meshtastic.NeighborInfo)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated .meshtastic.Neighbor neighbors = 4;
    {
      total_size += 1UL * this_._internal_neighbors_size();
      for (const auto& msg : this_._internal_neighbors()) {
        total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
      }
    }
  }
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    // uint32 node_id = 1;
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (this_._internal_node_id() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
            this_._internal_node_id());
      }
    }
    // uint32 last_sent_by_id = 2;
    if ((cached_has_bits & 0x00000002u) != 0) {
      if (this_._internal_last_sent_by_id() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
            this_._internal_last_sent_by_id());
      }
    }
    // uint32 node_broadcast_interval_secs = 3;
    if ((cached_has_bits & 0x00000004u) != 0) {
      if (this_._internal_node_broadcast_interval_secs() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
            this_._internal_node_broadcast_interval_secs());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void NeighborInfo::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<NeighborInfo*>(&to_msg);
  auto& from = static_cast<const NeighborInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.NeighborInfo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_neighbors()->MergeFrom(
      from._internal_neighbors());
  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (from._internal_node_id() != 0) {
        _this->_impl_.node_id_ = from._impl_.node_id_;
      }
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      if (from._internal_last_sent_by_id() != 0) {
        _this->_impl_.last_sent_by_id_ = from._impl_.last_sent_by_id_;
      }
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      if (from._internal_node_broadcast_interval_secs() != 0) {
        _this->_impl_.node_broadcast_interval_secs_ = from._impl_.node_broadcast_interval_secs_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void NeighborInfo::CopyFrom(const NeighborInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.NeighborInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void NeighborInfo::InternalSwap(NeighborInfo* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.neighbors_.InternalSwap(&other->_impl_.neighbors_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NeighborInfo, _impl_.node_broadcast_interval_secs_)
      + sizeof(NeighborInfo::_impl_.node_broadcast_interval_secs_)
      - PROTOBUF_FIELD_OFFSET(NeighborInfo, _impl_.node_id_)>(
          reinterpret_cast<char*>(&_impl_.node_id_),
          reinterpret_cast<char*>(&other->_impl_.node_id_));
}

::google::protobuf::Metadata NeighborInfo::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class Neighbor::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<Neighbor>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(Neighbor, _impl_._has_bits_);
};

Neighbor::Neighbor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, Neighbor_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:meshtastic.Neighbor)
}
Neighbor::Neighbor(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Neighbor& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, Neighbor_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}
PROTOBUF_NDEBUG_INLINE Neighbor::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void Neighbor::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, node_id_),
           0,
           offsetof(Impl_, node_broadcast_interval_secs_) -
               offsetof(Impl_, node_id_) +
               sizeof(Impl_::node_broadcast_interval_secs_));
}
Neighbor::~Neighbor() {
  // @@protoc_insertion_point(destructor:meshtastic.Neighbor)
  SharedDtor(*this);
}
inline void Neighbor::SharedDtor(MessageLite& self) {
  Neighbor& this_ = static_cast<Neighbor&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL Neighbor::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) Neighbor(arena);
}
constexpr auto Neighbor::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(Neighbor),
                                            alignof(Neighbor));
}
constexpr auto Neighbor::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_Neighbor_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &Neighbor::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<Neighbor>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &Neighbor::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<Neighbor>(), &Neighbor::ByteSizeLong,
              &Neighbor::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(Neighbor, _impl_._cached_size_),
          false,
      },
      &Neighbor::kDescriptorMethods,
      &descriptor_table_meshtastic_2fmesh_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull Neighbor_class_data_ =
        Neighbor::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
Neighbor::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&Neighbor_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(Neighbor_class_data_.tc_table);
  return Neighbor_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 0, 2>
Neighbor::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Neighbor, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    Neighbor_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::meshtastic::Neighbor>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // uint32 node_broadcast_interval_secs = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Neighbor, _impl_.node_broadcast_interval_secs_), 3>(),
     {32, 3, 0, PROTOBUF_FIELD_OFFSET(Neighbor, _impl_.node_broadcast_interval_secs_)}},
    // uint32 node_id = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Neighbor, _impl_.node_id_), 0>(),
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(Neighbor, _impl_.node_id_)}},
    // float snr = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 1, 0, PROTOBUF_FIELD_OFFSET(Neighbor, _impl_.snr_)}},
    // fixed32 last_rx_time = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 2, 0, PROTOBUF_FIELD_OFFSET(Neighbor, _impl_.last_rx_time_)}},
  }}, {{
    65535, 65535
  }}, {{
    // uint32 node_id = 1;
    {PROTOBUF_FIELD_OFFSET(Neighbor, _impl_.node_id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // float snr = 2;
    {PROTOBUF_FIELD_OFFSET(Neighbor, _impl_.snr_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // fixed32 last_rx_time = 3;
    {PROTOBUF_FIELD_OFFSET(Neighbor, _impl_.last_rx_time_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFixed32)},
    // uint32 node_broadcast_interval_secs = 4;
    {PROTOBUF_FIELD_OFFSET(Neighbor, _impl_.node_broadcast_interval_secs_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void Neighbor::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.Neighbor)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000000fu) != 0) {
    ::memset(&_impl_.node_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.node_broadcast_interval_secs_) -
        reinterpret_cast<char*>(&_impl_.node_id_)) + sizeof(_impl_.node_broadcast_interval_secs_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL Neighbor::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const Neighbor& this_ = static_cast<const Neighbor&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL Neighbor::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const Neighbor& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.Neighbor)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // uint32 node_id = 1;
  if ((this_._impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (this_._internal_node_id() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          1, this_._internal_node_id(), target);
    }
  }

  // float snr = 2;
  if ((this_._impl_._has_bits_[0] & 0x00000002u) != 0) {
    if (::absl::bit_cast<::uint32_t>(this_._internal_snr()) != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFloatToArray(
          2, this_._internal_snr(), target);
    }
  }

  // fixed32 last_rx_time = 3;
  if ((this_._impl_._has_bits_[0] & 0x00000004u) != 0) {
    if (this_._internal_last_rx_time() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
          3, this_._internal_last_rx_time(), target);
    }
  }

  // uint32 node_broadcast_interval_secs = 4;
  if ((this_._impl_._has_bits_[0] & 0x00000008u) != 0) {
    if (this_._internal_node_broadcast_interval_secs() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          4, this_._internal_node_broadcast_interval_secs(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.Neighbor)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t Neighbor::ByteSizeLong(const MessageLite& base) {
  const Neighbor& this_ = static_cast<const Neighbor&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t Neighbor::ByteSizeLong() const {
  const Neighbor& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:meshtastic.Neighbor)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000000fu) != 0) {
    // uint32 node_id = 1;
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (this_._internal_node_id() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
            this_._internal_node_id());
      }
    }
    // float snr = 2;
    if ((cached_has_bits & 0x00000002u) != 0) {
      if (::absl::bit_cast<::uint32_t>(this_._internal_snr()) != 0) {
        total_size += 5;
      }
    }
    // fixed32 last_rx_time = 3;
    if ((cached_has_bits & 0x00000004u) != 0) {
      if (this_._internal_last_rx_time() != 0) {
        total_size += 5;
      }
    }
    // uint32 node_broadcast_interval_secs = 4;
    if ((cached_has_bits & 0x00000008u) != 0) {
      if (this_._internal_node_broadcast_interval_secs() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
            this_._internal_node_broadcast_interval_secs());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void Neighbor::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Neighbor*>(&to_msg);
  auto& from = static_cast<const Neighbor&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.Neighbor)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000000fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (from._internal_node_id() != 0) {
        _this->_impl_.node_id_ = from._impl_.node_id_;
      }
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      if (::absl::bit_cast<::uint32_t>(from._internal_snr()) != 0) {
        _this->_impl_.snr_ = from._impl_.snr_;
      }
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      if (from._internal_last_rx_time() != 0) {
        _this->_impl_.last_rx_time_ = from._impl_.last_rx_time_;
      }
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      if (from._internal_node_broadcast_interval_secs() != 0) {
        _this->_impl_.node_broadcast_interval_secs_ = from._impl_.node_broadcast_interval_secs_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Neighbor::CopyFrom(const Neighbor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.Neighbor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Neighbor::InternalSwap(Neighbor* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Neighbor, _impl_.node_broadcast_interval_secs_)
      + sizeof(Neighbor::_impl_.node_broadcast_interval_secs_)
      - PROTOBUF_FIELD_OFFSET(Neighbor, _impl_.node_id_)>(
          reinterpret_cast<char*>(&_impl_.node_id_),
          reinterpret_cast<char*>(&other->_impl_.node_id_));
}

::google::protobuf::Metadata Neighbor::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class DeviceMetadata::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<DeviceMetadata>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(DeviceMetadata, _impl_._has_bits_);
};

DeviceMetadata::DeviceMetadata(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, DeviceMetadata_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:meshtastic.DeviceMetadata)
}
PROTOBUF_NDEBUG_INLINE DeviceMetadata::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::meshtastic::DeviceMetadata& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        firmware_version_(arena, from.firmware_version_) {}

DeviceMetadata::DeviceMetadata(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const DeviceMetadata& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, DeviceMetadata_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  DeviceMetadata* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, device_state_version_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, device_state_version_),
           offsetof(Impl_, excluded_modules_) -
               offsetof(Impl_, device_state_version_) +
               sizeof(Impl_::excluded_modules_));

  // @@protoc_insertion_point(copy_constructor:meshtastic.DeviceMetadata)
}
PROTOBUF_NDEBUG_INLINE DeviceMetadata::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        firmware_version_(arena) {}

inline void DeviceMetadata::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, device_state_version_),
           0,
           offsetof(Impl_, excluded_modules_) -
               offsetof(Impl_, device_state_version_) +
               sizeof(Impl_::excluded_modules_));
}
DeviceMetadata::~DeviceMetadata() {
  // @@protoc_insertion_point(destructor:meshtastic.DeviceMetadata)
  SharedDtor(*this);
}
inline void DeviceMetadata::SharedDtor(MessageLite& self) {
  DeviceMetadata& this_ = static_cast<DeviceMetadata&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.firmware_version_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL DeviceMetadata::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) DeviceMetadata(arena);
}
constexpr auto DeviceMetadata::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(DeviceMetadata),
                                            alignof(DeviceMetadata));
}
constexpr auto DeviceMetadata::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_DeviceMetadata_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &DeviceMetadata::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<DeviceMetadata>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &DeviceMetadata::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<DeviceMetadata>(), &DeviceMetadata::ByteSizeLong,
              &DeviceMetadata::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(DeviceMetadata, _impl_._cached_size_),
          false,
      },
      &DeviceMetadata::kDescriptorMethods,
      &descriptor_table_meshtastic_2fmesh_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull DeviceMetadata_class_data_ =
        DeviceMetadata::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
DeviceMetadata::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&DeviceMetadata_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(DeviceMetadata_class_data_.tc_table);
  return DeviceMetadata_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 12, 0, 58, 2>
DeviceMetadata::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(DeviceMetadata, _impl_._has_bits_),
    0, // no _extensions_
    12, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294963200,  // skipmap
    offsetof(decltype(_table_), field_entries),
    12,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    DeviceMetadata_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::meshtastic::DeviceMetadata>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string firmware_version = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(DeviceMetadata, _impl_.firmware_version_)}},
    // uint32 device_state_version = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(DeviceMetadata, _impl_.device_state_version_), 1>(),
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(DeviceMetadata, _impl_.device_state_version_)}},
    // bool canShutdown = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(DeviceMetadata, _impl_.canshutdown_), 2>(),
     {24, 2, 0, PROTOBUF_FIELD_OFFSET(DeviceMetadata, _impl_.canshutdown_)}},
    // bool hasWifi = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(DeviceMetadata, _impl_.haswifi_), 3>(),
     {32, 3, 0, PROTOBUF_FIELD_OFFSET(DeviceMetadata, _impl_.haswifi_)}},
    // bool hasBluetooth = 5;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(DeviceMetadata, _impl_.hasbluetooth_), 4>(),
     {40, 4, 0, PROTOBUF_FIELD_OFFSET(DeviceMetadata, _impl_.hasbluetooth_)}},
    // bool hasEthernet = 6;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(DeviceMetadata, _impl_.hasethernet_), 5>(),
     {48, 5, 0, PROTOBUF_FIELD_OFFSET(DeviceMetadata, _impl_.hasethernet_)}},
    // .meshtastic.Config.DeviceConfig.Role role = 7;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(DeviceMetadata, _impl_.role_), 6>(),
     {56, 6, 0, PROTOBUF_FIELD_OFFSET(DeviceMetadata, _impl_.role_)}},
    // uint32 position_flags = 8;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(DeviceMetadata, _impl_.position_flags_), 7>(),
     {64, 7, 0, PROTOBUF_FIELD_OFFSET(DeviceMetadata, _impl_.position_flags_)}},
    // .meshtastic.HardwareModel hw_model = 9;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(DeviceMetadata, _impl_.hw_model_), 8>(),
     {72, 8, 0, PROTOBUF_FIELD_OFFSET(DeviceMetadata, _impl_.hw_model_)}},
    // bool hasRemoteHardware = 10;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(DeviceMetadata, _impl_.hasremotehardware_), 9>(),
     {80, 9, 0, PROTOBUF_FIELD_OFFSET(DeviceMetadata, _impl_.hasremotehardware_)}},
    // bool hasPKC = 11;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(DeviceMetadata, _impl_.haspkc_), 10>(),
     {88, 10, 0, PROTOBUF_FIELD_OFFSET(DeviceMetadata, _impl_.haspkc_)}},
    // uint32 excluded_modules = 12;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(DeviceMetadata, _impl_.excluded_modules_), 11>(),
     {96, 11, 0, PROTOBUF_FIELD_OFFSET(DeviceMetadata, _impl_.excluded_modules_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // string firmware_version = 1;
    {PROTOBUF_FIELD_OFFSET(DeviceMetadata, _impl_.firmware_version_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // uint32 device_state_version = 2;
    {PROTOBUF_FIELD_OFFSET(DeviceMetadata, _impl_.device_state_version_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // bool canShutdown = 3;
    {PROTOBUF_FIELD_OFFSET(DeviceMetadata, _impl_.canshutdown_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // bool hasWifi = 4;
    {PROTOBUF_FIELD_OFFSET(DeviceMetadata, _impl_.haswifi_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // bool hasBluetooth = 5;
    {PROTOBUF_FIELD_OFFSET(DeviceMetadata, _impl_.hasbluetooth_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // bool hasEthernet = 6;
    {PROTOBUF_FIELD_OFFSET(DeviceMetadata, _impl_.hasethernet_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // .meshtastic.Config.DeviceConfig.Role role = 7;
    {PROTOBUF_FIELD_OFFSET(DeviceMetadata, _impl_.role_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kOpenEnum)},
    // uint32 position_flags = 8;
    {PROTOBUF_FIELD_OFFSET(DeviceMetadata, _impl_.position_flags_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // .meshtastic.HardwareModel hw_model = 9;
    {PROTOBUF_FIELD_OFFSET(DeviceMetadata, _impl_.hw_model_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kOpenEnum)},
    // bool hasRemoteHardware = 10;
    {PROTOBUF_FIELD_OFFSET(DeviceMetadata, _impl_.hasremotehardware_), _Internal::kHasBitsOffset + 9, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // bool hasPKC = 11;
    {PROTOBUF_FIELD_OFFSET(DeviceMetadata, _impl_.haspkc_), _Internal::kHasBitsOffset + 10, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // uint32 excluded_modules = 12;
    {PROTOBUF_FIELD_OFFSET(DeviceMetadata, _impl_.excluded_modules_), _Internal::kHasBitsOffset + 11, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
  }},
  // no aux_entries
  {{
    "\31\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
    "meshtastic.DeviceMetadata"
    "firmware_version"
  }},
};
PROTOBUF_NOINLINE void DeviceMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.DeviceMetadata)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    _impl_.firmware_version_.ClearNonDefaultToEmpty();
  }
  if ((cached_has_bits & 0x000000feu) != 0) {
    ::memset(&_impl_.device_state_version_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.position_flags_) -
        reinterpret_cast<char*>(&_impl_.device_state_version_)) + sizeof(_impl_.position_flags_));
  }
  if ((cached_has_bits & 0x00000f00u) != 0) {
    ::memset(&_impl_.hw_model_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.excluded_modules_) -
        reinterpret_cast<char*>(&_impl_.hw_model_)) + sizeof(_impl_.excluded_modules_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL DeviceMetadata::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const DeviceMetadata& this_ = static_cast<const DeviceMetadata&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL DeviceMetadata::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const DeviceMetadata& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.DeviceMetadata)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // string firmware_version = 1;
  if ((this_._impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (!this_._internal_firmware_version().empty()) {
      const ::std::string& _s = this_._internal_firmware_version();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "meshtastic.DeviceMetadata.firmware_version");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // uint32 device_state_version = 2;
  if ((this_._impl_._has_bits_[0] & 0x00000002u) != 0) {
    if (this_._internal_device_state_version() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          2, this_._internal_device_state_version(), target);
    }
  }

  // bool canShutdown = 3;
  if ((this_._impl_._has_bits_[0] & 0x00000004u) != 0) {
    if (this_._internal_canshutdown() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          3, this_._internal_canshutdown(), target);
    }
  }

  // bool hasWifi = 4;
  if ((this_._impl_._has_bits_[0] & 0x00000008u) != 0) {
    if (this_._internal_haswifi() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          4, this_._internal_haswifi(), target);
    }
  }

  // bool hasBluetooth = 5;
  if ((this_._impl_._has_bits_[0] & 0x00000010u) != 0) {
    if (this_._internal_hasbluetooth() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          5, this_._internal_hasbluetooth(), target);
    }
  }

  // bool hasEthernet = 6;
  if ((this_._impl_._has_bits_[0] & 0x00000020u) != 0) {
    if (this_._internal_hasethernet() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          6, this_._internal_hasethernet(), target);
    }
  }

  // .meshtastic.Config.DeviceConfig.Role role = 7;
  if ((this_._impl_._has_bits_[0] & 0x00000040u) != 0) {
    if (this_._internal_role() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          7, this_._internal_role(), target);
    }
  }

  // uint32 position_flags = 8;
  if ((this_._impl_._has_bits_[0] & 0x00000080u) != 0) {
    if (this_._internal_position_flags() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          8, this_._internal_position_flags(), target);
    }
  }

  // .meshtastic.HardwareModel hw_model = 9;
  if ((this_._impl_._has_bits_[0] & 0x00000100u) != 0) {
    if (this_._internal_hw_model() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          9, this_._internal_hw_model(), target);
    }
  }

  // bool hasRemoteHardware = 10;
  if ((this_._impl_._has_bits_[0] & 0x00000200u) != 0) {
    if (this_._internal_hasremotehardware() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          10, this_._internal_hasremotehardware(), target);
    }
  }

  // bool hasPKC = 11;
  if ((this_._impl_._has_bits_[0] & 0x00000400u) != 0) {
    if (this_._internal_haspkc() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          11, this_._internal_haspkc(), target);
    }
  }

  // uint32 excluded_modules = 12;
  if ((this_._impl_._has_bits_[0] & 0x00000800u) != 0) {
    if (this_._internal_excluded_modules() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          12, this_._internal_excluded_modules(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.DeviceMetadata)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t DeviceMetadata::ByteSizeLong(const MessageLite& base) {
  const DeviceMetadata& this_ = static_cast<const DeviceMetadata&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t DeviceMetadata::ByteSizeLong() const {
  const DeviceMetadata& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:meshtastic.DeviceMetadata)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x000000ffu) != 0) {
    // string firmware_version = 1;
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (!this_._internal_firmware_version().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_firmware_version());
      }
    }
    // uint32 device_state_version = 2;
    if ((cached_has_bits & 0x00000002u) != 0) {
      if (this_._internal_device_state_version() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
            this_._internal_device_state_version());
      }
    }
    // bool canShutdown = 3;
    if ((cached_has_bits & 0x00000004u) != 0) {
      if (this_._internal_canshutdown() != 0) {
        total_size += 2;
      }
    }
    // bool hasWifi = 4;
    if ((cached_has_bits & 0x00000008u) != 0) {
      if (this_._internal_haswifi() != 0) {
        total_size += 2;
      }
    }
    // bool hasBluetooth = 5;
    if ((cached_has_bits & 0x00000010u) != 0) {
      if (this_._internal_hasbluetooth() != 0) {
        total_size += 2;
      }
    }
    // bool hasEthernet = 6;
    if ((cached_has_bits & 0x00000020u) != 0) {
      if (this_._internal_hasethernet() != 0) {
        total_size += 2;
      }
    }
    // .meshtastic.Config.DeviceConfig.Role role = 7;
    if ((cached_has_bits & 0x00000040u) != 0) {
      if (this_._internal_role() != 0) {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this_._internal_role());
      }
    }
    // uint32 position_flags = 8;
    if ((cached_has_bits & 0x00000080u) != 0) {
      if (this_._internal_position_flags() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
            this_._internal_position_flags());
      }
    }
  }
  if ((cached_has_bits & 0x00000f00u) != 0) {
    // .meshtastic.HardwareModel hw_model = 9;
    if ((cached_has_bits & 0x00000100u) != 0) {
      if (this_._internal_hw_model() != 0) {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this_._internal_hw_model());
      }
    }
    // bool hasRemoteHardware = 10;
    if ((cached_has_bits & 0x00000200u) != 0) {
      if (this_._internal_hasremotehardware() != 0) {
        total_size += 2;
      }
    }
    // bool hasPKC = 11;
    if ((cached_has_bits & 0x00000400u) != 0) {
      if (this_._internal_haspkc() != 0) {
        total_size += 2;
      }
    }
    // uint32 excluded_modules = 12;
    if ((cached_has_bits & 0x00000800u) != 0) {
      if (this_._internal_excluded_modules() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
            this_._internal_excluded_modules());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void DeviceMetadata::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<DeviceMetadata*>(&to_msg);
  auto& from = static_cast<const DeviceMetadata&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.DeviceMetadata)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x000000ffu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (!from._internal_firmware_version().empty()) {
        _this->_internal_set_firmware_version(from._internal_firmware_version());
      } else {
        if (_this->_impl_.firmware_version_.IsDefault()) {
          _this->_internal_set_firmware_version("");
        }
      }
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      if (from._internal_device_state_version() != 0) {
        _this->_impl_.device_state_version_ = from._impl_.device_state_version_;
      }
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      if (from._internal_canshutdown() != 0) {
        _this->_impl_.canshutdown_ = from._impl_.canshutdown_;
      }
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      if (from._internal_haswifi() != 0) {
        _this->_impl_.haswifi_ = from._impl_.haswifi_;
      }
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      if (from._internal_hasbluetooth() != 0) {
        _this->_impl_.hasbluetooth_ = from._impl_.hasbluetooth_;
      }
    }
    if ((cached_has_bits & 0x00000020u) != 0) {
      if (from._internal_hasethernet() != 0) {
        _this->_impl_.hasethernet_ = from._impl_.hasethernet_;
      }
    }
    if ((cached_has_bits & 0x00000040u) != 0) {
      if (from._internal_role() != 0) {
        _this->_impl_.role_ = from._impl_.role_;
      }
    }
    if ((cached_has_bits & 0x00000080u) != 0) {
      if (from._internal_position_flags() != 0) {
        _this->_impl_.position_flags_ = from._impl_.position_flags_;
      }
    }
  }
  if ((cached_has_bits & 0x00000f00u) != 0) {
    if ((cached_has_bits & 0x00000100u) != 0) {
      if (from._internal_hw_model() != 0) {
        _this->_impl_.hw_model_ = from._impl_.hw_model_;
      }
    }
    if ((cached_has_bits & 0x00000200u) != 0) {
      if (from._internal_hasremotehardware() != 0) {
        _this->_impl_.hasremotehardware_ = from._impl_.hasremotehardware_;
      }
    }
    if ((cached_has_bits & 0x00000400u) != 0) {
      if (from._internal_haspkc() != 0) {
        _this->_impl_.haspkc_ = from._impl_.haspkc_;
      }
    }
    if ((cached_has_bits & 0x00000800u) != 0) {
      if (from._internal_excluded_modules() != 0) {
        _this->_impl_.excluded_modules_ = from._impl_.excluded_modules_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void DeviceMetadata::CopyFrom(const DeviceMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.DeviceMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void DeviceMetadata::InternalSwap(DeviceMetadata* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.firmware_version_, &other->_impl_.firmware_version_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DeviceMetadata, _impl_.excluded_modules_)
      + sizeof(DeviceMetadata::_impl_.excluded_modules_)
      - PROTOBUF_FIELD_OFFSET(DeviceMetadata, _impl_.device_state_version_)>(
          reinterpret_cast<char*>(&_impl_.device_state_version_),
          reinterpret_cast<char*>(&other->_impl_.device_state_version_));
}

::google::protobuf::Metadata DeviceMetadata::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class Heartbeat::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<Heartbeat>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(Heartbeat, _impl_._has_bits_);
};

Heartbeat::Heartbeat(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, Heartbeat_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:meshtastic.Heartbeat)
}
Heartbeat::Heartbeat(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Heartbeat& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, Heartbeat_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
}
PROTOBUF_NDEBUG_INLINE Heartbeat::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void Heartbeat::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.nonce_ = {};
}
Heartbeat::~Heartbeat() {
  // @@protoc_insertion_point(destructor:meshtastic.Heartbeat)
  SharedDtor(*this);
}
inline void Heartbeat::SharedDtor(MessageLite& self) {
  Heartbeat& this_ = static_cast<Heartbeat&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL Heartbeat::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) Heartbeat(arena);
}
constexpr auto Heartbeat::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(Heartbeat),
                                            alignof(Heartbeat));
}
constexpr auto Heartbeat::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_Heartbeat_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &Heartbeat::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<Heartbeat>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &Heartbeat::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<Heartbeat>(), &Heartbeat::ByteSizeLong,
              &Heartbeat::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(Heartbeat, _impl_._cached_size_),
          false,
      },
      &Heartbeat::kDescriptorMethods,
      &descriptor_table_meshtastic_2fmesh_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull Heartbeat_class_data_ =
        Heartbeat::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
Heartbeat::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&Heartbeat_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(Heartbeat_class_data_.tc_table);
  return Heartbeat_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2>
Heartbeat::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Heartbeat, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    Heartbeat_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::meshtastic::Heartbeat>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // uint32 nonce = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Heartbeat, _impl_.nonce_), 0>(),
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(Heartbeat, _impl_.nonce_)}},
  }}, {{
    65535, 65535
  }}, {{
    // uint32 nonce = 1;
    {PROTOBUF_FIELD_OFFSET(Heartbeat, _impl_.nonce_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void Heartbeat::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.Heartbeat)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.nonce_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL Heartbeat::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const Heartbeat& this_ = static_cast<const Heartbeat&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL Heartbeat::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const Heartbeat& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.Heartbeat)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // uint32 nonce = 1;
  if ((this_._impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (this_._internal_nonce() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          1, this_._internal_nonce(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.Heartbeat)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t Heartbeat::ByteSizeLong(const MessageLite& base) {
  const Heartbeat& this_ = static_cast<const Heartbeat&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t Heartbeat::ByteSizeLong() const {
  const Heartbeat& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:meshtastic.Heartbeat)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

   {
    // uint32 nonce = 1;
    cached_has_bits = this_._impl_._has_bits_[0];
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (this_._internal_nonce() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
            this_._internal_nonce());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void Heartbeat::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Heartbeat*>(&to_msg);
  auto& from = static_cast<const Heartbeat&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.Heartbeat)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    if (from._internal_nonce() != 0) {
      _this->_impl_.nonce_ = from._impl_.nonce_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Heartbeat::CopyFrom(const Heartbeat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.Heartbeat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Heartbeat::InternalSwap(Heartbeat* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.nonce_, other->_impl_.nonce_);
}

::google::protobuf::Metadata Heartbeat::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class NodeRemoteHardwarePin::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<NodeRemoteHardwarePin>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(NodeRemoteHardwarePin, _impl_._has_bits_);
};

void NodeRemoteHardwarePin::clear_pin() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pin_ != nullptr) _impl_.pin_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
NodeRemoteHardwarePin::NodeRemoteHardwarePin(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, NodeRemoteHardwarePin_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:meshtastic.NodeRemoteHardwarePin)
}
PROTOBUF_NDEBUG_INLINE NodeRemoteHardwarePin::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::meshtastic::NodeRemoteHardwarePin& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

NodeRemoteHardwarePin::NodeRemoteHardwarePin(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const NodeRemoteHardwarePin& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, NodeRemoteHardwarePin_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  NodeRemoteHardwarePin* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.pin_ = ((cached_has_bits & 0x00000001u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.pin_)
                : nullptr;
  _impl_.node_num_ = from._impl_.node_num_;

  // @@protoc_insertion_point(copy_constructor:meshtastic.NodeRemoteHardwarePin)
}
PROTOBUF_NDEBUG_INLINE NodeRemoteHardwarePin::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0} {}

inline void NodeRemoteHardwarePin::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, pin_),
           0,
           offsetof(Impl_, node_num_) -
               offsetof(Impl_, pin_) +
               sizeof(Impl_::node_num_));
}
NodeRemoteHardwarePin::~NodeRemoteHardwarePin() {
  // @@protoc_insertion_point(destructor:meshtastic.NodeRemoteHardwarePin)
  SharedDtor(*this);
}
inline void NodeRemoteHardwarePin::SharedDtor(MessageLite& self) {
  NodeRemoteHardwarePin& this_ = static_cast<NodeRemoteHardwarePin&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.pin_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL NodeRemoteHardwarePin::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) NodeRemoteHardwarePin(arena);
}
constexpr auto NodeRemoteHardwarePin::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(NodeRemoteHardwarePin),
                                            alignof(NodeRemoteHardwarePin));
}
constexpr auto NodeRemoteHardwarePin::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_NodeRemoteHardwarePin_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &NodeRemoteHardwarePin::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<NodeRemoteHardwarePin>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &NodeRemoteHardwarePin::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<NodeRemoteHardwarePin>(), &NodeRemoteHardwarePin::ByteSizeLong,
              &NodeRemoteHardwarePin::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(NodeRemoteHardwarePin, _impl_._cached_size_),
          false,
      },
      &NodeRemoteHardwarePin::kDescriptorMethods,
      &descriptor_table_meshtastic_2fmesh_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull NodeRemoteHardwarePin_class_data_ =
        NodeRemoteHardwarePin::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
NodeRemoteHardwarePin::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&NodeRemoteHardwarePin_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(NodeRemoteHardwarePin_class_data_.tc_table);
  return NodeRemoteHardwarePin_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 1, 0, 2>
NodeRemoteHardwarePin::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(NodeRemoteHardwarePin, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    NodeRemoteHardwarePin_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::meshtastic::NodeRemoteHardwarePin>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // .meshtastic.RemoteHardwarePin pin = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(NodeRemoteHardwarePin, _impl_.pin_)}},
    // uint32 node_num = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(NodeRemoteHardwarePin, _impl_.node_num_), 1>(),
     {8, 1, 0, PROTOBUF_FIELD_OFFSET(NodeRemoteHardwarePin, _impl_.node_num_)}},
  }}, {{
    65535, 65535
  }}, {{
    // uint32 node_num = 1;
    {PROTOBUF_FIELD_OFFSET(NodeRemoteHardwarePin, _impl_.node_num_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // .meshtastic.RemoteHardwarePin pin = 2;
    {PROTOBUF_FIELD_OFFSET(NodeRemoteHardwarePin, _impl_.pin_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::meshtastic::RemoteHardwarePin>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void NodeRemoteHardwarePin::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.NodeRemoteHardwarePin)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    ABSL_DCHECK(_impl_.pin_ != nullptr);
    _impl_.pin_->Clear();
  }
  _impl_.node_num_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL NodeRemoteHardwarePin::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const NodeRemoteHardwarePin& this_ = static_cast<const NodeRemoteHardwarePin&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL NodeRemoteHardwarePin::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const NodeRemoteHardwarePin& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.NodeRemoteHardwarePin)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // uint32 node_num = 1;
  if ((this_._impl_._has_bits_[0] & 0x00000002u) != 0) {
    if (this_._internal_node_num() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          1, this_._internal_node_num(), target);
    }
  }

  cached_has_bits = this_._impl_._has_bits_[0];
  // .meshtastic.RemoteHardwarePin pin = 2;
  if ((cached_has_bits & 0x00000001u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, *this_._impl_.pin_, this_._impl_.pin_->GetCachedSize(), target,
        stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.NodeRemoteHardwarePin)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t NodeRemoteHardwarePin::ByteSizeLong(const MessageLite& base) {
  const NodeRemoteHardwarePin& this_ = static_cast<const NodeRemoteHardwarePin&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t NodeRemoteHardwarePin::ByteSizeLong() const {
  const NodeRemoteHardwarePin& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:meshtastic.NodeRemoteHardwarePin)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    // .meshtastic.RemoteHardwarePin pin = 2;
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.pin_);
    }
    // uint32 node_num = 1;
    if ((cached_has_bits & 0x00000002u) != 0) {
      if (this_._internal_node_num() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
            this_._internal_node_num());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void NodeRemoteHardwarePin::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<NodeRemoteHardwarePin*>(&to_msg);
  auto& from = static_cast<const NodeRemoteHardwarePin&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.NodeRemoteHardwarePin)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      ABSL_DCHECK(from._impl_.pin_ != nullptr);
      if (_this->_impl_.pin_ == nullptr) {
        _this->_impl_.pin_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.pin_);
      } else {
        _this->_impl_.pin_->MergeFrom(*from._impl_.pin_);
      }
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      if (from._internal_node_num() != 0) {
        _this->_impl_.node_num_ = from._impl_.node_num_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void NodeRemoteHardwarePin::CopyFrom(const NodeRemoteHardwarePin& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.NodeRemoteHardwarePin)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void NodeRemoteHardwarePin::InternalSwap(NodeRemoteHardwarePin* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NodeRemoteHardwarePin, _impl_.node_num_)
      + sizeof(NodeRemoteHardwarePin::_impl_.node_num_)
      - PROTOBUF_FIELD_OFFSET(NodeRemoteHardwarePin, _impl_.pin_)>(
          reinterpret_cast<char*>(&_impl_.pin_),
          reinterpret_cast<char*>(&other->_impl_.pin_));
}

::google::protobuf::Metadata NodeRemoteHardwarePin::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class ChunkedPayload::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<ChunkedPayload>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(ChunkedPayload, _impl_._has_bits_);
};

ChunkedPayload::ChunkedPayload(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ChunkedPayload_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:meshtastic.ChunkedPayload)
}
PROTOBUF_NDEBUG_INLINE ChunkedPayload::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::meshtastic::ChunkedPayload& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        payload_chunk_(arena, from.payload_chunk_) {}

ChunkedPayload::ChunkedPayload(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const ChunkedPayload& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ChunkedPayload_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  ChunkedPayload* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, payload_id_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, payload_id_),
           offsetof(Impl_, chunk_index_) -
               offsetof(Impl_, payload_id_) +
               sizeof(Impl_::chunk_index_));

  // @@protoc_insertion_point(copy_constructor:meshtastic.ChunkedPayload)
}
PROTOBUF_NDEBUG_INLINE ChunkedPayload::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        payload_chunk_(arena) {}

inline void ChunkedPayload::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, payload_id_),
           0,
           offsetof(Impl_, chunk_index_) -
               offsetof(Impl_, payload_id_) +
               sizeof(Impl_::chunk_index_));
}
ChunkedPayload::~ChunkedPayload() {
  // @@protoc_insertion_point(destructor:meshtastic.ChunkedPayload)
  SharedDtor(*this);
}
inline void ChunkedPayload::SharedDtor(MessageLite& self) {
  ChunkedPayload& this_ = static_cast<ChunkedPayload&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.payload_chunk_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL ChunkedPayload::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) ChunkedPayload(arena);
}
constexpr auto ChunkedPayload::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(ChunkedPayload),
                                            alignof(ChunkedPayload));
}
constexpr auto ChunkedPayload::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_ChunkedPayload_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &ChunkedPayload::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<ChunkedPayload>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &ChunkedPayload::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<ChunkedPayload>(), &ChunkedPayload::ByteSizeLong,
              &ChunkedPayload::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(ChunkedPayload, _impl_._cached_size_),
          false,
      },
      &ChunkedPayload::kDescriptorMethods,
      &descriptor_table_meshtastic_2fmesh_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull ChunkedPayload_class_data_ =
        ChunkedPayload::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
ChunkedPayload::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&ChunkedPayload_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(ChunkedPayload_class_data_.tc_table);
  return ChunkedPayload_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 0, 2>
ChunkedPayload::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(ChunkedPayload, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    ChunkedPayload_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::meshtastic::ChunkedPayload>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // bytes payload_chunk = 4;
    {::_pbi::TcParser::FastBS1,
     {34, 0, 0, PROTOBUF_FIELD_OFFSET(ChunkedPayload, _impl_.payload_chunk_)}},
    // uint32 payload_id = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ChunkedPayload, _impl_.payload_id_), 1>(),
     {8, 1, 0, PROTOBUF_FIELD_OFFSET(ChunkedPayload, _impl_.payload_id_)}},
    // uint32 chunk_count = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ChunkedPayload, _impl_.chunk_count_), 2>(),
     {16, 2, 0, PROTOBUF_FIELD_OFFSET(ChunkedPayload, _impl_.chunk_count_)}},
    // uint32 chunk_index = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ChunkedPayload, _impl_.chunk_index_), 3>(),
     {24, 3, 0, PROTOBUF_FIELD_OFFSET(ChunkedPayload, _impl_.chunk_index_)}},
  }}, {{
    65535, 65535
  }}, {{
    // uint32 payload_id = 1;
    {PROTOBUF_FIELD_OFFSET(ChunkedPayload, _impl_.payload_id_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // uint32 chunk_count = 2;
    {PROTOBUF_FIELD_OFFSET(ChunkedPayload, _impl_.chunk_count_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // uint32 chunk_index = 3;
    {PROTOBUF_FIELD_OFFSET(ChunkedPayload, _impl_.chunk_index_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // bytes payload_chunk = 4;
    {PROTOBUF_FIELD_OFFSET(ChunkedPayload, _impl_.payload_chunk_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void ChunkedPayload::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.ChunkedPayload)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    _impl_.payload_chunk_.ClearNonDefaultToEmpty();
  }
  if ((cached_has_bits & 0x0000000eu) != 0) {
    ::memset(&_impl_.payload_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.chunk_index_) -
        reinterpret_cast<char*>(&_impl_.payload_id_)) + sizeof(_impl_.chunk_index_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL ChunkedPayload::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const ChunkedPayload& this_ = static_cast<const ChunkedPayload&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL ChunkedPayload::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const ChunkedPayload& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.ChunkedPayload)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // uint32 payload_id = 1;
  if ((this_._impl_._has_bits_[0] & 0x00000002u) != 0) {
    if (this_._internal_payload_id() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          1, this_._internal_payload_id(), target);
    }
  }

  // uint32 chunk_count = 2;
  if ((this_._impl_._has_bits_[0] & 0x00000004u) != 0) {
    if (this_._internal_chunk_count() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          2, this_._internal_chunk_count(), target);
    }
  }

  // uint32 chunk_index = 3;
  if ((this_._impl_._has_bits_[0] & 0x00000008u) != 0) {
    if (this_._internal_chunk_index() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          3, this_._internal_chunk_index(), target);
    }
  }

  // bytes payload_chunk = 4;
  if ((this_._impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (!this_._internal_payload_chunk().empty()) {
      const ::std::string& _s = this_._internal_payload_chunk();
      target = stream->WriteBytesMaybeAliased(4, _s, target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.ChunkedPayload)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t ChunkedPayload::ByteSizeLong(const MessageLite& base) {
  const ChunkedPayload& this_ = static_cast<const ChunkedPayload&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t ChunkedPayload::ByteSizeLong() const {
  const ChunkedPayload& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:meshtastic.ChunkedPayload)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000000fu) != 0) {
    // bytes payload_chunk = 4;
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (!this_._internal_payload_chunk().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                        this_._internal_payload_chunk());
      }
    }
    // uint32 payload_id = 1;
    if ((cached_has_bits & 0x00000002u) != 0) {
      if (this_._internal_payload_id() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
            this_._internal_payload_id());
      }
    }
    // uint32 chunk_count = 2;
    if ((cached_has_bits & 0x00000004u) != 0) {
      if (this_._internal_chunk_count() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
            this_._internal_chunk_count());
      }
    }
    // uint32 chunk_index = 3;
    if ((cached_has_bits & 0x00000008u) != 0) {
      if (this_._internal_chunk_index() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
            this_._internal_chunk_index());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void ChunkedPayload::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<ChunkedPayload*>(&to_msg);
  auto& from = static_cast<const ChunkedPayload&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.ChunkedPayload)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000000fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (!from._internal_payload_chunk().empty()) {
        _this->_internal_set_payload_chunk(from._internal_payload_chunk());
      } else {
        if (_this->_impl_.payload_chunk_.IsDefault()) {
          _this->_internal_set_payload_chunk("");
        }
      }
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      if (from._internal_payload_id() != 0) {
        _this->_impl_.payload_id_ = from._impl_.payload_id_;
      }
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      if (from._internal_chunk_count() != 0) {
        _this->_impl_.chunk_count_ = from._impl_.chunk_count_;
      }
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      if (from._internal_chunk_index() != 0) {
        _this->_impl_.chunk_index_ = from._impl_.chunk_index_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void ChunkedPayload::CopyFrom(const ChunkedPayload& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.ChunkedPayload)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void ChunkedPayload::InternalSwap(ChunkedPayload* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.payload_chunk_, &other->_impl_.payload_chunk_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ChunkedPayload, _impl_.chunk_index_)
      + sizeof(ChunkedPayload::_impl_.chunk_index_)
      - PROTOBUF_FIELD_OFFSET(ChunkedPayload, _impl_.payload_id_)>(
          reinterpret_cast<char*>(&_impl_.payload_id_),
          reinterpret_cast<char*>(&other->_impl_.payload_id_));
}

::google::protobuf::Metadata ChunkedPayload::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class resend_chunks::_Internal {
 public:
};

resend_chunks::resend_chunks(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, resend_chunks_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:meshtastic.resend_chunks)
}
PROTOBUF_NDEBUG_INLINE resend_chunks::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::meshtastic::resend_chunks& from_msg)
      : chunks_{visibility, arena, from.chunks_},
        _chunks_cached_byte_size_{0},
        _cached_size_{0} {}

resend_chunks::resend_chunks(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const resend_chunks& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, resend_chunks_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  resend_chunks* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:meshtastic.resend_chunks)
}
PROTOBUF_NDEBUG_INLINE resend_chunks::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : chunks_{visibility, arena},
        _chunks_cached_byte_size_{0},
        _cached_size_{0} {}

inline void resend_chunks::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
resend_chunks::~resend_chunks() {
  // @@protoc_insertion_point(destructor:meshtastic.resend_chunks)
  SharedDtor(*this);
}
inline void resend_chunks::SharedDtor(MessageLite& self) {
  resend_chunks& this_ = static_cast<resend_chunks&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL resend_chunks::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) resend_chunks(arena);
}
constexpr auto resend_chunks::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(resend_chunks, _impl_.chunks_) +
          decltype(resend_chunks::_impl_.chunks_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(resend_chunks), alignof(resend_chunks), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&resend_chunks::PlacementNew_,
                                 sizeof(resend_chunks),
                                 alignof(resend_chunks));
  }
}
constexpr auto resend_chunks::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_resend_chunks_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &resend_chunks::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<resend_chunks>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &resend_chunks::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<resend_chunks>(), &resend_chunks::ByteSizeLong,
              &resend_chunks::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(resend_chunks, _impl_._cached_size_),
          false,
      },
      &resend_chunks::kDescriptorMethods,
      &descriptor_table_meshtastic_2fmesh_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull resend_chunks_class_data_ =
        resend_chunks::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
resend_chunks::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&resend_chunks_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(resend_chunks_class_data_.tc_table);
  return resend_chunks_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2>
resend_chunks::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    resend_chunks_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::meshtastic::resend_chunks>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated uint32 chunks = 1;
    {::_pbi::TcParser::FastV32P1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(resend_chunks, _impl_.chunks_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated uint32 chunks = 1;
    {PROTOBUF_FIELD_OFFSET(resend_chunks, _impl_.chunks_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedUInt32)},
  }},
  // no aux_entries
  {{
  }},
};
PROTOBUF_NOINLINE void resend_chunks::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.resend_chunks)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.chunks_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL resend_chunks::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const resend_chunks& this_ = static_cast<const resend_chunks&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL resend_chunks::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const resend_chunks& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.resend_chunks)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated uint32 chunks = 1;
  {
    int byte_size = this_._impl_._chunks_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          1, this_._internal_chunks(), byte_size, target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.resend_chunks)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t resend_chunks::ByteSizeLong(const MessageLite& base) {
  const resend_chunks& this_ = static_cast<const resend_chunks&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t resend_chunks::ByteSizeLong() const {
  const resend_chunks& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:meshtastic.resend_chunks)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated uint32 chunks = 1;
    {
      total_size +=
          ::_pbi::WireFormatLite::UInt32SizeWithPackedTagSize(
              this_._internal_chunks(), 1,
              this_._impl_._chunks_cached_byte_size_);
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void resend_chunks::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<resend_chunks*>(&to_msg);
  auto& from = static_cast<const resend_chunks&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.resend_chunks)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_chunks()->MergeFrom(from._internal_chunks());
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void resend_chunks::CopyFrom(const resend_chunks& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.resend_chunks)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void resend_chunks::InternalSwap(resend_chunks* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.chunks_.InternalSwap(&other->_impl_.chunks_);
}

::google::protobuf::Metadata resend_chunks::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class ChunkedPayloadResponse::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<ChunkedPayloadResponse>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(ChunkedPayloadResponse, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::meshtastic::ChunkedPayloadResponse, _impl_._oneof_case_);
};

void ChunkedPayloadResponse::set_allocated_resend_chunks(::meshtastic::resend_chunks* PROTOBUF_NULLABLE resend_chunks) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_payload_variant();
  if (resend_chunks) {
    ::google::protobuf::Arena* submessage_arena = resend_chunks->GetArena();
    if (message_arena != submessage_arena) {
      resend_chunks = ::google::protobuf::internal::GetOwnedMessage(message_arena, resend_chunks, submessage_arena);
    }
    set_has_resend_chunks();
    _impl_.payload_variant_.resend_chunks_ = resend_chunks;
  }
  // @@protoc_insertion_point(field_set_allocated:meshtastic.ChunkedPayloadResponse.resend_chunks)
}
ChunkedPayloadResponse::ChunkedPayloadResponse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ChunkedPayloadResponse_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:meshtastic.ChunkedPayloadResponse)
}
PROTOBUF_NDEBUG_INLINE ChunkedPayloadResponse::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::meshtastic::ChunkedPayloadResponse& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        payload_variant_{},
        _oneof_case_{from._oneof_case_[0]} {}

ChunkedPayloadResponse::ChunkedPayloadResponse(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const ChunkedPayloadResponse& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, ChunkedPayloadResponse_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  ChunkedPayloadResponse* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.payload_id_ = from._impl_.payload_id_;
  switch (payload_variant_case()) {
    case PAYLOAD_VARIANT_NOT_SET:
      break;
      case kRequestTransfer:
        _impl_.payload_variant_.request_transfer_ = from._impl_.payload_variant_.request_transfer_;
        break;
      case kAcceptTransfer:
        _impl_.payload_variant_.accept_transfer_ = from._impl_.payload_variant_.accept_transfer_;
        break;
      case kResendChunks:
        _impl_.payload_variant_.resend_chunks_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.resend_chunks_);
        break;
  }

  // @@protoc_insertion_point(copy_constructor:meshtastic.ChunkedPayloadResponse)
}
PROTOBUF_NDEBUG_INLINE ChunkedPayloadResponse::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        payload_variant_{},
        _oneof_case_{} {}

inline void ChunkedPayloadResponse::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.payload_id_ = {};
}
ChunkedPayloadResponse::~ChunkedPayloadResponse() {
  // @@protoc_insertion_point(destructor:meshtastic.ChunkedPayloadResponse)
  SharedDtor(*this);
}
inline void ChunkedPayloadResponse::SharedDtor(MessageLite& self) {
  ChunkedPayloadResponse& this_ = static_cast<ChunkedPayloadResponse&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  if (this_.has_payload_variant()) {
    this_.clear_payload_variant();
  }
  this_._impl_.~Impl_();
}

void ChunkedPayloadResponse::clear_payload_variant() {
// @@protoc_insertion_point(one_of_clear_start:meshtastic.ChunkedPayloadResponse)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (payload_variant_case()) {
    case kRequestTransfer: {
      // No need to clear
      break;
    }
    case kAcceptTransfer: {
      // No need to clear
      break;
    }
    case kResendChunks: {
      if (GetArena() == nullptr) {
        delete _impl_.payload_variant_.resend_chunks_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_variant_.resend_chunks_);
      }
      break;
    }
    case PAYLOAD_VARIANT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = PAYLOAD_VARIANT_NOT_SET;
}


inline void* PROTOBUF_NONNULL ChunkedPayloadResponse::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) ChunkedPayloadResponse(arena);
}
constexpr auto ChunkedPayloadResponse::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(ChunkedPayloadResponse),
                                            alignof(ChunkedPayloadResponse));
}
constexpr auto ChunkedPayloadResponse::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_ChunkedPayloadResponse_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &ChunkedPayloadResponse::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<ChunkedPayloadResponse>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &ChunkedPayloadResponse::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<ChunkedPayloadResponse>(), &ChunkedPayloadResponse::ByteSizeLong,
              &ChunkedPayloadResponse::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(ChunkedPayloadResponse, _impl_._cached_size_),
          false,
      },
      &ChunkedPayloadResponse::kDescriptorMethods,
      &descriptor_table_meshtastic_2fmesh_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull ChunkedPayloadResponse_class_data_ =
        ChunkedPayloadResponse::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
ChunkedPayloadResponse::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&ChunkedPayloadResponse_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(ChunkedPayloadResponse_class_data_.tc_table);
  return ChunkedPayloadResponse_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 4, 1, 0, 2>
ChunkedPayloadResponse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(ChunkedPayloadResponse, _impl_._has_bits_),
    0, // no _extensions_
    4, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    ChunkedPayloadResponse_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::meshtastic::ChunkedPayloadResponse>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // uint32 payload_id = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ChunkedPayloadResponse, _impl_.payload_id_), 0>(),
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(ChunkedPayloadResponse, _impl_.payload_id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // uint32 payload_id = 1;
    {PROTOBUF_FIELD_OFFSET(ChunkedPayloadResponse, _impl_.payload_id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // bool request_transfer = 2;
    {PROTOBUF_FIELD_OFFSET(ChunkedPayloadResponse, _impl_.payload_variant_.request_transfer_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // bool accept_transfer = 3;
    {PROTOBUF_FIELD_OFFSET(ChunkedPayloadResponse, _impl_.payload_variant_.accept_transfer_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // .meshtastic.resend_chunks resend_chunks = 4;
    {PROTOBUF_FIELD_OFFSET(ChunkedPayloadResponse, _impl_.payload_variant_.resend_chunks_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::meshtastic::resend_chunks>()},
  }},
  {{
  }},
};
PROTOBUF_NOINLINE void ChunkedPayloadResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:meshtastic.ChunkedPayloadResponse)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.payload_id_ = 0u;
  clear_payload_variant();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL ChunkedPayloadResponse::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const ChunkedPayloadResponse& this_ = static_cast<const ChunkedPayloadResponse&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL ChunkedPayloadResponse::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const ChunkedPayloadResponse& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:meshtastic.ChunkedPayloadResponse)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // uint32 payload_id = 1;
  if ((this_._impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (this_._internal_payload_id() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          1, this_._internal_payload_id(), target);
    }
  }

  switch (this_.payload_variant_case()) {
    case kRequestTransfer: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          2, this_._internal_request_transfer(), target);
      break;
    }
    case kAcceptTransfer: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          3, this_._internal_accept_transfer(), target);
      break;
    }
    case kResendChunks: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          4, *this_._impl_.payload_variant_.resend_chunks_, this_._impl_.payload_variant_.resend_chunks_->GetCachedSize(), target,
          stream);
      break;
    }
    default:
      break;
  }
  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:meshtastic.ChunkedPayloadResponse)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t ChunkedPayloadResponse::ByteSizeLong(const MessageLite& base) {
  const ChunkedPayloadResponse& this_ = static_cast<const ChunkedPayloadResponse&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t ChunkedPayloadResponse::ByteSizeLong() const {
  const ChunkedPayloadResponse& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:meshtastic.ChunkedPayloadResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

   {
    // uint32 payload_id = 1;
    cached_has_bits = this_._impl_._has_bits_[0];
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (this_._internal_payload_id() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
            this_._internal_payload_id());
      }
    }
  }
  switch (this_.payload_variant_case()) {
    // bool request_transfer = 2;
    case kRequestTransfer: {
      total_size += 2;
      break;
    }
    // bool accept_transfer = 3;
    case kAcceptTransfer: {
      total_size += 2;
      break;
    }
    // .meshtastic.resend_chunks resend_chunks = 4;
    case kResendChunks: {
      total_size += 1 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.payload_variant_.resend_chunks_);
      break;
    }
    case PAYLOAD_VARIANT_NOT_SET: {
      break;
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void ChunkedPayloadResponse::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<ChunkedPayloadResponse*>(&to_msg);
  auto& from = static_cast<const ChunkedPayloadResponse&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:meshtastic.ChunkedPayloadResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    if (from._internal_payload_id() != 0) {
      _this->_impl_.payload_id_ = from._impl_.payload_id_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_payload_variant();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kRequestTransfer: {
        _this->_impl_.payload_variant_.request_transfer_ = from._impl_.payload_variant_.request_transfer_;
        break;
      }
      case kAcceptTransfer: {
        _this->_impl_.payload_variant_.accept_transfer_ = from._impl_.payload_variant_.accept_transfer_;
        break;
      }
      case kResendChunks: {
        if (oneof_needs_init) {
          _this->_impl_.payload_variant_.resend_chunks_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.payload_variant_.resend_chunks_);
        } else {
          _this->_impl_.payload_variant_.resend_chunks_->MergeFrom(*from._impl_.payload_variant_.resend_chunks_);
        }
        break;
      }
      case PAYLOAD_VARIANT_NOT_SET:
        break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void ChunkedPayloadResponse::CopyFrom(const ChunkedPayloadResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:meshtastic.ChunkedPayloadResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void ChunkedPayloadResponse::InternalSwap(ChunkedPayloadResponse* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.payload_id_, other->_impl_.payload_id_);
  swap(_impl_.payload_variant_, other->_impl_.payload_variant_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::google::protobuf::Metadata ChunkedPayloadResponse::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace meshtastic
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google
// @@protoc_insertion_point(global_scope)
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::std::false_type
    _static_init2_ [[maybe_unused]] =
        (::_pbi::AddDescriptors(&descriptor_table_meshtastic_2fmesh_2eproto),
         ::std::false_type{});
#include "google/protobuf/port_undef.inc"
